
AVR_2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000050f8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000052  00800060  000050f8  0000518c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000a6  008000b2  008000b2  000051de  2**0
                  ALLOC
  3 .stab         00006114  00000000  00000000  000051e0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000030ee  00000000  00000000  0000b2f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0000e3e2  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  0000e522  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  0000e692  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  000102db  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  000111c6  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  00011f74  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  000120d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  00012361  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00012b2f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 6e 19 	jmp	0x32dc	; 0x32dc <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 ef       	ldi	r30, 0xF8	; 248
      68:	f0 e5       	ldi	r31, 0x50	; 80
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a2 3b       	cpi	r26, 0xB2	; 178
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	11 e0       	ldi	r17, 0x01	; 1
      78:	a2 eb       	ldi	r26, 0xB2	; 178
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a8 35       	cpi	r26, 0x58	; 88
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 6b 06 	call	0xcd6	; 0xcd6 <main>
      8a:	0c 94 7a 28 	jmp	0x50f4	; 0x50f4 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 ee 26 	jmp	0x4ddc	; 0x4ddc <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a1 ea       	ldi	r26, 0xA1	; 161
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 0a 27 	jmp	0x4e14	; 0x4e14 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 fa 26 	jmp	0x4df4	; 0x4df4 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 16 27 	jmp	0x4e2c	; 0x4e2c <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 fa 26 	jmp	0x4df4	; 0x4df4 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 16 27 	jmp	0x4e2c	; 0x4e2c <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 ee 26 	jmp	0x4ddc	; 0x4ddc <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	81 ea       	ldi	r24, 0xA1	; 161
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 0a 27 	jmp	0x4e14	; 0x4e14 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 fa 26 	jmp	0x4df4	; 0x4df4 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 16 27 	jmp	0x4e2c	; 0x4e2c <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 fa 26 	jmp	0x4df4	; 0x4df4 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 16 27 	jmp	0x4e2c	; 0x4e2c <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 fa 26 	jmp	0x4df4	; 0x4df4 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 16 27 	jmp	0x4e2c	; 0x4e2c <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 fe 26 	jmp	0x4dfc	; 0x4dfc <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 1a 27 	jmp	0x4e34	; 0x4e34 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <ADC_voidInit>:
#include "DigExInterrupt.h"

#include <avr/delay.h>

void ADC_voidInit(void)
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	cd b7       	in	r28, 0x3d	; 61
     b4c:	de b7       	in	r29, 0x3e	; 62
	 * Vref selection -> 5v
	 * REFS1 : 0, REFS0 : 1
	 * Left adjustment
	 * ADLAR : 1
	 */
	ADMUX |=(REFS1<<7) | (REFS0<<6) | (ADLAR<<5);
     b4e:	a7 e2       	ldi	r26, 0x27	; 39
     b50:	b0 e0       	ldi	r27, 0x00	; 0
     b52:	e7 e2       	ldi	r30, 0x27	; 39
     b54:	f0 e0       	ldi	r31, 0x00	; 0
     b56:	80 81       	ld	r24, Z
     b58:	80 62       	ori	r24, 0x20	; 32
     b5a:	8c 93       	st	X, r24
	 *  ADATE : Auto trigger disabled -> 	0	 |		1
	 *  ADIF: Interrupt Flag 		->		0	 |		0
	 *  ADIE: Interrupt Enable	 ->			0	 |		1
	 *  ADPS: Prescaler
	 */
	ADCSRA |= (ADEN<<7) | (ADATE<<5) | (ADIF<<4) | (ADIE<<3) |(ADPS0<<0) | (ADPS1<<1) | (ADPS2<<2);
     b5c:	a6 e2       	ldi	r26, 0x26	; 38
     b5e:	b0 e0       	ldi	r27, 0x00	; 0
     b60:	e6 e2       	ldi	r30, 0x26	; 38
     b62:	f0 e0       	ldi	r31, 0x00	; 0
     b64:	80 81       	ld	r24, Z
     b66:	87 68       	ori	r24, 0x87	; 135
     b68:	8c 93       	st	X, r24


//	SREG |=(1<<7);
}
     b6a:	cf 91       	pop	r28
     b6c:	df 91       	pop	r29
     b6e:	08 95       	ret

00000b70 <ADC_u16Read>:

U16 ADC_u16Read(U32 Pin)
{
     b70:	df 93       	push	r29
     b72:	cf 93       	push	r28
     b74:	cd b7       	in	r28, 0x3d	; 61
     b76:	de b7       	in	r29, 0x3e	; 62
     b78:	62 97       	sbiw	r28, 0x12	; 18
     b7a:	0f b6       	in	r0, 0x3f	; 63
     b7c:	f8 94       	cli
     b7e:	de bf       	out	0x3e, r29	; 62
     b80:	0f be       	out	0x3f, r0	; 63
     b82:	cd bf       	out	0x3d, r28	; 61
     b84:	6f 87       	std	Y+15, r22	; 0x0f
     b86:	78 8b       	std	Y+16, r23	; 0x10
     b88:	89 8b       	std	Y+17, r24	; 0x11
     b8a:	9a 8b       	std	Y+18, r25	; 0x12
	ADCH = 0;
     b8c:	e5 e2       	ldi	r30, 0x25	; 37
     b8e:	f0 e0       	ldi	r31, 0x00	; 0
     b90:	10 82       	st	Z, r1
	// Analog channel and Gain selection : 5
//	ADMUX |= (0<<3) | (1<<2) | (0<<1) |(1<<0);

	Pin = Pin&0b00000111;
     b92:	8f 85       	ldd	r24, Y+15	; 0x0f
     b94:	98 89       	ldd	r25, Y+16	; 0x10
     b96:	a9 89       	ldd	r26, Y+17	; 0x11
     b98:	ba 89       	ldd	r27, Y+18	; 0x12
     b9a:	87 70       	andi	r24, 0x07	; 7
     b9c:	90 70       	andi	r25, 0x00	; 0
     b9e:	a0 70       	andi	r26, 0x00	; 0
     ba0:	b0 70       	andi	r27, 0x00	; 0
     ba2:	8f 87       	std	Y+15, r24	; 0x0f
     ba4:	98 8b       	std	Y+16, r25	; 0x10
     ba6:	a9 8b       	std	Y+17, r26	; 0x11
     ba8:	ba 8b       	std	Y+18, r27	; 0x12
	ADMUX|= Pin;
     baa:	a7 e2       	ldi	r26, 0x27	; 39
     bac:	b0 e0       	ldi	r27, 0x00	; 0
     bae:	e7 e2       	ldi	r30, 0x27	; 39
     bb0:	f0 e0       	ldi	r31, 0x00	; 0
     bb2:	90 81       	ld	r25, Z
     bb4:	8f 85       	ldd	r24, Y+15	; 0x0f
     bb6:	89 2b       	or	r24, r25
     bb8:	8c 93       	st	X, r24

	/*
	 *  ADC Start Conversion
	 *  ADSC -> 1
	 */
	set_bit(ADCSRA, 6);
     bba:	a6 e2       	ldi	r26, 0x26	; 38
     bbc:	b0 e0       	ldi	r27, 0x00	; 0
     bbe:	e6 e2       	ldi	r30, 0x26	; 38
     bc0:	f0 e0       	ldi	r31, 0x00	; 0
     bc2:	80 81       	ld	r24, Z
     bc4:	80 64       	ori	r24, 0x40	; 64
     bc6:	8c 93       	st	X, r24
     bc8:	80 e0       	ldi	r24, 0x00	; 0
     bca:	90 e0       	ldi	r25, 0x00	; 0
     bcc:	a8 ec       	ldi	r26, 0xC8	; 200
     bce:	b2 e4       	ldi	r27, 0x42	; 66
     bd0:	8b 87       	std	Y+11, r24	; 0x0b
     bd2:	9c 87       	std	Y+12, r25	; 0x0c
     bd4:	ad 87       	std	Y+13, r26	; 0x0d
     bd6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     bd8:	6b 85       	ldd	r22, Y+11	; 0x0b
     bda:	7c 85       	ldd	r23, Y+12	; 0x0c
     bdc:	8d 85       	ldd	r24, Y+13	; 0x0d
     bde:	9e 85       	ldd	r25, Y+14	; 0x0e
     be0:	20 e0       	ldi	r18, 0x00	; 0
     be2:	30 e0       	ldi	r19, 0x00	; 0
     be4:	4a ef       	ldi	r20, 0xFA	; 250
     be6:	54 e4       	ldi	r21, 0x44	; 68
     be8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     bec:	dc 01       	movw	r26, r24
     bee:	cb 01       	movw	r24, r22
     bf0:	8f 83       	std	Y+7, r24	; 0x07
     bf2:	98 87       	std	Y+8, r25	; 0x08
     bf4:	a9 87       	std	Y+9, r26	; 0x09
     bf6:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     bf8:	6f 81       	ldd	r22, Y+7	; 0x07
     bfa:	78 85       	ldd	r23, Y+8	; 0x08
     bfc:	89 85       	ldd	r24, Y+9	; 0x09
     bfe:	9a 85       	ldd	r25, Y+10	; 0x0a
     c00:	20 e0       	ldi	r18, 0x00	; 0
     c02:	30 e0       	ldi	r19, 0x00	; 0
     c04:	40 e8       	ldi	r20, 0x80	; 128
     c06:	5f e3       	ldi	r21, 0x3F	; 63
     c08:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     c0c:	88 23       	and	r24, r24
     c0e:	2c f4       	brge	.+10     	; 0xc1a <ADC_u16Read+0xaa>
		__ticks = 1;
     c10:	81 e0       	ldi	r24, 0x01	; 1
     c12:	90 e0       	ldi	r25, 0x00	; 0
     c14:	9e 83       	std	Y+6, r25	; 0x06
     c16:	8d 83       	std	Y+5, r24	; 0x05
     c18:	3f c0       	rjmp	.+126    	; 0xc98 <ADC_u16Read+0x128>
	else if (__tmp > 65535)
     c1a:	6f 81       	ldd	r22, Y+7	; 0x07
     c1c:	78 85       	ldd	r23, Y+8	; 0x08
     c1e:	89 85       	ldd	r24, Y+9	; 0x09
     c20:	9a 85       	ldd	r25, Y+10	; 0x0a
     c22:	20 e0       	ldi	r18, 0x00	; 0
     c24:	3f ef       	ldi	r19, 0xFF	; 255
     c26:	4f e7       	ldi	r20, 0x7F	; 127
     c28:	57 e4       	ldi	r21, 0x47	; 71
     c2a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     c2e:	18 16       	cp	r1, r24
     c30:	4c f5       	brge	.+82     	; 0xc84 <ADC_u16Read+0x114>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     c32:	6b 85       	ldd	r22, Y+11	; 0x0b
     c34:	7c 85       	ldd	r23, Y+12	; 0x0c
     c36:	8d 85       	ldd	r24, Y+13	; 0x0d
     c38:	9e 85       	ldd	r25, Y+14	; 0x0e
     c3a:	20 e0       	ldi	r18, 0x00	; 0
     c3c:	30 e0       	ldi	r19, 0x00	; 0
     c3e:	40 e2       	ldi	r20, 0x20	; 32
     c40:	51 e4       	ldi	r21, 0x41	; 65
     c42:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     c46:	dc 01       	movw	r26, r24
     c48:	cb 01       	movw	r24, r22
     c4a:	bc 01       	movw	r22, r24
     c4c:	cd 01       	movw	r24, r26
     c4e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     c52:	dc 01       	movw	r26, r24
     c54:	cb 01       	movw	r24, r22
     c56:	9e 83       	std	Y+6, r25	; 0x06
     c58:	8d 83       	std	Y+5, r24	; 0x05
     c5a:	0f c0       	rjmp	.+30     	; 0xc7a <ADC_u16Read+0x10a>
     c5c:	88 ec       	ldi	r24, 0xC8	; 200
     c5e:	90 e0       	ldi	r25, 0x00	; 0
     c60:	9c 83       	std	Y+4, r25	; 0x04
     c62:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     c64:	8b 81       	ldd	r24, Y+3	; 0x03
     c66:	9c 81       	ldd	r25, Y+4	; 0x04
     c68:	01 97       	sbiw	r24, 0x01	; 1
     c6a:	f1 f7       	brne	.-4      	; 0xc68 <ADC_u16Read+0xf8>
     c6c:	9c 83       	std	Y+4, r25	; 0x04
     c6e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     c70:	8d 81       	ldd	r24, Y+5	; 0x05
     c72:	9e 81       	ldd	r25, Y+6	; 0x06
     c74:	01 97       	sbiw	r24, 0x01	; 1
     c76:	9e 83       	std	Y+6, r25	; 0x06
     c78:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     c7a:	8d 81       	ldd	r24, Y+5	; 0x05
     c7c:	9e 81       	ldd	r25, Y+6	; 0x06
     c7e:	00 97       	sbiw	r24, 0x00	; 0
     c80:	69 f7       	brne	.-38     	; 0xc5c <ADC_u16Read+0xec>
     c82:	14 c0       	rjmp	.+40     	; 0xcac <ADC_u16Read+0x13c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     c84:	6f 81       	ldd	r22, Y+7	; 0x07
     c86:	78 85       	ldd	r23, Y+8	; 0x08
     c88:	89 85       	ldd	r24, Y+9	; 0x09
     c8a:	9a 85       	ldd	r25, Y+10	; 0x0a
     c8c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     c90:	dc 01       	movw	r26, r24
     c92:	cb 01       	movw	r24, r22
     c94:	9e 83       	std	Y+6, r25	; 0x06
     c96:	8d 83       	std	Y+5, r24	; 0x05
     c98:	8d 81       	ldd	r24, Y+5	; 0x05
     c9a:	9e 81       	ldd	r25, Y+6	; 0x06
     c9c:	9a 83       	std	Y+2, r25	; 0x02
     c9e:	89 83       	std	Y+1, r24	; 0x01
     ca0:	89 81       	ldd	r24, Y+1	; 0x01
     ca2:	9a 81       	ldd	r25, Y+2	; 0x02
     ca4:	01 97       	sbiw	r24, 0x01	; 1
     ca6:	f1 f7       	brne	.-4      	; 0xca4 <ADC_u16Read+0x134>
     ca8:	9a 83       	std	Y+2, r25	; 0x02
     caa:	89 83       	std	Y+1, r24	; 0x01
	while(!get_bit(ADCSRA, 4));

	/* Clear interrupt flag,
	 * ADIF -> 1
	 */
	set_bit(ADCSRA,4);
     cac:	a6 e2       	ldi	r26, 0x26	; 38
     cae:	b0 e0       	ldi	r27, 0x00	; 0
     cb0:	e6 e2       	ldi	r30, 0x26	; 38
     cb2:	f0 e0       	ldi	r31, 0x00	; 0
     cb4:	80 81       	ld	r24, Z
     cb6:	80 61       	ori	r24, 0x10	; 16
     cb8:	8c 93       	st	X, r24

	return ADCH;
     cba:	e5 e2       	ldi	r30, 0x25	; 37
     cbc:	f0 e0       	ldi	r31, 0x00	; 0
     cbe:	80 81       	ld	r24, Z
     cc0:	88 2f       	mov	r24, r24
     cc2:	90 e0       	ldi	r25, 0x00	; 0
}
     cc4:	62 96       	adiw	r28, 0x12	; 18
     cc6:	0f b6       	in	r0, 0x3f	; 63
     cc8:	f8 94       	cli
     cca:	de bf       	out	0x3e, r29	; 62
     ccc:	0f be       	out	0x3f, r0	; 63
     cce:	cd bf       	out	0x3d, r28	; 61
     cd0:	cf 91       	pop	r28
     cd2:	df 91       	pop	r29
     cd4:	08 95       	ret

00000cd6 <main>:




int main(void)
{
     cd6:	af 92       	push	r10
     cd8:	bf 92       	push	r11
     cda:	cf 92       	push	r12
     cdc:	df 92       	push	r13
     cde:	ef 92       	push	r14
     ce0:	ff 92       	push	r15
     ce2:	0f 93       	push	r16
     ce4:	df 93       	push	r29
     ce6:	cf 93       	push	r28
     ce8:	cd b7       	in	r28, 0x3d	; 61
     cea:	de b7       	in	r29, 0x3e	; 62


	/* DIO configuration */
	DIO_voidSetPinDirection(DIO_u8PinA6, DIO_u8PinIp);
     cec:	86 e0       	ldi	r24, 0x06	; 6
     cee:	60 e0       	ldi	r22, 0x00	; 0
     cf0:	0e 94 a0 08 	call	0x1140	; 0x1140 <DIO_voidSetPinDirection>
	DIO_voidSetPortDirection('C', DIO_u8PinOp);
     cf4:	83 e4       	ldi	r24, 0x43	; 67
     cf6:	61 e0       	ldi	r22, 0x01	; 1
     cf8:	0e 94 04 0b 	call	0x1608	; 0x1608 <DIO_voidSetPortDirection>

	/*initialize Resources*/
	LCD_voidInit();
     cfc:	0e 94 a9 0b 	call	0x1752	; 0x1752 <LCD_voidInit>
	ADC_voidInit();
     d00:	0e 94 a3 05 	call	0xb46	; 0xb46 <ADC_voidInit>

	/*Create Queue to hold temperature value*/
	xTempValue_Queue = xQueueCreate(1, sizeof (int));
     d04:	81 e0       	ldi	r24, 0x01	; 1
     d06:	62 e0       	ldi	r22, 0x02	; 2
     d08:	0e 94 71 19 	call	0x32e2	; 0x32e2 <xQueueCreate>
     d0c:	90 93 51 01 	sts	0x0151, r25
     d10:	80 93 50 01 	sts	0x0150, r24

	/*If Queue was created, proceed, otherwise do nothing.*/
	if(xTempValue_Queue != NULL){
     d14:	80 91 50 01 	lds	r24, 0x0150
     d18:	90 91 51 01 	lds	r25, 0x0151
     d1c:	00 97       	sbiw	r24, 0x00	; 0
     d1e:	c1 f1       	breq	.+112    	; 0xd90 <main+0xba>

		/*Create tasks*/
		xTaskCreate(check_temp_task, "check_temp", 400, NULL, TASK1_PRIORITY, NULL);
     d20:	20 e6       	ldi	r18, 0x60	; 96
     d22:	30 e0       	ldi	r19, 0x00	; 0
     d24:	89 ec       	ldi	r24, 0xC9	; 201
     d26:	96 e0       	ldi	r25, 0x06	; 6
     d28:	b9 01       	movw	r22, r18
     d2a:	40 e9       	ldi	r20, 0x90	; 144
     d2c:	51 e0       	ldi	r21, 0x01	; 1
     d2e:	20 e0       	ldi	r18, 0x00	; 0
     d30:	30 e0       	ldi	r19, 0x00	; 0
     d32:	02 e0       	ldi	r16, 0x02	; 2
     d34:	ee 24       	eor	r14, r14
     d36:	ff 24       	eor	r15, r15
     d38:	cc 24       	eor	r12, r12
     d3a:	dd 24       	eor	r13, r13
     d3c:	aa 24       	eor	r10, r10
     d3e:	bb 24       	eor	r11, r11
     d40:	0e 94 e7 1e 	call	0x3dce	; 0x3dce <xTaskGenericCreate>
		xTaskCreate(write_temp_task, "write_temp", 400, NULL, TASK2_PRIORITY, NULL);
     d44:	2b e6       	ldi	r18, 0x6B	; 107
     d46:	30 e0       	ldi	r19, 0x00	; 0
     d48:	8e e7       	ldi	r24, 0x7E	; 126
     d4a:	97 e0       	ldi	r25, 0x07	; 7
     d4c:	b9 01       	movw	r22, r18
     d4e:	40 e9       	ldi	r20, 0x90	; 144
     d50:	51 e0       	ldi	r21, 0x01	; 1
     d52:	20 e0       	ldi	r18, 0x00	; 0
     d54:	30 e0       	ldi	r19, 0x00	; 0
     d56:	02 e0       	ldi	r16, 0x02	; 2
     d58:	ee 24       	eor	r14, r14
     d5a:	ff 24       	eor	r15, r15
     d5c:	cc 24       	eor	r12, r12
     d5e:	dd 24       	eor	r13, r13
     d60:	aa 24       	eor	r10, r10
     d62:	bb 24       	eor	r11, r11
     d64:	0e 94 e7 1e 	call	0x3dce	; 0x3dce <xTaskGenericCreate>

		/*Create binary semaphore with initial value 0 because we used it for sync. between INTERRUPT and TASK*/
		temp_ready_semaphore = xSemaphoreCreateRecursiveMutex();
     d68:	0e 94 1a 1a 	call	0x3434	; 0x3434 <xQueueCreateMutex>
     d6c:	90 93 53 01 	sts	0x0153, r25
     d70:	80 93 52 01 	sts	0x0152, r24


		/*start Scheduler */
		vTaskStartScheduler();
     d74:	0e 94 e0 20 	call	0x41c0	; 0x41c0 <vTaskStartScheduler>
	}
	else{
		for(;;);
	}
	
	return 0;
     d78:	80 e0       	ldi	r24, 0x00	; 0
     d7a:	90 e0       	ldi	r25, 0x00	; 0
    
}
     d7c:	cf 91       	pop	r28
     d7e:	df 91       	pop	r29
     d80:	0f 91       	pop	r16
     d82:	ff 90       	pop	r15
     d84:	ef 90       	pop	r14
     d86:	df 90       	pop	r13
     d88:	cf 90       	pop	r12
     d8a:	bf 90       	pop	r11
     d8c:	af 90       	pop	r10
     d8e:	08 95       	ret
     d90:	ff cf       	rjmp	.-2      	; 0xd90 <main+0xba>

00000d92 <check_temp_task>:

/*Task1 Code */
 void check_temp_task(void*pvParamter)
{
     d92:	df 93       	push	r29
     d94:	cf 93       	push	r28
     d96:	cd b7       	in	r28, 0x3d	; 61
     d98:	de b7       	in	r29, 0x3e	; 62
     d9a:	65 97       	sbiw	r28, 0x15	; 21
     d9c:	0f b6       	in	r0, 0x3f	; 63
     d9e:	f8 94       	cli
     da0:	de bf       	out	0x3e, r29	; 62
     da2:	0f be       	out	0x3f, r0	; 63
     da4:	cd bf       	out	0x3d, r28	; 61
     da6:	9d 8b       	std	Y+21, r25	; 0x15
     da8:	8c 8b       	std	Y+20, r24	; 0x14
//	xSemaphoreTakeRecursive(temp_ready_semaphore, 100);
	int sampled, analog;
	portBASE_TYPE xStatus;
	for (;;)
	{
		sampled = ADC_u16Read(5);
     daa:	65 e0       	ldi	r22, 0x05	; 5
     dac:	70 e0       	ldi	r23, 0x00	; 0
     dae:	80 e0       	ldi	r24, 0x00	; 0
     db0:	90 e0       	ldi	r25, 0x00	; 0
     db2:	0e 94 b8 05 	call	0xb70	; 0xb70 <ADC_u16Read>
     db6:	99 8b       	std	Y+17, r25	; 0x11
     db8:	88 8b       	std	Y+16, r24	; 0x10
		analog = (sampled * (5*100))/RESOLUTION;
     dba:	28 89       	ldd	r18, Y+16	; 0x10
     dbc:	39 89       	ldd	r19, Y+17	; 0x11
     dbe:	84 ef       	ldi	r24, 0xF4	; 244
     dc0:	91 e0       	ldi	r25, 0x01	; 1
     dc2:	ac 01       	movw	r20, r24
     dc4:	24 9f       	mul	r18, r20
     dc6:	c0 01       	movw	r24, r0
     dc8:	25 9f       	mul	r18, r21
     dca:	90 0d       	add	r25, r0
     dcc:	34 9f       	mul	r19, r20
     dce:	90 0d       	add	r25, r0
     dd0:	11 24       	eor	r1, r1
     dd2:	2f ef       	ldi	r18, 0xFF	; 255
     dd4:	30 e0       	ldi	r19, 0x00	; 0
     dd6:	b9 01       	movw	r22, r18
     dd8:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <__divmodhi4>
     ddc:	cb 01       	movw	r24, r22
     dde:	9b 8b       	std	Y+19, r25	; 0x13
     de0:	8a 8b       	std	Y+18, r24	; 0x12

		xStatus = xQueueSendToBack(xTempValue_Queue, &analog, 1000);
     de2:	80 91 50 01 	lds	r24, 0x0150
     de6:	90 91 51 01 	lds	r25, 0x0151
     dea:	9e 01       	movw	r18, r28
     dec:	2e 5e       	subi	r18, 0xEE	; 238
     dee:	3f 4f       	sbci	r19, 0xFF	; 255
     df0:	b9 01       	movw	r22, r18
     df2:	48 ee       	ldi	r20, 0xE8	; 232
     df4:	53 e0       	ldi	r21, 0x03	; 3
     df6:	20 e0       	ldi	r18, 0x00	; 0
     df8:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <xQueueGenericSend>
     dfc:	8f 87       	std	Y+15, r24	; 0x0f
		if (xStatus != pdPASS){
     dfe:	8f 85       	ldd	r24, Y+15	; 0x0f
     e00:	81 30       	cpi	r24, 0x01	; 1
     e02:	09 f4       	brne	.+2      	; 0xe06 <check_temp_task+0x74>
     e04:	78 c0       	rjmp	.+240    	; 0xef6 <check_temp_task+0x164>
			LCD_voidClear();
     e06:	0e 94 d1 11 	call	0x23a2	; 0x23a2 <LCD_voidClear>
			LCD_voidString("T1: Not Send.");
     e0a:	86 e7       	ldi	r24, 0x76	; 118
     e0c:	90 e0       	ldi	r25, 0x00	; 0
     e0e:	0e 94 97 10 	call	0x212e	; 0x212e <LCD_voidString>
     e12:	80 e0       	ldi	r24, 0x00	; 0
     e14:	90 e0       	ldi	r25, 0x00	; 0
     e16:	aa ef       	ldi	r26, 0xFA	; 250
     e18:	b4 e4       	ldi	r27, 0x44	; 68
     e1a:	8b 87       	std	Y+11, r24	; 0x0b
     e1c:	9c 87       	std	Y+12, r25	; 0x0c
     e1e:	ad 87       	std	Y+13, r26	; 0x0d
     e20:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     e22:	6b 85       	ldd	r22, Y+11	; 0x0b
     e24:	7c 85       	ldd	r23, Y+12	; 0x0c
     e26:	8d 85       	ldd	r24, Y+13	; 0x0d
     e28:	9e 85       	ldd	r25, Y+14	; 0x0e
     e2a:	20 e0       	ldi	r18, 0x00	; 0
     e2c:	30 e0       	ldi	r19, 0x00	; 0
     e2e:	4a ef       	ldi	r20, 0xFA	; 250
     e30:	54 e4       	ldi	r21, 0x44	; 68
     e32:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     e36:	dc 01       	movw	r26, r24
     e38:	cb 01       	movw	r24, r22
     e3a:	8f 83       	std	Y+7, r24	; 0x07
     e3c:	98 87       	std	Y+8, r25	; 0x08
     e3e:	a9 87       	std	Y+9, r26	; 0x09
     e40:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     e42:	6f 81       	ldd	r22, Y+7	; 0x07
     e44:	78 85       	ldd	r23, Y+8	; 0x08
     e46:	89 85       	ldd	r24, Y+9	; 0x09
     e48:	9a 85       	ldd	r25, Y+10	; 0x0a
     e4a:	20 e0       	ldi	r18, 0x00	; 0
     e4c:	30 e0       	ldi	r19, 0x00	; 0
     e4e:	40 e8       	ldi	r20, 0x80	; 128
     e50:	5f e3       	ldi	r21, 0x3F	; 63
     e52:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     e56:	88 23       	and	r24, r24
     e58:	2c f4       	brge	.+10     	; 0xe64 <check_temp_task+0xd2>
		__ticks = 1;
     e5a:	81 e0       	ldi	r24, 0x01	; 1
     e5c:	90 e0       	ldi	r25, 0x00	; 0
     e5e:	9e 83       	std	Y+6, r25	; 0x06
     e60:	8d 83       	std	Y+5, r24	; 0x05
     e62:	3f c0       	rjmp	.+126    	; 0xee2 <check_temp_task+0x150>
	else if (__tmp > 65535)
     e64:	6f 81       	ldd	r22, Y+7	; 0x07
     e66:	78 85       	ldd	r23, Y+8	; 0x08
     e68:	89 85       	ldd	r24, Y+9	; 0x09
     e6a:	9a 85       	ldd	r25, Y+10	; 0x0a
     e6c:	20 e0       	ldi	r18, 0x00	; 0
     e6e:	3f ef       	ldi	r19, 0xFF	; 255
     e70:	4f e7       	ldi	r20, 0x7F	; 127
     e72:	57 e4       	ldi	r21, 0x47	; 71
     e74:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     e78:	18 16       	cp	r1, r24
     e7a:	4c f5       	brge	.+82     	; 0xece <check_temp_task+0x13c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     e7c:	6b 85       	ldd	r22, Y+11	; 0x0b
     e7e:	7c 85       	ldd	r23, Y+12	; 0x0c
     e80:	8d 85       	ldd	r24, Y+13	; 0x0d
     e82:	9e 85       	ldd	r25, Y+14	; 0x0e
     e84:	20 e0       	ldi	r18, 0x00	; 0
     e86:	30 e0       	ldi	r19, 0x00	; 0
     e88:	40 e2       	ldi	r20, 0x20	; 32
     e8a:	51 e4       	ldi	r21, 0x41	; 65
     e8c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     e90:	dc 01       	movw	r26, r24
     e92:	cb 01       	movw	r24, r22
     e94:	bc 01       	movw	r22, r24
     e96:	cd 01       	movw	r24, r26
     e98:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     e9c:	dc 01       	movw	r26, r24
     e9e:	cb 01       	movw	r24, r22
     ea0:	9e 83       	std	Y+6, r25	; 0x06
     ea2:	8d 83       	std	Y+5, r24	; 0x05
     ea4:	0f c0       	rjmp	.+30     	; 0xec4 <check_temp_task+0x132>
     ea6:	88 ec       	ldi	r24, 0xC8	; 200
     ea8:	90 e0       	ldi	r25, 0x00	; 0
     eaa:	9c 83       	std	Y+4, r25	; 0x04
     eac:	8b 83       	std	Y+3, r24	; 0x03
     eae:	8b 81       	ldd	r24, Y+3	; 0x03
     eb0:	9c 81       	ldd	r25, Y+4	; 0x04
     eb2:	01 97       	sbiw	r24, 0x01	; 1
     eb4:	f1 f7       	brne	.-4      	; 0xeb2 <check_temp_task+0x120>
     eb6:	9c 83       	std	Y+4, r25	; 0x04
     eb8:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     eba:	8d 81       	ldd	r24, Y+5	; 0x05
     ebc:	9e 81       	ldd	r25, Y+6	; 0x06
     ebe:	01 97       	sbiw	r24, 0x01	; 1
     ec0:	9e 83       	std	Y+6, r25	; 0x06
     ec2:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     ec4:	8d 81       	ldd	r24, Y+5	; 0x05
     ec6:	9e 81       	ldd	r25, Y+6	; 0x06
     ec8:	00 97       	sbiw	r24, 0x00	; 0
     eca:	69 f7       	brne	.-38     	; 0xea6 <check_temp_task+0x114>
     ecc:	14 c0       	rjmp	.+40     	; 0xef6 <check_temp_task+0x164>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     ece:	6f 81       	ldd	r22, Y+7	; 0x07
     ed0:	78 85       	ldd	r23, Y+8	; 0x08
     ed2:	89 85       	ldd	r24, Y+9	; 0x09
     ed4:	9a 85       	ldd	r25, Y+10	; 0x0a
     ed6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     eda:	dc 01       	movw	r26, r24
     edc:	cb 01       	movw	r24, r22
     ede:	9e 83       	std	Y+6, r25	; 0x06
     ee0:	8d 83       	std	Y+5, r24	; 0x05
     ee2:	8d 81       	ldd	r24, Y+5	; 0x05
     ee4:	9e 81       	ldd	r25, Y+6	; 0x06
     ee6:	9a 83       	std	Y+2, r25	; 0x02
     ee8:	89 83       	std	Y+1, r24	; 0x01
     eea:	89 81       	ldd	r24, Y+1	; 0x01
     eec:	9a 81       	ldd	r25, Y+2	; 0x02
     eee:	01 97       	sbiw	r24, 0x01	; 1
     ef0:	f1 f7       	brne	.-4      	; 0xeee <check_temp_task+0x15c>
     ef2:	9a 83       	std	Y+2, r25	; 0x02
     ef4:	89 83       	std	Y+1, r24	; 0x01
			_delay_ms(2000);
		}
//	xSemaphoreGive(temp_ready_semaphore);
		taskYIELD();
     ef6:	0e 94 5e 18 	call	0x30bc	; 0x30bc <vPortYield>
     efa:	57 cf       	rjmp	.-338    	; 0xdaa <check_temp_task+0x18>

00000efc <write_temp_task>:
		
}

/*Task 2 Code*/
 void write_temp_task(void*pvParamter)
{
     efc:	df 93       	push	r29
     efe:	cf 93       	push	r28
     f00:	cd b7       	in	r28, 0x3d	; 61
     f02:	de b7       	in	r29, 0x3e	; 62
     f04:	a1 97       	sbiw	r28, 0x21	; 33
     f06:	0f b6       	in	r0, 0x3f	; 63
     f08:	f8 94       	cli
     f0a:	de bf       	out	0x3e, r29	; 62
     f0c:	0f be       	out	0x3f, r0	; 63
     f0e:	cd bf       	out	0x3d, r28	; 61
     f10:	99 a3       	std	Y+33, r25	; 0x21
     f12:	88 a3       	std	Y+32, r24	; 0x20
	 portBASE_TYPE xStatus;
	 int recieveValue;

	while(1)
	{
		if(uxQueueMessagesWaiting(xTempValue_Queue)!=0){
     f14:	80 91 50 01 	lds	r24, 0x0150
     f18:	90 91 51 01 	lds	r25, 0x0151
     f1c:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <uxQueueMessagesWaiting>
     f20:	88 23       	and	r24, r24
     f22:	c1 f3       	breq	.-16     	; 0xf14 <write_temp_task+0x18>
			xStatus = xQueueReceive(xTempValue_Queue, &recieveValue, 1000/portTICK_RATE_MS);
     f24:	80 91 50 01 	lds	r24, 0x0150
     f28:	90 91 51 01 	lds	r25, 0x0151
     f2c:	9e 01       	movw	r18, r28
     f2e:	22 5e       	subi	r18, 0xE2	; 226
     f30:	3f 4f       	sbci	r19, 0xFF	; 255
     f32:	b9 01       	movw	r22, r18
     f34:	44 e6       	ldi	r20, 0x64	; 100
     f36:	50 e0       	ldi	r21, 0x00	; 0
     f38:	20 e0       	ldi	r18, 0x00	; 0
     f3a:	0e 94 cc 1b 	call	0x3798	; 0x3798 <xQueueGenericReceive>
     f3e:	8d 8f       	std	Y+29, r24	; 0x1d
			if(xStatus==pdPASS){
     f40:	8d 8d       	ldd	r24, Y+29	; 0x1d
     f42:	81 30       	cpi	r24, 0x01	; 1
     f44:	09 f0       	breq	.+2      	; 0xf48 <write_temp_task+0x4c>
     f46:	83 c0       	rjmp	.+262    	; 0x104e <write_temp_task+0x152>
				LCD_voidClear();
     f48:	0e 94 d1 11 	call	0x23a2	; 0x23a2 <LCD_voidClear>
				LCD_voidString("Temp:");
     f4c:	84 e8       	ldi	r24, 0x84	; 132
     f4e:	90 e0       	ldi	r25, 0x00	; 0
     f50:	0e 94 97 10 	call	0x212e	; 0x212e <LCD_voidString>
				LCD_voidInteger(recieveValue);
     f54:	8e 8d       	ldd	r24, Y+30	; 0x1e
     f56:	9f 8d       	ldd	r25, Y+31	; 0x1f
     f58:	aa 27       	eor	r26, r26
     f5a:	97 fd       	sbrc	r25, 7
     f5c:	a0 95       	com	r26
     f5e:	ba 2f       	mov	r27, r26
     f60:	bc 01       	movw	r22, r24
     f62:	cd 01       	movw	r24, r26
     f64:	0e 94 3a 11 	call	0x2274	; 0x2274 <LCD_voidInteger>
     f68:	80 e0       	ldi	r24, 0x00	; 0
     f6a:	90 e0       	ldi	r25, 0x00	; 0
     f6c:	aa ef       	ldi	r26, 0xFA	; 250
     f6e:	b4 e4       	ldi	r27, 0x44	; 68
     f70:	89 8f       	std	Y+25, r24	; 0x19
     f72:	9a 8f       	std	Y+26, r25	; 0x1a
     f74:	ab 8f       	std	Y+27, r26	; 0x1b
     f76:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     f78:	69 8d       	ldd	r22, Y+25	; 0x19
     f7a:	7a 8d       	ldd	r23, Y+26	; 0x1a
     f7c:	8b 8d       	ldd	r24, Y+27	; 0x1b
     f7e:	9c 8d       	ldd	r25, Y+28	; 0x1c
     f80:	20 e0       	ldi	r18, 0x00	; 0
     f82:	30 e0       	ldi	r19, 0x00	; 0
     f84:	4a ef       	ldi	r20, 0xFA	; 250
     f86:	54 e4       	ldi	r21, 0x44	; 68
     f88:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     f8c:	dc 01       	movw	r26, r24
     f8e:	cb 01       	movw	r24, r22
     f90:	8d 8b       	std	Y+21, r24	; 0x15
     f92:	9e 8b       	std	Y+22, r25	; 0x16
     f94:	af 8b       	std	Y+23, r26	; 0x17
     f96:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
     f98:	6d 89       	ldd	r22, Y+21	; 0x15
     f9a:	7e 89       	ldd	r23, Y+22	; 0x16
     f9c:	8f 89       	ldd	r24, Y+23	; 0x17
     f9e:	98 8d       	ldd	r25, Y+24	; 0x18
     fa0:	20 e0       	ldi	r18, 0x00	; 0
     fa2:	30 e0       	ldi	r19, 0x00	; 0
     fa4:	40 e8       	ldi	r20, 0x80	; 128
     fa6:	5f e3       	ldi	r21, 0x3F	; 63
     fa8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     fac:	88 23       	and	r24, r24
     fae:	2c f4       	brge	.+10     	; 0xfba <write_temp_task+0xbe>
		__ticks = 1;
     fb0:	81 e0       	ldi	r24, 0x01	; 1
     fb2:	90 e0       	ldi	r25, 0x00	; 0
     fb4:	9c 8b       	std	Y+20, r25	; 0x14
     fb6:	8b 8b       	std	Y+19, r24	; 0x13
     fb8:	3f c0       	rjmp	.+126    	; 0x1038 <write_temp_task+0x13c>
	else if (__tmp > 65535)
     fba:	6d 89       	ldd	r22, Y+21	; 0x15
     fbc:	7e 89       	ldd	r23, Y+22	; 0x16
     fbe:	8f 89       	ldd	r24, Y+23	; 0x17
     fc0:	98 8d       	ldd	r25, Y+24	; 0x18
     fc2:	20 e0       	ldi	r18, 0x00	; 0
     fc4:	3f ef       	ldi	r19, 0xFF	; 255
     fc6:	4f e7       	ldi	r20, 0x7F	; 127
     fc8:	57 e4       	ldi	r21, 0x47	; 71
     fca:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     fce:	18 16       	cp	r1, r24
     fd0:	4c f5       	brge	.+82     	; 0x1024 <write_temp_task+0x128>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     fd2:	69 8d       	ldd	r22, Y+25	; 0x19
     fd4:	7a 8d       	ldd	r23, Y+26	; 0x1a
     fd6:	8b 8d       	ldd	r24, Y+27	; 0x1b
     fd8:	9c 8d       	ldd	r25, Y+28	; 0x1c
     fda:	20 e0       	ldi	r18, 0x00	; 0
     fdc:	30 e0       	ldi	r19, 0x00	; 0
     fde:	40 e2       	ldi	r20, 0x20	; 32
     fe0:	51 e4       	ldi	r21, 0x41	; 65
     fe2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     fe6:	dc 01       	movw	r26, r24
     fe8:	cb 01       	movw	r24, r22
     fea:	bc 01       	movw	r22, r24
     fec:	cd 01       	movw	r24, r26
     fee:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     ff2:	dc 01       	movw	r26, r24
     ff4:	cb 01       	movw	r24, r22
     ff6:	9c 8b       	std	Y+20, r25	; 0x14
     ff8:	8b 8b       	std	Y+19, r24	; 0x13
     ffa:	0f c0       	rjmp	.+30     	; 0x101a <write_temp_task+0x11e>
     ffc:	88 ec       	ldi	r24, 0xC8	; 200
     ffe:	90 e0       	ldi	r25, 0x00	; 0
    1000:	9a 8b       	std	Y+18, r25	; 0x12
    1002:	89 8b       	std	Y+17, r24	; 0x11
    1004:	89 89       	ldd	r24, Y+17	; 0x11
    1006:	9a 89       	ldd	r25, Y+18	; 0x12
    1008:	01 97       	sbiw	r24, 0x01	; 1
    100a:	f1 f7       	brne	.-4      	; 0x1008 <write_temp_task+0x10c>
    100c:	9a 8b       	std	Y+18, r25	; 0x12
    100e:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1010:	8b 89       	ldd	r24, Y+19	; 0x13
    1012:	9c 89       	ldd	r25, Y+20	; 0x14
    1014:	01 97       	sbiw	r24, 0x01	; 1
    1016:	9c 8b       	std	Y+20, r25	; 0x14
    1018:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    101a:	8b 89       	ldd	r24, Y+19	; 0x13
    101c:	9c 89       	ldd	r25, Y+20	; 0x14
    101e:	00 97       	sbiw	r24, 0x00	; 0
    1020:	69 f7       	brne	.-38     	; 0xffc <write_temp_task+0x100>
    1022:	78 cf       	rjmp	.-272    	; 0xf14 <write_temp_task+0x18>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1024:	6d 89       	ldd	r22, Y+21	; 0x15
    1026:	7e 89       	ldd	r23, Y+22	; 0x16
    1028:	8f 89       	ldd	r24, Y+23	; 0x17
    102a:	98 8d       	ldd	r25, Y+24	; 0x18
    102c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1030:	dc 01       	movw	r26, r24
    1032:	cb 01       	movw	r24, r22
    1034:	9c 8b       	std	Y+20, r25	; 0x14
    1036:	8b 8b       	std	Y+19, r24	; 0x13
    1038:	8b 89       	ldd	r24, Y+19	; 0x13
    103a:	9c 89       	ldd	r25, Y+20	; 0x14
    103c:	98 8b       	std	Y+16, r25	; 0x10
    103e:	8f 87       	std	Y+15, r24	; 0x0f
    1040:	8f 85       	ldd	r24, Y+15	; 0x0f
    1042:	98 89       	ldd	r25, Y+16	; 0x10
    1044:	01 97       	sbiw	r24, 0x01	; 1
    1046:	f1 f7       	brne	.-4      	; 0x1044 <write_temp_task+0x148>
    1048:	98 8b       	std	Y+16, r25	; 0x10
    104a:	8f 87       	std	Y+15, r24	; 0x0f
    104c:	63 cf       	rjmp	.-314    	; 0xf14 <write_temp_task+0x18>
				_delay_ms(2000);
			}
			else{
				LCD_voidClear();
    104e:	0e 94 d1 11 	call	0x23a2	; 0x23a2 <LCD_voidClear>
				LCD_voidString("T2: Not received.");
    1052:	8a e8       	ldi	r24, 0x8A	; 138
    1054:	90 e0       	ldi	r25, 0x00	; 0
    1056:	0e 94 97 10 	call	0x212e	; 0x212e <LCD_voidString>
    105a:	80 e0       	ldi	r24, 0x00	; 0
    105c:	90 e0       	ldi	r25, 0x00	; 0
    105e:	aa ef       	ldi	r26, 0xFA	; 250
    1060:	b4 e4       	ldi	r27, 0x44	; 68
    1062:	8b 87       	std	Y+11, r24	; 0x0b
    1064:	9c 87       	std	Y+12, r25	; 0x0c
    1066:	ad 87       	std	Y+13, r26	; 0x0d
    1068:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    106a:	6b 85       	ldd	r22, Y+11	; 0x0b
    106c:	7c 85       	ldd	r23, Y+12	; 0x0c
    106e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1070:	9e 85       	ldd	r25, Y+14	; 0x0e
    1072:	20 e0       	ldi	r18, 0x00	; 0
    1074:	30 e0       	ldi	r19, 0x00	; 0
    1076:	4a ef       	ldi	r20, 0xFA	; 250
    1078:	54 e4       	ldi	r21, 0x44	; 68
    107a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    107e:	dc 01       	movw	r26, r24
    1080:	cb 01       	movw	r24, r22
    1082:	8f 83       	std	Y+7, r24	; 0x07
    1084:	98 87       	std	Y+8, r25	; 0x08
    1086:	a9 87       	std	Y+9, r26	; 0x09
    1088:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    108a:	6f 81       	ldd	r22, Y+7	; 0x07
    108c:	78 85       	ldd	r23, Y+8	; 0x08
    108e:	89 85       	ldd	r24, Y+9	; 0x09
    1090:	9a 85       	ldd	r25, Y+10	; 0x0a
    1092:	20 e0       	ldi	r18, 0x00	; 0
    1094:	30 e0       	ldi	r19, 0x00	; 0
    1096:	40 e8       	ldi	r20, 0x80	; 128
    1098:	5f e3       	ldi	r21, 0x3F	; 63
    109a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    109e:	88 23       	and	r24, r24
    10a0:	2c f4       	brge	.+10     	; 0x10ac <write_temp_task+0x1b0>
		__ticks = 1;
    10a2:	81 e0       	ldi	r24, 0x01	; 1
    10a4:	90 e0       	ldi	r25, 0x00	; 0
    10a6:	9e 83       	std	Y+6, r25	; 0x06
    10a8:	8d 83       	std	Y+5, r24	; 0x05
    10aa:	3f c0       	rjmp	.+126    	; 0x112a <write_temp_task+0x22e>
	else if (__tmp > 65535)
    10ac:	6f 81       	ldd	r22, Y+7	; 0x07
    10ae:	78 85       	ldd	r23, Y+8	; 0x08
    10b0:	89 85       	ldd	r24, Y+9	; 0x09
    10b2:	9a 85       	ldd	r25, Y+10	; 0x0a
    10b4:	20 e0       	ldi	r18, 0x00	; 0
    10b6:	3f ef       	ldi	r19, 0xFF	; 255
    10b8:	4f e7       	ldi	r20, 0x7F	; 127
    10ba:	57 e4       	ldi	r21, 0x47	; 71
    10bc:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    10c0:	18 16       	cp	r1, r24
    10c2:	4c f5       	brge	.+82     	; 0x1116 <write_temp_task+0x21a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    10c4:	6b 85       	ldd	r22, Y+11	; 0x0b
    10c6:	7c 85       	ldd	r23, Y+12	; 0x0c
    10c8:	8d 85       	ldd	r24, Y+13	; 0x0d
    10ca:	9e 85       	ldd	r25, Y+14	; 0x0e
    10cc:	20 e0       	ldi	r18, 0x00	; 0
    10ce:	30 e0       	ldi	r19, 0x00	; 0
    10d0:	40 e2       	ldi	r20, 0x20	; 32
    10d2:	51 e4       	ldi	r21, 0x41	; 65
    10d4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    10d8:	dc 01       	movw	r26, r24
    10da:	cb 01       	movw	r24, r22
    10dc:	bc 01       	movw	r22, r24
    10de:	cd 01       	movw	r24, r26
    10e0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    10e4:	dc 01       	movw	r26, r24
    10e6:	cb 01       	movw	r24, r22
    10e8:	9e 83       	std	Y+6, r25	; 0x06
    10ea:	8d 83       	std	Y+5, r24	; 0x05
    10ec:	0f c0       	rjmp	.+30     	; 0x110c <write_temp_task+0x210>
    10ee:	88 ec       	ldi	r24, 0xC8	; 200
    10f0:	90 e0       	ldi	r25, 0x00	; 0
    10f2:	9c 83       	std	Y+4, r25	; 0x04
    10f4:	8b 83       	std	Y+3, r24	; 0x03
    10f6:	8b 81       	ldd	r24, Y+3	; 0x03
    10f8:	9c 81       	ldd	r25, Y+4	; 0x04
    10fa:	01 97       	sbiw	r24, 0x01	; 1
    10fc:	f1 f7       	brne	.-4      	; 0x10fa <write_temp_task+0x1fe>
    10fe:	9c 83       	std	Y+4, r25	; 0x04
    1100:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1102:	8d 81       	ldd	r24, Y+5	; 0x05
    1104:	9e 81       	ldd	r25, Y+6	; 0x06
    1106:	01 97       	sbiw	r24, 0x01	; 1
    1108:	9e 83       	std	Y+6, r25	; 0x06
    110a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    110c:	8d 81       	ldd	r24, Y+5	; 0x05
    110e:	9e 81       	ldd	r25, Y+6	; 0x06
    1110:	00 97       	sbiw	r24, 0x00	; 0
    1112:	69 f7       	brne	.-38     	; 0x10ee <write_temp_task+0x1f2>
    1114:	ff ce       	rjmp	.-514    	; 0xf14 <write_temp_task+0x18>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1116:	6f 81       	ldd	r22, Y+7	; 0x07
    1118:	78 85       	ldd	r23, Y+8	; 0x08
    111a:	89 85       	ldd	r24, Y+9	; 0x09
    111c:	9a 85       	ldd	r25, Y+10	; 0x0a
    111e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1122:	dc 01       	movw	r26, r24
    1124:	cb 01       	movw	r24, r22
    1126:	9e 83       	std	Y+6, r25	; 0x06
    1128:	8d 83       	std	Y+5, r24	; 0x05
    112a:	8d 81       	ldd	r24, Y+5	; 0x05
    112c:	9e 81       	ldd	r25, Y+6	; 0x06
    112e:	9a 83       	std	Y+2, r25	; 0x02
    1130:	89 83       	std	Y+1, r24	; 0x01
    1132:	89 81       	ldd	r24, Y+1	; 0x01
    1134:	9a 81       	ldd	r25, Y+2	; 0x02
    1136:	01 97       	sbiw	r24, 0x01	; 1
    1138:	f1 f7       	brne	.-4      	; 0x1136 <write_temp_task+0x23a>
    113a:	9a 83       	std	Y+2, r25	; 0x02
    113c:	89 83       	std	Y+1, r24	; 0x01
    113e:	ea ce       	rjmp	.-556    	; 0xf14 <write_temp_task+0x18>

00001140 <DIO_voidSetPinDirection>:

/*
 *  States the Direction of the PIN: INPUT/OUTPUT
 */
extern void DIO_voidSetPinDirection(U8 DIO_u8LocalPinToSet, U8 DIO_u8DIOLocalDirection)
{
    1140:	df 93       	push	r29
    1142:	cf 93       	push	r28
    1144:	00 d0       	rcall	.+0      	; 0x1146 <DIO_voidSetPinDirection+0x6>
    1146:	cd b7       	in	r28, 0x3d	; 61
    1148:	de b7       	in	r29, 0x3e	; 62
    114a:	89 83       	std	Y+1, r24	; 0x01
    114c:	6a 83       	std	Y+2, r22	; 0x02
	if((DIO_u8LocalPinToSet>=0 && DIO_u8LocalPinToSet<=31) && (DIO_u8DIOLocalDirection==0 || DIO_u8DIOLocalDirection==1))
    114e:	89 81       	ldd	r24, Y+1	; 0x01
    1150:	80 32       	cpi	r24, 0x20	; 32
    1152:	08 f0       	brcs	.+2      	; 0x1156 <DIO_voidSetPinDirection+0x16>
    1154:	cd c0       	rjmp	.+410    	; 0x12f0 <DIO_voidSetPinDirection+0x1b0>
    1156:	8a 81       	ldd	r24, Y+2	; 0x02
    1158:	88 23       	and	r24, r24
    115a:	21 f0       	breq	.+8      	; 0x1164 <DIO_voidSetPinDirection+0x24>
    115c:	8a 81       	ldd	r24, Y+2	; 0x02
    115e:	81 30       	cpi	r24, 0x01	; 1
    1160:	09 f0       	breq	.+2      	; 0x1164 <DIO_voidSetPinDirection+0x24>
    1162:	c6 c0       	rjmp	.+396    	; 0x12f0 <DIO_voidSetPinDirection+0x1b0>
	{
		if( (DIO_u8LocalPinToSet / 8) == 0)
    1164:	89 81       	ldd	r24, Y+1	; 0x01
    1166:	88 30       	cpi	r24, 0x08	; 8
    1168:	70 f5       	brcc	.+92     	; 0x11c6 <DIO_voidSetPinDirection+0x86>
		{
			assign_bit(DDRA, (DIO_u8LocalPinToSet %8), DIO_u8DIOLocalDirection);
    116a:	aa e3       	ldi	r26, 0x3A	; 58
    116c:	b0 e0       	ldi	r27, 0x00	; 0
    116e:	ea e3       	ldi	r30, 0x3A	; 58
    1170:	f0 e0       	ldi	r31, 0x00	; 0
    1172:	80 81       	ld	r24, Z
    1174:	48 2f       	mov	r20, r24
    1176:	89 81       	ldd	r24, Y+1	; 0x01
    1178:	88 2f       	mov	r24, r24
    117a:	90 e0       	ldi	r25, 0x00	; 0
    117c:	9c 01       	movw	r18, r24
    117e:	27 70       	andi	r18, 0x07	; 7
    1180:	30 70       	andi	r19, 0x00	; 0
    1182:	81 e0       	ldi	r24, 0x01	; 1
    1184:	90 e0       	ldi	r25, 0x00	; 0
    1186:	02 c0       	rjmp	.+4      	; 0x118c <DIO_voidSetPinDirection+0x4c>
    1188:	88 0f       	add	r24, r24
    118a:	99 1f       	adc	r25, r25
    118c:	2a 95       	dec	r18
    118e:	e2 f7       	brpl	.-8      	; 0x1188 <DIO_voidSetPinDirection+0x48>
    1190:	80 95       	com	r24
    1192:	84 23       	and	r24, r20
    1194:	8c 93       	st	X, r24
    1196:	aa e3       	ldi	r26, 0x3A	; 58
    1198:	b0 e0       	ldi	r27, 0x00	; 0
    119a:	ea e3       	ldi	r30, 0x3A	; 58
    119c:	f0 e0       	ldi	r31, 0x00	; 0
    119e:	80 81       	ld	r24, Z
    11a0:	48 2f       	mov	r20, r24
    11a2:	8a 81       	ldd	r24, Y+2	; 0x02
    11a4:	28 2f       	mov	r18, r24
    11a6:	30 e0       	ldi	r19, 0x00	; 0
    11a8:	89 81       	ldd	r24, Y+1	; 0x01
    11aa:	88 2f       	mov	r24, r24
    11ac:	90 e0       	ldi	r25, 0x00	; 0
    11ae:	87 70       	andi	r24, 0x07	; 7
    11b0:	90 70       	andi	r25, 0x00	; 0
    11b2:	b9 01       	movw	r22, r18
    11b4:	02 c0       	rjmp	.+4      	; 0x11ba <DIO_voidSetPinDirection+0x7a>
    11b6:	66 0f       	add	r22, r22
    11b8:	77 1f       	adc	r23, r23
    11ba:	8a 95       	dec	r24
    11bc:	e2 f7       	brpl	.-8      	; 0x11b6 <DIO_voidSetPinDirection+0x76>
    11be:	cb 01       	movw	r24, r22
    11c0:	84 2b       	or	r24, r20
    11c2:	8c 93       	st	X, r24
    11c4:	95 c0       	rjmp	.+298    	; 0x12f0 <DIO_voidSetPinDirection+0x1b0>
		}
		else if ( (DIO_u8LocalPinToSet / 8) == 1)
    11c6:	89 81       	ldd	r24, Y+1	; 0x01
    11c8:	88 50       	subi	r24, 0x08	; 8
    11ca:	88 30       	cpi	r24, 0x08	; 8
    11cc:	70 f5       	brcc	.+92     	; 0x122a <DIO_voidSetPinDirection+0xea>
		{
			assign_bit(DDRB, (DIO_u8LocalPinToSet %8), DIO_u8DIOLocalDirection);
    11ce:	a7 e3       	ldi	r26, 0x37	; 55
    11d0:	b0 e0       	ldi	r27, 0x00	; 0
    11d2:	e7 e3       	ldi	r30, 0x37	; 55
    11d4:	f0 e0       	ldi	r31, 0x00	; 0
    11d6:	80 81       	ld	r24, Z
    11d8:	48 2f       	mov	r20, r24
    11da:	89 81       	ldd	r24, Y+1	; 0x01
    11dc:	88 2f       	mov	r24, r24
    11de:	90 e0       	ldi	r25, 0x00	; 0
    11e0:	9c 01       	movw	r18, r24
    11e2:	27 70       	andi	r18, 0x07	; 7
    11e4:	30 70       	andi	r19, 0x00	; 0
    11e6:	81 e0       	ldi	r24, 0x01	; 1
    11e8:	90 e0       	ldi	r25, 0x00	; 0
    11ea:	02 c0       	rjmp	.+4      	; 0x11f0 <DIO_voidSetPinDirection+0xb0>
    11ec:	88 0f       	add	r24, r24
    11ee:	99 1f       	adc	r25, r25
    11f0:	2a 95       	dec	r18
    11f2:	e2 f7       	brpl	.-8      	; 0x11ec <DIO_voidSetPinDirection+0xac>
    11f4:	80 95       	com	r24
    11f6:	84 23       	and	r24, r20
    11f8:	8c 93       	st	X, r24
    11fa:	a7 e3       	ldi	r26, 0x37	; 55
    11fc:	b0 e0       	ldi	r27, 0x00	; 0
    11fe:	e7 e3       	ldi	r30, 0x37	; 55
    1200:	f0 e0       	ldi	r31, 0x00	; 0
    1202:	80 81       	ld	r24, Z
    1204:	48 2f       	mov	r20, r24
    1206:	8a 81       	ldd	r24, Y+2	; 0x02
    1208:	28 2f       	mov	r18, r24
    120a:	30 e0       	ldi	r19, 0x00	; 0
    120c:	89 81       	ldd	r24, Y+1	; 0x01
    120e:	88 2f       	mov	r24, r24
    1210:	90 e0       	ldi	r25, 0x00	; 0
    1212:	87 70       	andi	r24, 0x07	; 7
    1214:	90 70       	andi	r25, 0x00	; 0
    1216:	b9 01       	movw	r22, r18
    1218:	02 c0       	rjmp	.+4      	; 0x121e <DIO_voidSetPinDirection+0xde>
    121a:	66 0f       	add	r22, r22
    121c:	77 1f       	adc	r23, r23
    121e:	8a 95       	dec	r24
    1220:	e2 f7       	brpl	.-8      	; 0x121a <DIO_voidSetPinDirection+0xda>
    1222:	cb 01       	movw	r24, r22
    1224:	84 2b       	or	r24, r20
    1226:	8c 93       	st	X, r24
    1228:	63 c0       	rjmp	.+198    	; 0x12f0 <DIO_voidSetPinDirection+0x1b0>
		}
		else if ( (DIO_u8LocalPinToSet / 8) == 2)
    122a:	89 81       	ldd	r24, Y+1	; 0x01
    122c:	80 51       	subi	r24, 0x10	; 16
    122e:	88 30       	cpi	r24, 0x08	; 8
    1230:	70 f5       	brcc	.+92     	; 0x128e <DIO_voidSetPinDirection+0x14e>
		{
			assign_bit(DDRC, (DIO_u8LocalPinToSet %8), DIO_u8DIOLocalDirection);
    1232:	a4 e3       	ldi	r26, 0x34	; 52
    1234:	b0 e0       	ldi	r27, 0x00	; 0
    1236:	e4 e3       	ldi	r30, 0x34	; 52
    1238:	f0 e0       	ldi	r31, 0x00	; 0
    123a:	80 81       	ld	r24, Z
    123c:	48 2f       	mov	r20, r24
    123e:	89 81       	ldd	r24, Y+1	; 0x01
    1240:	88 2f       	mov	r24, r24
    1242:	90 e0       	ldi	r25, 0x00	; 0
    1244:	9c 01       	movw	r18, r24
    1246:	27 70       	andi	r18, 0x07	; 7
    1248:	30 70       	andi	r19, 0x00	; 0
    124a:	81 e0       	ldi	r24, 0x01	; 1
    124c:	90 e0       	ldi	r25, 0x00	; 0
    124e:	02 c0       	rjmp	.+4      	; 0x1254 <DIO_voidSetPinDirection+0x114>
    1250:	88 0f       	add	r24, r24
    1252:	99 1f       	adc	r25, r25
    1254:	2a 95       	dec	r18
    1256:	e2 f7       	brpl	.-8      	; 0x1250 <DIO_voidSetPinDirection+0x110>
    1258:	80 95       	com	r24
    125a:	84 23       	and	r24, r20
    125c:	8c 93       	st	X, r24
    125e:	a4 e3       	ldi	r26, 0x34	; 52
    1260:	b0 e0       	ldi	r27, 0x00	; 0
    1262:	e4 e3       	ldi	r30, 0x34	; 52
    1264:	f0 e0       	ldi	r31, 0x00	; 0
    1266:	80 81       	ld	r24, Z
    1268:	48 2f       	mov	r20, r24
    126a:	8a 81       	ldd	r24, Y+2	; 0x02
    126c:	28 2f       	mov	r18, r24
    126e:	30 e0       	ldi	r19, 0x00	; 0
    1270:	89 81       	ldd	r24, Y+1	; 0x01
    1272:	88 2f       	mov	r24, r24
    1274:	90 e0       	ldi	r25, 0x00	; 0
    1276:	87 70       	andi	r24, 0x07	; 7
    1278:	90 70       	andi	r25, 0x00	; 0
    127a:	b9 01       	movw	r22, r18
    127c:	02 c0       	rjmp	.+4      	; 0x1282 <DIO_voidSetPinDirection+0x142>
    127e:	66 0f       	add	r22, r22
    1280:	77 1f       	adc	r23, r23
    1282:	8a 95       	dec	r24
    1284:	e2 f7       	brpl	.-8      	; 0x127e <DIO_voidSetPinDirection+0x13e>
    1286:	cb 01       	movw	r24, r22
    1288:	84 2b       	or	r24, r20
    128a:	8c 93       	st	X, r24
    128c:	31 c0       	rjmp	.+98     	; 0x12f0 <DIO_voidSetPinDirection+0x1b0>
		}
		else if ( (DIO_u8LocalPinToSet / 8) == 3)
    128e:	89 81       	ldd	r24, Y+1	; 0x01
    1290:	88 51       	subi	r24, 0x18	; 24
    1292:	88 30       	cpi	r24, 0x08	; 8
    1294:	68 f5       	brcc	.+90     	; 0x12f0 <DIO_voidSetPinDirection+0x1b0>
		{
			assign_bit(DDRD, (DIO_u8LocalPinToSet %8), DIO_u8DIOLocalDirection);
    1296:	a1 e3       	ldi	r26, 0x31	; 49
    1298:	b0 e0       	ldi	r27, 0x00	; 0
    129a:	e1 e3       	ldi	r30, 0x31	; 49
    129c:	f0 e0       	ldi	r31, 0x00	; 0
    129e:	80 81       	ld	r24, Z
    12a0:	48 2f       	mov	r20, r24
    12a2:	89 81       	ldd	r24, Y+1	; 0x01
    12a4:	88 2f       	mov	r24, r24
    12a6:	90 e0       	ldi	r25, 0x00	; 0
    12a8:	9c 01       	movw	r18, r24
    12aa:	27 70       	andi	r18, 0x07	; 7
    12ac:	30 70       	andi	r19, 0x00	; 0
    12ae:	81 e0       	ldi	r24, 0x01	; 1
    12b0:	90 e0       	ldi	r25, 0x00	; 0
    12b2:	02 c0       	rjmp	.+4      	; 0x12b8 <DIO_voidSetPinDirection+0x178>
    12b4:	88 0f       	add	r24, r24
    12b6:	99 1f       	adc	r25, r25
    12b8:	2a 95       	dec	r18
    12ba:	e2 f7       	brpl	.-8      	; 0x12b4 <DIO_voidSetPinDirection+0x174>
    12bc:	80 95       	com	r24
    12be:	84 23       	and	r24, r20
    12c0:	8c 93       	st	X, r24
    12c2:	a1 e3       	ldi	r26, 0x31	; 49
    12c4:	b0 e0       	ldi	r27, 0x00	; 0
    12c6:	e1 e3       	ldi	r30, 0x31	; 49
    12c8:	f0 e0       	ldi	r31, 0x00	; 0
    12ca:	80 81       	ld	r24, Z
    12cc:	48 2f       	mov	r20, r24
    12ce:	8a 81       	ldd	r24, Y+2	; 0x02
    12d0:	28 2f       	mov	r18, r24
    12d2:	30 e0       	ldi	r19, 0x00	; 0
    12d4:	89 81       	ldd	r24, Y+1	; 0x01
    12d6:	88 2f       	mov	r24, r24
    12d8:	90 e0       	ldi	r25, 0x00	; 0
    12da:	87 70       	andi	r24, 0x07	; 7
    12dc:	90 70       	andi	r25, 0x00	; 0
    12de:	b9 01       	movw	r22, r18
    12e0:	02 c0       	rjmp	.+4      	; 0x12e6 <DIO_voidSetPinDirection+0x1a6>
    12e2:	66 0f       	add	r22, r22
    12e4:	77 1f       	adc	r23, r23
    12e6:	8a 95       	dec	r24
    12e8:	e2 f7       	brpl	.-8      	; 0x12e2 <DIO_voidSetPinDirection+0x1a2>
    12ea:	cb 01       	movw	r24, r22
    12ec:	84 2b       	or	r24, r20
    12ee:	8c 93       	st	X, r24
		}
	} /* end if */
} /*end function */
    12f0:	0f 90       	pop	r0
    12f2:	0f 90       	pop	r0
    12f4:	cf 91       	pop	r28
    12f6:	df 91       	pop	r29
    12f8:	08 95       	ret

000012fa <DIO_voidWritePin>:

/*
 *  States the Value of the PIN: HIGH/LOW
 */
extern void DIO_voidWritePin(U8 DIO_u8LocalPinToSet, U8 DIO_u8DIOLocalValue)
{
    12fa:	df 93       	push	r29
    12fc:	cf 93       	push	r28
    12fe:	00 d0       	rcall	.+0      	; 0x1300 <DIO_voidWritePin+0x6>
    1300:	cd b7       	in	r28, 0x3d	; 61
    1302:	de b7       	in	r29, 0x3e	; 62
    1304:	89 83       	std	Y+1, r24	; 0x01
    1306:	6a 83       	std	Y+2, r22	; 0x02
	if((DIO_u8LocalPinToSet>=0 && DIO_u8LocalPinToSet<=31) && (DIO_u8DIOLocalValue==0 || DIO_u8DIOLocalValue==1))
    1308:	89 81       	ldd	r24, Y+1	; 0x01
    130a:	80 32       	cpi	r24, 0x20	; 32
    130c:	08 f0       	brcs	.+2      	; 0x1310 <DIO_voidWritePin+0x16>
    130e:	cd c0       	rjmp	.+410    	; 0x14aa <DIO_voidWritePin+0x1b0>
    1310:	8a 81       	ldd	r24, Y+2	; 0x02
    1312:	88 23       	and	r24, r24
    1314:	21 f0       	breq	.+8      	; 0x131e <DIO_voidWritePin+0x24>
    1316:	8a 81       	ldd	r24, Y+2	; 0x02
    1318:	81 30       	cpi	r24, 0x01	; 1
    131a:	09 f0       	breq	.+2      	; 0x131e <DIO_voidWritePin+0x24>
    131c:	c6 c0       	rjmp	.+396    	; 0x14aa <DIO_voidWritePin+0x1b0>
	{
		if( (DIO_u8LocalPinToSet / 8) == 0)
    131e:	89 81       	ldd	r24, Y+1	; 0x01
    1320:	88 30       	cpi	r24, 0x08	; 8
    1322:	70 f5       	brcc	.+92     	; 0x1380 <DIO_voidWritePin+0x86>
		{
			assign_bit(PORTA, (DIO_u8LocalPinToSet % 8), DIO_u8DIOLocalValue);
    1324:	ab e3       	ldi	r26, 0x3B	; 59
    1326:	b0 e0       	ldi	r27, 0x00	; 0
    1328:	eb e3       	ldi	r30, 0x3B	; 59
    132a:	f0 e0       	ldi	r31, 0x00	; 0
    132c:	80 81       	ld	r24, Z
    132e:	48 2f       	mov	r20, r24
    1330:	89 81       	ldd	r24, Y+1	; 0x01
    1332:	88 2f       	mov	r24, r24
    1334:	90 e0       	ldi	r25, 0x00	; 0
    1336:	9c 01       	movw	r18, r24
    1338:	27 70       	andi	r18, 0x07	; 7
    133a:	30 70       	andi	r19, 0x00	; 0
    133c:	81 e0       	ldi	r24, 0x01	; 1
    133e:	90 e0       	ldi	r25, 0x00	; 0
    1340:	02 c0       	rjmp	.+4      	; 0x1346 <DIO_voidWritePin+0x4c>
    1342:	88 0f       	add	r24, r24
    1344:	99 1f       	adc	r25, r25
    1346:	2a 95       	dec	r18
    1348:	e2 f7       	brpl	.-8      	; 0x1342 <DIO_voidWritePin+0x48>
    134a:	80 95       	com	r24
    134c:	84 23       	and	r24, r20
    134e:	8c 93       	st	X, r24
    1350:	ab e3       	ldi	r26, 0x3B	; 59
    1352:	b0 e0       	ldi	r27, 0x00	; 0
    1354:	eb e3       	ldi	r30, 0x3B	; 59
    1356:	f0 e0       	ldi	r31, 0x00	; 0
    1358:	80 81       	ld	r24, Z
    135a:	48 2f       	mov	r20, r24
    135c:	8a 81       	ldd	r24, Y+2	; 0x02
    135e:	28 2f       	mov	r18, r24
    1360:	30 e0       	ldi	r19, 0x00	; 0
    1362:	89 81       	ldd	r24, Y+1	; 0x01
    1364:	88 2f       	mov	r24, r24
    1366:	90 e0       	ldi	r25, 0x00	; 0
    1368:	87 70       	andi	r24, 0x07	; 7
    136a:	90 70       	andi	r25, 0x00	; 0
    136c:	b9 01       	movw	r22, r18
    136e:	02 c0       	rjmp	.+4      	; 0x1374 <DIO_voidWritePin+0x7a>
    1370:	66 0f       	add	r22, r22
    1372:	77 1f       	adc	r23, r23
    1374:	8a 95       	dec	r24
    1376:	e2 f7       	brpl	.-8      	; 0x1370 <DIO_voidWritePin+0x76>
    1378:	cb 01       	movw	r24, r22
    137a:	84 2b       	or	r24, r20
    137c:	8c 93       	st	X, r24
    137e:	95 c0       	rjmp	.+298    	; 0x14aa <DIO_voidWritePin+0x1b0>
		}
		else if ( (DIO_u8LocalPinToSet / 8) == 1)
    1380:	89 81       	ldd	r24, Y+1	; 0x01
    1382:	88 50       	subi	r24, 0x08	; 8
    1384:	88 30       	cpi	r24, 0x08	; 8
    1386:	70 f5       	brcc	.+92     	; 0x13e4 <DIO_voidWritePin+0xea>
		{
			assign_bit(PORTB, (DIO_u8LocalPinToSet % 8), DIO_u8DIOLocalValue);
    1388:	a8 e3       	ldi	r26, 0x38	; 56
    138a:	b0 e0       	ldi	r27, 0x00	; 0
    138c:	e8 e3       	ldi	r30, 0x38	; 56
    138e:	f0 e0       	ldi	r31, 0x00	; 0
    1390:	80 81       	ld	r24, Z
    1392:	48 2f       	mov	r20, r24
    1394:	89 81       	ldd	r24, Y+1	; 0x01
    1396:	88 2f       	mov	r24, r24
    1398:	90 e0       	ldi	r25, 0x00	; 0
    139a:	9c 01       	movw	r18, r24
    139c:	27 70       	andi	r18, 0x07	; 7
    139e:	30 70       	andi	r19, 0x00	; 0
    13a0:	81 e0       	ldi	r24, 0x01	; 1
    13a2:	90 e0       	ldi	r25, 0x00	; 0
    13a4:	02 c0       	rjmp	.+4      	; 0x13aa <DIO_voidWritePin+0xb0>
    13a6:	88 0f       	add	r24, r24
    13a8:	99 1f       	adc	r25, r25
    13aa:	2a 95       	dec	r18
    13ac:	e2 f7       	brpl	.-8      	; 0x13a6 <DIO_voidWritePin+0xac>
    13ae:	80 95       	com	r24
    13b0:	84 23       	and	r24, r20
    13b2:	8c 93       	st	X, r24
    13b4:	a8 e3       	ldi	r26, 0x38	; 56
    13b6:	b0 e0       	ldi	r27, 0x00	; 0
    13b8:	e8 e3       	ldi	r30, 0x38	; 56
    13ba:	f0 e0       	ldi	r31, 0x00	; 0
    13bc:	80 81       	ld	r24, Z
    13be:	48 2f       	mov	r20, r24
    13c0:	8a 81       	ldd	r24, Y+2	; 0x02
    13c2:	28 2f       	mov	r18, r24
    13c4:	30 e0       	ldi	r19, 0x00	; 0
    13c6:	89 81       	ldd	r24, Y+1	; 0x01
    13c8:	88 2f       	mov	r24, r24
    13ca:	90 e0       	ldi	r25, 0x00	; 0
    13cc:	87 70       	andi	r24, 0x07	; 7
    13ce:	90 70       	andi	r25, 0x00	; 0
    13d0:	b9 01       	movw	r22, r18
    13d2:	02 c0       	rjmp	.+4      	; 0x13d8 <DIO_voidWritePin+0xde>
    13d4:	66 0f       	add	r22, r22
    13d6:	77 1f       	adc	r23, r23
    13d8:	8a 95       	dec	r24
    13da:	e2 f7       	brpl	.-8      	; 0x13d4 <DIO_voidWritePin+0xda>
    13dc:	cb 01       	movw	r24, r22
    13de:	84 2b       	or	r24, r20
    13e0:	8c 93       	st	X, r24
    13e2:	63 c0       	rjmp	.+198    	; 0x14aa <DIO_voidWritePin+0x1b0>
		}
		else if ( (DIO_u8LocalPinToSet / 8) == 2)
    13e4:	89 81       	ldd	r24, Y+1	; 0x01
    13e6:	80 51       	subi	r24, 0x10	; 16
    13e8:	88 30       	cpi	r24, 0x08	; 8
    13ea:	70 f5       	brcc	.+92     	; 0x1448 <DIO_voidWritePin+0x14e>
		{
			assign_bit(PORTC, (DIO_u8LocalPinToSet % 8), DIO_u8DIOLocalValue);
    13ec:	a5 e3       	ldi	r26, 0x35	; 53
    13ee:	b0 e0       	ldi	r27, 0x00	; 0
    13f0:	e5 e3       	ldi	r30, 0x35	; 53
    13f2:	f0 e0       	ldi	r31, 0x00	; 0
    13f4:	80 81       	ld	r24, Z
    13f6:	48 2f       	mov	r20, r24
    13f8:	89 81       	ldd	r24, Y+1	; 0x01
    13fa:	88 2f       	mov	r24, r24
    13fc:	90 e0       	ldi	r25, 0x00	; 0
    13fe:	9c 01       	movw	r18, r24
    1400:	27 70       	andi	r18, 0x07	; 7
    1402:	30 70       	andi	r19, 0x00	; 0
    1404:	81 e0       	ldi	r24, 0x01	; 1
    1406:	90 e0       	ldi	r25, 0x00	; 0
    1408:	02 c0       	rjmp	.+4      	; 0x140e <DIO_voidWritePin+0x114>
    140a:	88 0f       	add	r24, r24
    140c:	99 1f       	adc	r25, r25
    140e:	2a 95       	dec	r18
    1410:	e2 f7       	brpl	.-8      	; 0x140a <DIO_voidWritePin+0x110>
    1412:	80 95       	com	r24
    1414:	84 23       	and	r24, r20
    1416:	8c 93       	st	X, r24
    1418:	a5 e3       	ldi	r26, 0x35	; 53
    141a:	b0 e0       	ldi	r27, 0x00	; 0
    141c:	e5 e3       	ldi	r30, 0x35	; 53
    141e:	f0 e0       	ldi	r31, 0x00	; 0
    1420:	80 81       	ld	r24, Z
    1422:	48 2f       	mov	r20, r24
    1424:	8a 81       	ldd	r24, Y+2	; 0x02
    1426:	28 2f       	mov	r18, r24
    1428:	30 e0       	ldi	r19, 0x00	; 0
    142a:	89 81       	ldd	r24, Y+1	; 0x01
    142c:	88 2f       	mov	r24, r24
    142e:	90 e0       	ldi	r25, 0x00	; 0
    1430:	87 70       	andi	r24, 0x07	; 7
    1432:	90 70       	andi	r25, 0x00	; 0
    1434:	b9 01       	movw	r22, r18
    1436:	02 c0       	rjmp	.+4      	; 0x143c <DIO_voidWritePin+0x142>
    1438:	66 0f       	add	r22, r22
    143a:	77 1f       	adc	r23, r23
    143c:	8a 95       	dec	r24
    143e:	e2 f7       	brpl	.-8      	; 0x1438 <DIO_voidWritePin+0x13e>
    1440:	cb 01       	movw	r24, r22
    1442:	84 2b       	or	r24, r20
    1444:	8c 93       	st	X, r24
    1446:	31 c0       	rjmp	.+98     	; 0x14aa <DIO_voidWritePin+0x1b0>
		}
		else if ( (DIO_u8LocalPinToSet / 8) == 3)
    1448:	89 81       	ldd	r24, Y+1	; 0x01
    144a:	88 51       	subi	r24, 0x18	; 24
    144c:	88 30       	cpi	r24, 0x08	; 8
    144e:	68 f5       	brcc	.+90     	; 0x14aa <DIO_voidWritePin+0x1b0>
		{
			assign_bit(PORTD, (DIO_u8LocalPinToSet %8), DIO_u8DIOLocalValue);
    1450:	a2 e3       	ldi	r26, 0x32	; 50
    1452:	b0 e0       	ldi	r27, 0x00	; 0
    1454:	e2 e3       	ldi	r30, 0x32	; 50
    1456:	f0 e0       	ldi	r31, 0x00	; 0
    1458:	80 81       	ld	r24, Z
    145a:	48 2f       	mov	r20, r24
    145c:	89 81       	ldd	r24, Y+1	; 0x01
    145e:	88 2f       	mov	r24, r24
    1460:	90 e0       	ldi	r25, 0x00	; 0
    1462:	9c 01       	movw	r18, r24
    1464:	27 70       	andi	r18, 0x07	; 7
    1466:	30 70       	andi	r19, 0x00	; 0
    1468:	81 e0       	ldi	r24, 0x01	; 1
    146a:	90 e0       	ldi	r25, 0x00	; 0
    146c:	02 c0       	rjmp	.+4      	; 0x1472 <DIO_voidWritePin+0x178>
    146e:	88 0f       	add	r24, r24
    1470:	99 1f       	adc	r25, r25
    1472:	2a 95       	dec	r18
    1474:	e2 f7       	brpl	.-8      	; 0x146e <DIO_voidWritePin+0x174>
    1476:	80 95       	com	r24
    1478:	84 23       	and	r24, r20
    147a:	8c 93       	st	X, r24
    147c:	a2 e3       	ldi	r26, 0x32	; 50
    147e:	b0 e0       	ldi	r27, 0x00	; 0
    1480:	e2 e3       	ldi	r30, 0x32	; 50
    1482:	f0 e0       	ldi	r31, 0x00	; 0
    1484:	80 81       	ld	r24, Z
    1486:	48 2f       	mov	r20, r24
    1488:	8a 81       	ldd	r24, Y+2	; 0x02
    148a:	28 2f       	mov	r18, r24
    148c:	30 e0       	ldi	r19, 0x00	; 0
    148e:	89 81       	ldd	r24, Y+1	; 0x01
    1490:	88 2f       	mov	r24, r24
    1492:	90 e0       	ldi	r25, 0x00	; 0
    1494:	87 70       	andi	r24, 0x07	; 7
    1496:	90 70       	andi	r25, 0x00	; 0
    1498:	b9 01       	movw	r22, r18
    149a:	02 c0       	rjmp	.+4      	; 0x14a0 <DIO_voidWritePin+0x1a6>
    149c:	66 0f       	add	r22, r22
    149e:	77 1f       	adc	r23, r23
    14a0:	8a 95       	dec	r24
    14a2:	e2 f7       	brpl	.-8      	; 0x149c <DIO_voidWritePin+0x1a2>
    14a4:	cb 01       	movw	r24, r22
    14a6:	84 2b       	or	r24, r20
    14a8:	8c 93       	st	X, r24
		}
	}/* end if */
}/* end function */
    14aa:	0f 90       	pop	r0
    14ac:	0f 90       	pop	r0
    14ae:	cf 91       	pop	r28
    14b0:	df 91       	pop	r29
    14b2:	08 95       	ret

000014b4 <DIO_u8ReadPin>:

/*
 *  Reads the Value of the PIN: HIGH/LOW
 */
extern U8 DIO_u8ReadPin(U8 DIO_u8LocalPintToRead)
{
    14b4:	df 93       	push	r29
    14b6:	cf 93       	push	r28
    14b8:	00 d0       	rcall	.+0      	; 0x14ba <DIO_u8ReadPin+0x6>
    14ba:	cd b7       	in	r28, 0x3d	; 61
    14bc:	de b7       	in	r29, 0x3e	; 62
    14be:	8a 83       	std	Y+2, r24	; 0x02
	U8 DIO_u8DataToBeRead;
	if((DIO_u8LocalPintToRead>=0) && (DIO_u8LocalPintToRead<=31))
    14c0:	8a 81       	ldd	r24, Y+2	; 0x02
    14c2:	80 32       	cpi	r24, 0x20	; 32
    14c4:	08 f0       	brcs	.+2      	; 0x14c8 <DIO_u8ReadPin+0x14>
    14c6:	9a c0       	rjmp	.+308    	; 0x15fc <DIO_u8ReadPin+0x148>
	{
		if( (DIO_u8LocalPintToRead/8) == 0)
    14c8:	8a 81       	ldd	r24, Y+2	; 0x02
    14ca:	88 30       	cpi	r24, 0x08	; 8
    14cc:	18 f5       	brcc	.+70     	; 0x1514 <DIO_u8ReadPin+0x60>
		{
			DIO_u8DataToBeRead = get_bit(PINA,(DIO_u8LocalPintToRead%8) );
    14ce:	e9 e3       	ldi	r30, 0x39	; 57
    14d0:	f0 e0       	ldi	r31, 0x00	; 0
    14d2:	80 81       	ld	r24, Z
    14d4:	48 2f       	mov	r20, r24
    14d6:	50 e0       	ldi	r21, 0x00	; 0
    14d8:	8a 81       	ldd	r24, Y+2	; 0x02
    14da:	88 2f       	mov	r24, r24
    14dc:	90 e0       	ldi	r25, 0x00	; 0
    14de:	9c 01       	movw	r18, r24
    14e0:	27 70       	andi	r18, 0x07	; 7
    14e2:	30 70       	andi	r19, 0x00	; 0
    14e4:	81 e0       	ldi	r24, 0x01	; 1
    14e6:	90 e0       	ldi	r25, 0x00	; 0
    14e8:	02 c0       	rjmp	.+4      	; 0x14ee <DIO_u8ReadPin+0x3a>
    14ea:	88 0f       	add	r24, r24
    14ec:	99 1f       	adc	r25, r25
    14ee:	2a 95       	dec	r18
    14f0:	e2 f7       	brpl	.-8      	; 0x14ea <DIO_u8ReadPin+0x36>
    14f2:	9a 01       	movw	r18, r20
    14f4:	28 23       	and	r18, r24
    14f6:	39 23       	and	r19, r25
    14f8:	8a 81       	ldd	r24, Y+2	; 0x02
    14fa:	88 2f       	mov	r24, r24
    14fc:	90 e0       	ldi	r25, 0x00	; 0
    14fe:	87 70       	andi	r24, 0x07	; 7
    1500:	90 70       	andi	r25, 0x00	; 0
    1502:	a9 01       	movw	r20, r18
    1504:	02 c0       	rjmp	.+4      	; 0x150a <DIO_u8ReadPin+0x56>
    1506:	55 95       	asr	r21
    1508:	47 95       	ror	r20
    150a:	8a 95       	dec	r24
    150c:	e2 f7       	brpl	.-8      	; 0x1506 <DIO_u8ReadPin+0x52>
    150e:	ca 01       	movw	r24, r20
    1510:	89 83       	std	Y+1, r24	; 0x01
    1512:	74 c0       	rjmp	.+232    	; 0x15fc <DIO_u8ReadPin+0x148>
		}
		else if((DIO_u8LocalPintToRead/8) == 1)
    1514:	8a 81       	ldd	r24, Y+2	; 0x02
    1516:	88 50       	subi	r24, 0x08	; 8
    1518:	88 30       	cpi	r24, 0x08	; 8
    151a:	18 f5       	brcc	.+70     	; 0x1562 <DIO_u8ReadPin+0xae>
		{
			DIO_u8DataToBeRead = get_bit(PINB,(DIO_u8LocalPintToRead%8) );
    151c:	e6 e3       	ldi	r30, 0x36	; 54
    151e:	f0 e0       	ldi	r31, 0x00	; 0
    1520:	80 81       	ld	r24, Z
    1522:	48 2f       	mov	r20, r24
    1524:	50 e0       	ldi	r21, 0x00	; 0
    1526:	8a 81       	ldd	r24, Y+2	; 0x02
    1528:	88 2f       	mov	r24, r24
    152a:	90 e0       	ldi	r25, 0x00	; 0
    152c:	9c 01       	movw	r18, r24
    152e:	27 70       	andi	r18, 0x07	; 7
    1530:	30 70       	andi	r19, 0x00	; 0
    1532:	81 e0       	ldi	r24, 0x01	; 1
    1534:	90 e0       	ldi	r25, 0x00	; 0
    1536:	02 c0       	rjmp	.+4      	; 0x153c <DIO_u8ReadPin+0x88>
    1538:	88 0f       	add	r24, r24
    153a:	99 1f       	adc	r25, r25
    153c:	2a 95       	dec	r18
    153e:	e2 f7       	brpl	.-8      	; 0x1538 <DIO_u8ReadPin+0x84>
    1540:	9a 01       	movw	r18, r20
    1542:	28 23       	and	r18, r24
    1544:	39 23       	and	r19, r25
    1546:	8a 81       	ldd	r24, Y+2	; 0x02
    1548:	88 2f       	mov	r24, r24
    154a:	90 e0       	ldi	r25, 0x00	; 0
    154c:	87 70       	andi	r24, 0x07	; 7
    154e:	90 70       	andi	r25, 0x00	; 0
    1550:	a9 01       	movw	r20, r18
    1552:	02 c0       	rjmp	.+4      	; 0x1558 <DIO_u8ReadPin+0xa4>
    1554:	55 95       	asr	r21
    1556:	47 95       	ror	r20
    1558:	8a 95       	dec	r24
    155a:	e2 f7       	brpl	.-8      	; 0x1554 <DIO_u8ReadPin+0xa0>
    155c:	ca 01       	movw	r24, r20
    155e:	89 83       	std	Y+1, r24	; 0x01
    1560:	4d c0       	rjmp	.+154    	; 0x15fc <DIO_u8ReadPin+0x148>
		}
		else if((DIO_u8LocalPintToRead/8) == 2)
    1562:	8a 81       	ldd	r24, Y+2	; 0x02
    1564:	80 51       	subi	r24, 0x10	; 16
    1566:	88 30       	cpi	r24, 0x08	; 8
    1568:	18 f5       	brcc	.+70     	; 0x15b0 <DIO_u8ReadPin+0xfc>
		{
			DIO_u8DataToBeRead = get_bit(PINC,(DIO_u8LocalPintToRead%8) );
    156a:	e3 e3       	ldi	r30, 0x33	; 51
    156c:	f0 e0       	ldi	r31, 0x00	; 0
    156e:	80 81       	ld	r24, Z
    1570:	48 2f       	mov	r20, r24
    1572:	50 e0       	ldi	r21, 0x00	; 0
    1574:	8a 81       	ldd	r24, Y+2	; 0x02
    1576:	88 2f       	mov	r24, r24
    1578:	90 e0       	ldi	r25, 0x00	; 0
    157a:	9c 01       	movw	r18, r24
    157c:	27 70       	andi	r18, 0x07	; 7
    157e:	30 70       	andi	r19, 0x00	; 0
    1580:	81 e0       	ldi	r24, 0x01	; 1
    1582:	90 e0       	ldi	r25, 0x00	; 0
    1584:	02 c0       	rjmp	.+4      	; 0x158a <DIO_u8ReadPin+0xd6>
    1586:	88 0f       	add	r24, r24
    1588:	99 1f       	adc	r25, r25
    158a:	2a 95       	dec	r18
    158c:	e2 f7       	brpl	.-8      	; 0x1586 <DIO_u8ReadPin+0xd2>
    158e:	9a 01       	movw	r18, r20
    1590:	28 23       	and	r18, r24
    1592:	39 23       	and	r19, r25
    1594:	8a 81       	ldd	r24, Y+2	; 0x02
    1596:	88 2f       	mov	r24, r24
    1598:	90 e0       	ldi	r25, 0x00	; 0
    159a:	87 70       	andi	r24, 0x07	; 7
    159c:	90 70       	andi	r25, 0x00	; 0
    159e:	a9 01       	movw	r20, r18
    15a0:	02 c0       	rjmp	.+4      	; 0x15a6 <DIO_u8ReadPin+0xf2>
    15a2:	55 95       	asr	r21
    15a4:	47 95       	ror	r20
    15a6:	8a 95       	dec	r24
    15a8:	e2 f7       	brpl	.-8      	; 0x15a2 <DIO_u8ReadPin+0xee>
    15aa:	ca 01       	movw	r24, r20
    15ac:	89 83       	std	Y+1, r24	; 0x01
    15ae:	26 c0       	rjmp	.+76     	; 0x15fc <DIO_u8ReadPin+0x148>
		}
		else if((DIO_u8LocalPintToRead/8) == 3)
    15b0:	8a 81       	ldd	r24, Y+2	; 0x02
    15b2:	88 51       	subi	r24, 0x18	; 24
    15b4:	88 30       	cpi	r24, 0x08	; 8
    15b6:	10 f5       	brcc	.+68     	; 0x15fc <DIO_u8ReadPin+0x148>
		{
			DIO_u8DataToBeRead = get_bit(PIND,(DIO_u8LocalPintToRead%8) );
    15b8:	e0 e3       	ldi	r30, 0x30	; 48
    15ba:	f0 e0       	ldi	r31, 0x00	; 0
    15bc:	80 81       	ld	r24, Z
    15be:	48 2f       	mov	r20, r24
    15c0:	50 e0       	ldi	r21, 0x00	; 0
    15c2:	8a 81       	ldd	r24, Y+2	; 0x02
    15c4:	88 2f       	mov	r24, r24
    15c6:	90 e0       	ldi	r25, 0x00	; 0
    15c8:	9c 01       	movw	r18, r24
    15ca:	27 70       	andi	r18, 0x07	; 7
    15cc:	30 70       	andi	r19, 0x00	; 0
    15ce:	81 e0       	ldi	r24, 0x01	; 1
    15d0:	90 e0       	ldi	r25, 0x00	; 0
    15d2:	02 c0       	rjmp	.+4      	; 0x15d8 <DIO_u8ReadPin+0x124>
    15d4:	88 0f       	add	r24, r24
    15d6:	99 1f       	adc	r25, r25
    15d8:	2a 95       	dec	r18
    15da:	e2 f7       	brpl	.-8      	; 0x15d4 <DIO_u8ReadPin+0x120>
    15dc:	9a 01       	movw	r18, r20
    15de:	28 23       	and	r18, r24
    15e0:	39 23       	and	r19, r25
    15e2:	8a 81       	ldd	r24, Y+2	; 0x02
    15e4:	88 2f       	mov	r24, r24
    15e6:	90 e0       	ldi	r25, 0x00	; 0
    15e8:	87 70       	andi	r24, 0x07	; 7
    15ea:	90 70       	andi	r25, 0x00	; 0
    15ec:	a9 01       	movw	r20, r18
    15ee:	02 c0       	rjmp	.+4      	; 0x15f4 <DIO_u8ReadPin+0x140>
    15f0:	55 95       	asr	r21
    15f2:	47 95       	ror	r20
    15f4:	8a 95       	dec	r24
    15f6:	e2 f7       	brpl	.-8      	; 0x15f0 <DIO_u8ReadPin+0x13c>
    15f8:	ca 01       	movw	r24, r20
    15fa:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	return DIO_u8DataToBeRead;
    15fc:	89 81       	ldd	r24, Y+1	; 0x01
} /*end function */
    15fe:	0f 90       	pop	r0
    1600:	0f 90       	pop	r0
    1602:	cf 91       	pop	r28
    1604:	df 91       	pop	r29
    1606:	08 95       	ret

00001608 <DIO_voidSetPortDirection>:

/*
 *  States the Direction of the Port: INPUT/OUTPUT
 */
extern void DIO_voidSetPortDirection(U8 DIO_u8LocalPortToSet, U8 DIO_u8DIOLocalDirection)
{
    1608:	df 93       	push	r29
    160a:	cf 93       	push	r28
    160c:	00 d0       	rcall	.+0      	; 0x160e <DIO_voidSetPortDirection+0x6>
    160e:	cd b7       	in	r28, 0x3d	; 61
    1610:	de b7       	in	r29, 0x3e	; 62
    1612:	89 83       	std	Y+1, r24	; 0x01
    1614:	6a 83       	std	Y+2, r22	; 0x02
	/* declare Port A as Output */
	if(DIO_u8LocalPortToSet == 'A')
    1616:	89 81       	ldd	r24, Y+1	; 0x01
    1618:	81 34       	cpi	r24, 0x41	; 65
    161a:	71 f4       	brne	.+28     	; 0x1638 <DIO_voidSetPortDirection+0x30>
	{
		if(DIO_u8DIOLocalDirection == DIO_u8PinOp)
    161c:	8a 81       	ldd	r24, Y+2	; 0x02
    161e:	81 30       	cpi	r24, 0x01	; 1
    1620:	29 f4       	brne	.+10     	; 0x162c <DIO_voidSetPortDirection+0x24>
		{
		DDRA = 0xFF;
    1622:	ea e3       	ldi	r30, 0x3A	; 58
    1624:	f0 e0       	ldi	r31, 0x00	; 0
    1626:	8f ef       	ldi	r24, 0xFF	; 255
    1628:	80 83       	st	Z, r24
    162a:	06 c0       	rjmp	.+12     	; 0x1638 <DIO_voidSetPortDirection+0x30>
		}
		else if(DIO_u8DIOLocalDirection == DIO_u8PinIp)
    162c:	8a 81       	ldd	r24, Y+2	; 0x02
    162e:	88 23       	and	r24, r24
    1630:	19 f4       	brne	.+6      	; 0x1638 <DIO_voidSetPortDirection+0x30>
		{
		DDRA = 0x00;
    1632:	ea e3       	ldi	r30, 0x3A	; 58
    1634:	f0 e0       	ldi	r31, 0x00	; 0
    1636:	10 82       	st	Z, r1
		}
	}

	/* declare Port A as Output */
	if(DIO_u8LocalPortToSet == 'A')
    1638:	89 81       	ldd	r24, Y+1	; 0x01
    163a:	81 34       	cpi	r24, 0x41	; 65
    163c:	71 f4       	brne	.+28     	; 0x165a <DIO_voidSetPortDirection+0x52>
	{
		if(DIO_u8DIOLocalDirection == DIO_u8PinOp)
    163e:	8a 81       	ldd	r24, Y+2	; 0x02
    1640:	81 30       	cpi	r24, 0x01	; 1
    1642:	29 f4       	brne	.+10     	; 0x164e <DIO_voidSetPortDirection+0x46>
		{
			DDRA = 0xFF;
    1644:	ea e3       	ldi	r30, 0x3A	; 58
    1646:	f0 e0       	ldi	r31, 0x00	; 0
    1648:	8f ef       	ldi	r24, 0xFF	; 255
    164a:	80 83       	st	Z, r24
    164c:	06 c0       	rjmp	.+12     	; 0x165a <DIO_voidSetPortDirection+0x52>
		}
		else if(DIO_u8DIOLocalDirection == DIO_u8PinIp)
    164e:	8a 81       	ldd	r24, Y+2	; 0x02
    1650:	88 23       	and	r24, r24
    1652:	19 f4       	brne	.+6      	; 0x165a <DIO_voidSetPortDirection+0x52>
		{
			DDRA = 0x00;
    1654:	ea e3       	ldi	r30, 0x3A	; 58
    1656:	f0 e0       	ldi	r31, 0x00	; 0
    1658:	10 82       	st	Z, r1
		}
	} /* end Port A assigning */

	/* declare Port B as Output */
	if(DIO_u8LocalPortToSet == 'B')
    165a:	89 81       	ldd	r24, Y+1	; 0x01
    165c:	82 34       	cpi	r24, 0x42	; 66
    165e:	71 f4       	brne	.+28     	; 0x167c <DIO_voidSetPortDirection+0x74>
	{
		if(DIO_u8DIOLocalDirection == DIO_u8PinOp)
    1660:	8a 81       	ldd	r24, Y+2	; 0x02
    1662:	81 30       	cpi	r24, 0x01	; 1
    1664:	29 f4       	brne	.+10     	; 0x1670 <DIO_voidSetPortDirection+0x68>
		{
			DDRB = 0xFF;
    1666:	e7 e3       	ldi	r30, 0x37	; 55
    1668:	f0 e0       	ldi	r31, 0x00	; 0
    166a:	8f ef       	ldi	r24, 0xFF	; 255
    166c:	80 83       	st	Z, r24
    166e:	06 c0       	rjmp	.+12     	; 0x167c <DIO_voidSetPortDirection+0x74>
		}
		else if(DIO_u8DIOLocalDirection == DIO_u8PinIp)
    1670:	8a 81       	ldd	r24, Y+2	; 0x02
    1672:	88 23       	and	r24, r24
    1674:	19 f4       	brne	.+6      	; 0x167c <DIO_voidSetPortDirection+0x74>
		{
			DDRB = 0x00;
    1676:	e7 e3       	ldi	r30, 0x37	; 55
    1678:	f0 e0       	ldi	r31, 0x00	; 0
    167a:	10 82       	st	Z, r1
		}
	}/* end Port B assigning */

	/* declare Port C as Output */
	if(DIO_u8LocalPortToSet == 'C')
    167c:	89 81       	ldd	r24, Y+1	; 0x01
    167e:	83 34       	cpi	r24, 0x43	; 67
    1680:	71 f4       	brne	.+28     	; 0x169e <DIO_voidSetPortDirection+0x96>
	{
		if(DIO_u8DIOLocalDirection == DIO_u8PinOp)
    1682:	8a 81       	ldd	r24, Y+2	; 0x02
    1684:	81 30       	cpi	r24, 0x01	; 1
    1686:	29 f4       	brne	.+10     	; 0x1692 <DIO_voidSetPortDirection+0x8a>
		{
			DDRC = 0xFF;
    1688:	e4 e3       	ldi	r30, 0x34	; 52
    168a:	f0 e0       	ldi	r31, 0x00	; 0
    168c:	8f ef       	ldi	r24, 0xFF	; 255
    168e:	80 83       	st	Z, r24
    1690:	06 c0       	rjmp	.+12     	; 0x169e <DIO_voidSetPortDirection+0x96>
		}
		else if(DIO_u8DIOLocalDirection == DIO_u8PinIp)
    1692:	8a 81       	ldd	r24, Y+2	; 0x02
    1694:	88 23       	and	r24, r24
    1696:	19 f4       	brne	.+6      	; 0x169e <DIO_voidSetPortDirection+0x96>
		{
			DDRC = 0x00;
    1698:	e4 e3       	ldi	r30, 0x34	; 52
    169a:	f0 e0       	ldi	r31, 0x00	; 0
    169c:	10 82       	st	Z, r1
		}
	} /* end Port C assigning */

	/* declare Port D as Output */
	if(DIO_u8LocalPortToSet == 'D')
    169e:	89 81       	ldd	r24, Y+1	; 0x01
    16a0:	84 34       	cpi	r24, 0x44	; 68
    16a2:	71 f4       	brne	.+28     	; 0x16c0 <DIO_voidSetPortDirection+0xb8>
	{
		if(DIO_u8DIOLocalDirection == DIO_u8PinOp)
    16a4:	8a 81       	ldd	r24, Y+2	; 0x02
    16a6:	81 30       	cpi	r24, 0x01	; 1
    16a8:	29 f4       	brne	.+10     	; 0x16b4 <DIO_voidSetPortDirection+0xac>
		{
			DDRD = 0xFF;
    16aa:	e1 e3       	ldi	r30, 0x31	; 49
    16ac:	f0 e0       	ldi	r31, 0x00	; 0
    16ae:	8f ef       	ldi	r24, 0xFF	; 255
    16b0:	80 83       	st	Z, r24
    16b2:	06 c0       	rjmp	.+12     	; 0x16c0 <DIO_voidSetPortDirection+0xb8>
		}
		else if(DIO_u8DIOLocalDirection == DIO_u8PinIp)
    16b4:	8a 81       	ldd	r24, Y+2	; 0x02
    16b6:	88 23       	and	r24, r24
    16b8:	19 f4       	brne	.+6      	; 0x16c0 <DIO_voidSetPortDirection+0xb8>
		{
			DDRD = 0x00;
    16ba:	e1 e3       	ldi	r30, 0x31	; 49
    16bc:	f0 e0       	ldi	r31, 0x00	; 0
    16be:	10 82       	st	Z, r1
		}
	}/* end Port C assigning */
} /* end DIO_voidSetPortDirection Function */
    16c0:	0f 90       	pop	r0
    16c2:	0f 90       	pop	r0
    16c4:	cf 91       	pop	r28
    16c6:	df 91       	pop	r29
    16c8:	08 95       	ret

000016ca <DIO_voidWritePort>:

/*
 *  States the Value of the Port: HIGH/LOW
 */
extern void DIO_voidWritePort(U8 DIO_u8LocalPortToSet, U8 DIO_u8ValueToSet)
{
    16ca:	df 93       	push	r29
    16cc:	cf 93       	push	r28
    16ce:	00 d0       	rcall	.+0      	; 0x16d0 <DIO_voidWritePort+0x6>
    16d0:	cd b7       	in	r28, 0x3d	; 61
    16d2:	de b7       	in	r29, 0x3e	; 62
    16d4:	89 83       	std	Y+1, r24	; 0x01
    16d6:	6a 83       	std	Y+2, r22	; 0x02
	/* Assign Port A with value */
	if(DIO_u8LocalPortToSet == 'A')
    16d8:	89 81       	ldd	r24, Y+1	; 0x01
    16da:	81 34       	cpi	r24, 0x41	; 65
    16dc:	21 f4       	brne	.+8      	; 0x16e6 <DIO_voidWritePort+0x1c>
	{
			PORTA = DIO_u8ValueToSet;
    16de:	eb e3       	ldi	r30, 0x3B	; 59
    16e0:	f0 e0       	ldi	r31, 0x00	; 0
    16e2:	8a 81       	ldd	r24, Y+2	; 0x02
    16e4:	80 83       	st	Z, r24
	}

	/* Assign Port A with value */
	if(DIO_u8LocalPortToSet == 'B')
    16e6:	89 81       	ldd	r24, Y+1	; 0x01
    16e8:	82 34       	cpi	r24, 0x42	; 66
    16ea:	21 f4       	brne	.+8      	; 0x16f4 <DIO_voidWritePort+0x2a>
	{
		PORTB = DIO_u8ValueToSet;
    16ec:	e8 e3       	ldi	r30, 0x38	; 56
    16ee:	f0 e0       	ldi	r31, 0x00	; 0
    16f0:	8a 81       	ldd	r24, Y+2	; 0x02
    16f2:	80 83       	st	Z, r24
	}

	/* Assign Port A with value */
	if(DIO_u8LocalPortToSet == 'C')
    16f4:	89 81       	ldd	r24, Y+1	; 0x01
    16f6:	83 34       	cpi	r24, 0x43	; 67
    16f8:	21 f4       	brne	.+8      	; 0x1702 <DIO_voidWritePort+0x38>
	{
		PORTC = DIO_u8ValueToSet;
    16fa:	e5 e3       	ldi	r30, 0x35	; 53
    16fc:	f0 e0       	ldi	r31, 0x00	; 0
    16fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1700:	80 83       	st	Z, r24
	}

	/* Assign Port A with value */
	if(DIO_u8LocalPortToSet == 'D')
    1702:	89 81       	ldd	r24, Y+1	; 0x01
    1704:	84 34       	cpi	r24, 0x44	; 68
    1706:	21 f4       	brne	.+8      	; 0x1710 <DIO_voidWritePort+0x46>
	{
		PORTD = DIO_u8ValueToSet;
    1708:	e2 e3       	ldi	r30, 0x32	; 50
    170a:	f0 e0       	ldi	r31, 0x00	; 0
    170c:	8a 81       	ldd	r24, Y+2	; 0x02
    170e:	80 83       	st	Z, r24
	}
}/* end DIO_voidWritePort Function */
    1710:	0f 90       	pop	r0
    1712:	0f 90       	pop	r0
    1714:	cf 91       	pop	r28
    1716:	df 91       	pop	r29
    1718:	08 95       	ret

0000171a <DEI_voidInit>:

/*
 * Digital External Interrupt Initialization
 */
void DEI_voidInit(void)
{
    171a:	df 93       	push	r29
    171c:	cf 93       	push	r28
    171e:	cd b7       	in	r28, 0x3d	; 61
    1720:	de b7       	in	r29, 0x3e	; 62
	/* Enable 'I' the global interrupt. */
	set_bit(SREG, 7);
    1722:	af e5       	ldi	r26, 0x5F	; 95
    1724:	b0 e0       	ldi	r27, 0x00	; 0
    1726:	ef e5       	ldi	r30, 0x5F	; 95
    1728:	f0 e0       	ldi	r31, 0x00	; 0
    172a:	80 81       	ld	r24, Z
    172c:	80 68       	ori	r24, 0x80	; 128
    172e:	8c 93       	st	X, r24

	/* Enable the interrupt INT0,INT1, INT2
	 * Check Configuration
	 */
	GICR |= (INT0<<6) | (INT1<<7) | (INT2<<5);
    1730:	ab e5       	ldi	r26, 0x5B	; 91
    1732:	b0 e0       	ldi	r27, 0x00	; 0
    1734:	eb e5       	ldi	r30, 0x5B	; 91
    1736:	f0 e0       	ldi	r31, 0x00	; 0
    1738:	80 81       	ld	r24, Z
    173a:	80 6c       	ori	r24, 0xC0	; 192
    173c:	8c 93       	st	X, r24

	/*
	 * Configure the external interrupt INT0, INT1
	 * Sense control.
	 */
	MCUCR |= (ISC00<<0) | (ISC01<<1) | (ISC10<<2) | (ISC11<<3);
    173e:	a5 e5       	ldi	r26, 0x55	; 85
    1740:	b0 e0       	ldi	r27, 0x00	; 0
    1742:	e5 e5       	ldi	r30, 0x55	; 85
    1744:	f0 e0       	ldi	r31, 0x00	; 0
    1746:	80 81       	ld	r24, Z
    1748:	8e 60       	ori	r24, 0x0E	; 14
    174a:	8c 93       	st	X, r24
}	/* end function DEI_voidInit */
    174c:	cf 91       	pop	r28
    174e:	df 91       	pop	r29
    1750:	08 95       	ret

00001752 <LCD_voidInit>:
#include "LCD.h"

#include <stdlib.h>

extern void LCD_voidInit(void)
{
    1752:	0f 93       	push	r16
    1754:	1f 93       	push	r17
    1756:	df 93       	push	r29
    1758:	cf 93       	push	r28
    175a:	cd b7       	in	r28, 0x3d	; 61
    175c:	de b7       	in	r29, 0x3e	; 62
    175e:	c4 55       	subi	r28, 0x54	; 84
    1760:	d0 40       	sbci	r29, 0x00	; 0
    1762:	0f b6       	in	r0, 0x3f	; 63
    1764:	f8 94       	cli
    1766:	de bf       	out	0x3e, r29	; 62
    1768:	0f be       	out	0x3f, r0	; 63
    176a:	cd bf       	out	0x3d, r28	; 61
	// Control Pins:
	/* RS: A0, R\W: A1, E: A2 */
	DIO_voidSetPinDirection(LCD_RS, DIO_u8PinOp);
    176c:	80 e0       	ldi	r24, 0x00	; 0
    176e:	61 e0       	ldi	r22, 0x01	; 1
    1770:	0e 94 a0 08 	call	0x1140	; 0x1140 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(LCD_RW, DIO_u8PinOp);
    1774:	81 e0       	ldi	r24, 0x01	; 1
    1776:	61 e0       	ldi	r22, 0x01	; 1
    1778:	0e 94 a0 08 	call	0x1140	; 0x1140 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(LCD_E, DIO_u8PinOp);
    177c:	82 e0       	ldi	r24, 0x02	; 2
    177e:	61 e0       	ldi	r22, 0x01	; 1
    1780:	0e 94 a0 08 	call	0x1140	; 0x1140 <DIO_voidSetPinDirection>

	// Data Pins:
	/* Connected to Port D */
	DIO_voidSetPortDirection(PORT, DIO_u8PortOp);
    1784:	83 e4       	ldi	r24, 0x43	; 67
    1786:	61 e0       	ldi	r22, 0x01	; 1
    1788:	0e 94 04 0b 	call	0x1608	; 0x1608 <DIO_voidSetPortDirection>
    178c:	fe 01       	movw	r30, r28
    178e:	ef 5a       	subi	r30, 0xAF	; 175
    1790:	ff 4f       	sbci	r31, 0xFF	; 255
    1792:	80 e0       	ldi	r24, 0x00	; 0
    1794:	90 e0       	ldi	r25, 0x00	; 0
    1796:	a8 e4       	ldi	r26, 0x48	; 72
    1798:	b2 e4       	ldi	r27, 0x42	; 66
    179a:	80 83       	st	Z, r24
    179c:	91 83       	std	Z+1, r25	; 0x01
    179e:	a2 83       	std	Z+2, r26	; 0x02
    17a0:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    17a2:	8e 01       	movw	r16, r28
    17a4:	03 5b       	subi	r16, 0xB3	; 179
    17a6:	1f 4f       	sbci	r17, 0xFF	; 255
    17a8:	fe 01       	movw	r30, r28
    17aa:	ef 5a       	subi	r30, 0xAF	; 175
    17ac:	ff 4f       	sbci	r31, 0xFF	; 255
    17ae:	60 81       	ld	r22, Z
    17b0:	71 81       	ldd	r23, Z+1	; 0x01
    17b2:	82 81       	ldd	r24, Z+2	; 0x02
    17b4:	93 81       	ldd	r25, Z+3	; 0x03
    17b6:	20 e0       	ldi	r18, 0x00	; 0
    17b8:	30 e0       	ldi	r19, 0x00	; 0
    17ba:	4a ef       	ldi	r20, 0xFA	; 250
    17bc:	54 e4       	ldi	r21, 0x44	; 68
    17be:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    17c2:	dc 01       	movw	r26, r24
    17c4:	cb 01       	movw	r24, r22
    17c6:	f8 01       	movw	r30, r16
    17c8:	80 83       	st	Z, r24
    17ca:	91 83       	std	Z+1, r25	; 0x01
    17cc:	a2 83       	std	Z+2, r26	; 0x02
    17ce:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    17d0:	fe 01       	movw	r30, r28
    17d2:	e3 5b       	subi	r30, 0xB3	; 179
    17d4:	ff 4f       	sbci	r31, 0xFF	; 255
    17d6:	60 81       	ld	r22, Z
    17d8:	71 81       	ldd	r23, Z+1	; 0x01
    17da:	82 81       	ldd	r24, Z+2	; 0x02
    17dc:	93 81       	ldd	r25, Z+3	; 0x03
    17de:	20 e0       	ldi	r18, 0x00	; 0
    17e0:	30 e0       	ldi	r19, 0x00	; 0
    17e2:	40 e8       	ldi	r20, 0x80	; 128
    17e4:	5f e3       	ldi	r21, 0x3F	; 63
    17e6:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    17ea:	88 23       	and	r24, r24
    17ec:	44 f4       	brge	.+16     	; 0x17fe <LCD_voidInit+0xac>
		__ticks = 1;
    17ee:	fe 01       	movw	r30, r28
    17f0:	e5 5b       	subi	r30, 0xB5	; 181
    17f2:	ff 4f       	sbci	r31, 0xFF	; 255
    17f4:	81 e0       	ldi	r24, 0x01	; 1
    17f6:	90 e0       	ldi	r25, 0x00	; 0
    17f8:	91 83       	std	Z+1, r25	; 0x01
    17fa:	80 83       	st	Z, r24
    17fc:	64 c0       	rjmp	.+200    	; 0x18c6 <LCD_voidInit+0x174>
	else if (__tmp > 65535)
    17fe:	fe 01       	movw	r30, r28
    1800:	e3 5b       	subi	r30, 0xB3	; 179
    1802:	ff 4f       	sbci	r31, 0xFF	; 255
    1804:	60 81       	ld	r22, Z
    1806:	71 81       	ldd	r23, Z+1	; 0x01
    1808:	82 81       	ldd	r24, Z+2	; 0x02
    180a:	93 81       	ldd	r25, Z+3	; 0x03
    180c:	20 e0       	ldi	r18, 0x00	; 0
    180e:	3f ef       	ldi	r19, 0xFF	; 255
    1810:	4f e7       	ldi	r20, 0x7F	; 127
    1812:	57 e4       	ldi	r21, 0x47	; 71
    1814:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1818:	18 16       	cp	r1, r24
    181a:	0c f0       	brlt	.+2      	; 0x181e <LCD_voidInit+0xcc>
    181c:	43 c0       	rjmp	.+134    	; 0x18a4 <LCD_voidInit+0x152>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    181e:	fe 01       	movw	r30, r28
    1820:	ef 5a       	subi	r30, 0xAF	; 175
    1822:	ff 4f       	sbci	r31, 0xFF	; 255
    1824:	60 81       	ld	r22, Z
    1826:	71 81       	ldd	r23, Z+1	; 0x01
    1828:	82 81       	ldd	r24, Z+2	; 0x02
    182a:	93 81       	ldd	r25, Z+3	; 0x03
    182c:	20 e0       	ldi	r18, 0x00	; 0
    182e:	30 e0       	ldi	r19, 0x00	; 0
    1830:	40 e2       	ldi	r20, 0x20	; 32
    1832:	51 e4       	ldi	r21, 0x41	; 65
    1834:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1838:	dc 01       	movw	r26, r24
    183a:	cb 01       	movw	r24, r22
    183c:	8e 01       	movw	r16, r28
    183e:	05 5b       	subi	r16, 0xB5	; 181
    1840:	1f 4f       	sbci	r17, 0xFF	; 255
    1842:	bc 01       	movw	r22, r24
    1844:	cd 01       	movw	r24, r26
    1846:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    184a:	dc 01       	movw	r26, r24
    184c:	cb 01       	movw	r24, r22
    184e:	f8 01       	movw	r30, r16
    1850:	91 83       	std	Z+1, r25	; 0x01
    1852:	80 83       	st	Z, r24
    1854:	1f c0       	rjmp	.+62     	; 0x1894 <LCD_voidInit+0x142>
    1856:	fe 01       	movw	r30, r28
    1858:	e7 5b       	subi	r30, 0xB7	; 183
    185a:	ff 4f       	sbci	r31, 0xFF	; 255
    185c:	88 ec       	ldi	r24, 0xC8	; 200
    185e:	90 e0       	ldi	r25, 0x00	; 0
    1860:	91 83       	std	Z+1, r25	; 0x01
    1862:	80 83       	st	Z, r24
    1864:	fe 01       	movw	r30, r28
    1866:	e7 5b       	subi	r30, 0xB7	; 183
    1868:	ff 4f       	sbci	r31, 0xFF	; 255
    186a:	80 81       	ld	r24, Z
    186c:	91 81       	ldd	r25, Z+1	; 0x01
    186e:	01 97       	sbiw	r24, 0x01	; 1
    1870:	f1 f7       	brne	.-4      	; 0x186e <LCD_voidInit+0x11c>
    1872:	fe 01       	movw	r30, r28
    1874:	e7 5b       	subi	r30, 0xB7	; 183
    1876:	ff 4f       	sbci	r31, 0xFF	; 255
    1878:	91 83       	std	Z+1, r25	; 0x01
    187a:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    187c:	de 01       	movw	r26, r28
    187e:	a5 5b       	subi	r26, 0xB5	; 181
    1880:	bf 4f       	sbci	r27, 0xFF	; 255
    1882:	fe 01       	movw	r30, r28
    1884:	e5 5b       	subi	r30, 0xB5	; 181
    1886:	ff 4f       	sbci	r31, 0xFF	; 255
    1888:	80 81       	ld	r24, Z
    188a:	91 81       	ldd	r25, Z+1	; 0x01
    188c:	01 97       	sbiw	r24, 0x01	; 1
    188e:	11 96       	adiw	r26, 0x01	; 1
    1890:	9c 93       	st	X, r25
    1892:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1894:	fe 01       	movw	r30, r28
    1896:	e5 5b       	subi	r30, 0xB5	; 181
    1898:	ff 4f       	sbci	r31, 0xFF	; 255
    189a:	80 81       	ld	r24, Z
    189c:	91 81       	ldd	r25, Z+1	; 0x01
    189e:	00 97       	sbiw	r24, 0x00	; 0
    18a0:	d1 f6       	brne	.-76     	; 0x1856 <LCD_voidInit+0x104>
    18a2:	27 c0       	rjmp	.+78     	; 0x18f2 <LCD_voidInit+0x1a0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    18a4:	8e 01       	movw	r16, r28
    18a6:	05 5b       	subi	r16, 0xB5	; 181
    18a8:	1f 4f       	sbci	r17, 0xFF	; 255
    18aa:	fe 01       	movw	r30, r28
    18ac:	e3 5b       	subi	r30, 0xB3	; 179
    18ae:	ff 4f       	sbci	r31, 0xFF	; 255
    18b0:	60 81       	ld	r22, Z
    18b2:	71 81       	ldd	r23, Z+1	; 0x01
    18b4:	82 81       	ldd	r24, Z+2	; 0x02
    18b6:	93 81       	ldd	r25, Z+3	; 0x03
    18b8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    18bc:	dc 01       	movw	r26, r24
    18be:	cb 01       	movw	r24, r22
    18c0:	f8 01       	movw	r30, r16
    18c2:	91 83       	std	Z+1, r25	; 0x01
    18c4:	80 83       	st	Z, r24
    18c6:	de 01       	movw	r26, r28
    18c8:	a9 5b       	subi	r26, 0xB9	; 185
    18ca:	bf 4f       	sbci	r27, 0xFF	; 255
    18cc:	fe 01       	movw	r30, r28
    18ce:	e5 5b       	subi	r30, 0xB5	; 181
    18d0:	ff 4f       	sbci	r31, 0xFF	; 255
    18d2:	80 81       	ld	r24, Z
    18d4:	91 81       	ldd	r25, Z+1	; 0x01
    18d6:	8d 93       	st	X+, r24
    18d8:	9c 93       	st	X, r25
    18da:	fe 01       	movw	r30, r28
    18dc:	e9 5b       	subi	r30, 0xB9	; 185
    18de:	ff 4f       	sbci	r31, 0xFF	; 255
    18e0:	80 81       	ld	r24, Z
    18e2:	91 81       	ldd	r25, Z+1	; 0x01
    18e4:	01 97       	sbiw	r24, 0x01	; 1
    18e6:	f1 f7       	brne	.-4      	; 0x18e4 <LCD_voidInit+0x192>
    18e8:	fe 01       	movw	r30, r28
    18ea:	e9 5b       	subi	r30, 0xB9	; 185
    18ec:	ff 4f       	sbci	r31, 0xFF	; 255
    18ee:	91 83       	std	Z+1, r25	; 0x01
    18f0:	80 83       	st	Z, r24

	_delay_ms(50);
		/* review the datasheet for re-configuration */

	/* Display Clear */
	LCD_voidWriteCommand(0b00000001);
    18f2:	81 e0       	ldi	r24, 0x01	; 1
    18f4:	0e 94 e1 0e 	call	0x1dc2	; 0x1dc2 <LCD_voidWriteCommand>
    18f8:	fe 01       	movw	r30, r28
    18fa:	ed 5b       	subi	r30, 0xBD	; 189
    18fc:	ff 4f       	sbci	r31, 0xFF	; 255
    18fe:	80 e0       	ldi	r24, 0x00	; 0
    1900:	90 e0       	ldi	r25, 0x00	; 0
    1902:	a0 e2       	ldi	r26, 0x20	; 32
    1904:	b1 e4       	ldi	r27, 0x41	; 65
    1906:	80 83       	st	Z, r24
    1908:	91 83       	std	Z+1, r25	; 0x01
    190a:	a2 83       	std	Z+2, r26	; 0x02
    190c:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    190e:	8e 01       	movw	r16, r28
    1910:	01 5c       	subi	r16, 0xC1	; 193
    1912:	1f 4f       	sbci	r17, 0xFF	; 255
    1914:	fe 01       	movw	r30, r28
    1916:	ed 5b       	subi	r30, 0xBD	; 189
    1918:	ff 4f       	sbci	r31, 0xFF	; 255
    191a:	60 81       	ld	r22, Z
    191c:	71 81       	ldd	r23, Z+1	; 0x01
    191e:	82 81       	ldd	r24, Z+2	; 0x02
    1920:	93 81       	ldd	r25, Z+3	; 0x03
    1922:	20 e0       	ldi	r18, 0x00	; 0
    1924:	30 e0       	ldi	r19, 0x00	; 0
    1926:	4a ef       	ldi	r20, 0xFA	; 250
    1928:	54 e4       	ldi	r21, 0x44	; 68
    192a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    192e:	dc 01       	movw	r26, r24
    1930:	cb 01       	movw	r24, r22
    1932:	f8 01       	movw	r30, r16
    1934:	80 83       	st	Z, r24
    1936:	91 83       	std	Z+1, r25	; 0x01
    1938:	a2 83       	std	Z+2, r26	; 0x02
    193a:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    193c:	fe 01       	movw	r30, r28
    193e:	ff 96       	adiw	r30, 0x3f	; 63
    1940:	60 81       	ld	r22, Z
    1942:	71 81       	ldd	r23, Z+1	; 0x01
    1944:	82 81       	ldd	r24, Z+2	; 0x02
    1946:	93 81       	ldd	r25, Z+3	; 0x03
    1948:	20 e0       	ldi	r18, 0x00	; 0
    194a:	30 e0       	ldi	r19, 0x00	; 0
    194c:	40 e8       	ldi	r20, 0x80	; 128
    194e:	5f e3       	ldi	r21, 0x3F	; 63
    1950:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1954:	88 23       	and	r24, r24
    1956:	2c f4       	brge	.+10     	; 0x1962 <LCD_voidInit+0x210>
		__ticks = 1;
    1958:	81 e0       	ldi	r24, 0x01	; 1
    195a:	90 e0       	ldi	r25, 0x00	; 0
    195c:	9e af       	std	Y+62, r25	; 0x3e
    195e:	8d af       	std	Y+61, r24	; 0x3d
    1960:	46 c0       	rjmp	.+140    	; 0x19ee <LCD_voidInit+0x29c>
	else if (__tmp > 65535)
    1962:	fe 01       	movw	r30, r28
    1964:	ff 96       	adiw	r30, 0x3f	; 63
    1966:	60 81       	ld	r22, Z
    1968:	71 81       	ldd	r23, Z+1	; 0x01
    196a:	82 81       	ldd	r24, Z+2	; 0x02
    196c:	93 81       	ldd	r25, Z+3	; 0x03
    196e:	20 e0       	ldi	r18, 0x00	; 0
    1970:	3f ef       	ldi	r19, 0xFF	; 255
    1972:	4f e7       	ldi	r20, 0x7F	; 127
    1974:	57 e4       	ldi	r21, 0x47	; 71
    1976:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    197a:	18 16       	cp	r1, r24
    197c:	64 f5       	brge	.+88     	; 0x19d6 <LCD_voidInit+0x284>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    197e:	fe 01       	movw	r30, r28
    1980:	ed 5b       	subi	r30, 0xBD	; 189
    1982:	ff 4f       	sbci	r31, 0xFF	; 255
    1984:	60 81       	ld	r22, Z
    1986:	71 81       	ldd	r23, Z+1	; 0x01
    1988:	82 81       	ldd	r24, Z+2	; 0x02
    198a:	93 81       	ldd	r25, Z+3	; 0x03
    198c:	20 e0       	ldi	r18, 0x00	; 0
    198e:	30 e0       	ldi	r19, 0x00	; 0
    1990:	40 e2       	ldi	r20, 0x20	; 32
    1992:	51 e4       	ldi	r21, 0x41	; 65
    1994:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1998:	dc 01       	movw	r26, r24
    199a:	cb 01       	movw	r24, r22
    199c:	bc 01       	movw	r22, r24
    199e:	cd 01       	movw	r24, r26
    19a0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    19a4:	dc 01       	movw	r26, r24
    19a6:	cb 01       	movw	r24, r22
    19a8:	9e af       	std	Y+62, r25	; 0x3e
    19aa:	8d af       	std	Y+61, r24	; 0x3d
    19ac:	0f c0       	rjmp	.+30     	; 0x19cc <LCD_voidInit+0x27a>
    19ae:	88 ec       	ldi	r24, 0xC8	; 200
    19b0:	90 e0       	ldi	r25, 0x00	; 0
    19b2:	9c af       	std	Y+60, r25	; 0x3c
    19b4:	8b af       	std	Y+59, r24	; 0x3b
    19b6:	8b ad       	ldd	r24, Y+59	; 0x3b
    19b8:	9c ad       	ldd	r25, Y+60	; 0x3c
    19ba:	01 97       	sbiw	r24, 0x01	; 1
    19bc:	f1 f7       	brne	.-4      	; 0x19ba <LCD_voidInit+0x268>
    19be:	9c af       	std	Y+60, r25	; 0x3c
    19c0:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    19c2:	8d ad       	ldd	r24, Y+61	; 0x3d
    19c4:	9e ad       	ldd	r25, Y+62	; 0x3e
    19c6:	01 97       	sbiw	r24, 0x01	; 1
    19c8:	9e af       	std	Y+62, r25	; 0x3e
    19ca:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    19cc:	8d ad       	ldd	r24, Y+61	; 0x3d
    19ce:	9e ad       	ldd	r25, Y+62	; 0x3e
    19d0:	00 97       	sbiw	r24, 0x00	; 0
    19d2:	69 f7       	brne	.-38     	; 0x19ae <LCD_voidInit+0x25c>
    19d4:	16 c0       	rjmp	.+44     	; 0x1a02 <LCD_voidInit+0x2b0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    19d6:	fe 01       	movw	r30, r28
    19d8:	ff 96       	adiw	r30, 0x3f	; 63
    19da:	60 81       	ld	r22, Z
    19dc:	71 81       	ldd	r23, Z+1	; 0x01
    19de:	82 81       	ldd	r24, Z+2	; 0x02
    19e0:	93 81       	ldd	r25, Z+3	; 0x03
    19e2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    19e6:	dc 01       	movw	r26, r24
    19e8:	cb 01       	movw	r24, r22
    19ea:	9e af       	std	Y+62, r25	; 0x3e
    19ec:	8d af       	std	Y+61, r24	; 0x3d
    19ee:	8d ad       	ldd	r24, Y+61	; 0x3d
    19f0:	9e ad       	ldd	r25, Y+62	; 0x3e
    19f2:	9a af       	std	Y+58, r25	; 0x3a
    19f4:	89 af       	std	Y+57, r24	; 0x39
    19f6:	89 ad       	ldd	r24, Y+57	; 0x39
    19f8:	9a ad       	ldd	r25, Y+58	; 0x3a
    19fa:	01 97       	sbiw	r24, 0x01	; 1
    19fc:	f1 f7       	brne	.-4      	; 0x19fa <LCD_voidInit+0x2a8>
    19fe:	9a af       	std	Y+58, r25	; 0x3a
    1a00:	89 af       	std	Y+57, r24	; 0x39
	_delay_ms(10);

	/* Return Home  */
	LCD_voidWriteCommand(0b00000010);
    1a02:	82 e0       	ldi	r24, 0x02	; 2
    1a04:	0e 94 e1 0e 	call	0x1dc2	; 0x1dc2 <LCD_voidWriteCommand>
    1a08:	80 e0       	ldi	r24, 0x00	; 0
    1a0a:	90 e0       	ldi	r25, 0x00	; 0
    1a0c:	a0 e2       	ldi	r26, 0x20	; 32
    1a0e:	b1 e4       	ldi	r27, 0x41	; 65
    1a10:	8d ab       	std	Y+53, r24	; 0x35
    1a12:	9e ab       	std	Y+54, r25	; 0x36
    1a14:	af ab       	std	Y+55, r26	; 0x37
    1a16:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1a18:	6d a9       	ldd	r22, Y+53	; 0x35
    1a1a:	7e a9       	ldd	r23, Y+54	; 0x36
    1a1c:	8f a9       	ldd	r24, Y+55	; 0x37
    1a1e:	98 ad       	ldd	r25, Y+56	; 0x38
    1a20:	20 e0       	ldi	r18, 0x00	; 0
    1a22:	30 e0       	ldi	r19, 0x00	; 0
    1a24:	4a ef       	ldi	r20, 0xFA	; 250
    1a26:	54 e4       	ldi	r21, 0x44	; 68
    1a28:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a2c:	dc 01       	movw	r26, r24
    1a2e:	cb 01       	movw	r24, r22
    1a30:	89 ab       	std	Y+49, r24	; 0x31
    1a32:	9a ab       	std	Y+50, r25	; 0x32
    1a34:	ab ab       	std	Y+51, r26	; 0x33
    1a36:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    1a38:	69 a9       	ldd	r22, Y+49	; 0x31
    1a3a:	7a a9       	ldd	r23, Y+50	; 0x32
    1a3c:	8b a9       	ldd	r24, Y+51	; 0x33
    1a3e:	9c a9       	ldd	r25, Y+52	; 0x34
    1a40:	20 e0       	ldi	r18, 0x00	; 0
    1a42:	30 e0       	ldi	r19, 0x00	; 0
    1a44:	40 e8       	ldi	r20, 0x80	; 128
    1a46:	5f e3       	ldi	r21, 0x3F	; 63
    1a48:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1a4c:	88 23       	and	r24, r24
    1a4e:	2c f4       	brge	.+10     	; 0x1a5a <LCD_voidInit+0x308>
		__ticks = 1;
    1a50:	81 e0       	ldi	r24, 0x01	; 1
    1a52:	90 e0       	ldi	r25, 0x00	; 0
    1a54:	98 ab       	std	Y+48, r25	; 0x30
    1a56:	8f a7       	std	Y+47, r24	; 0x2f
    1a58:	3f c0       	rjmp	.+126    	; 0x1ad8 <LCD_voidInit+0x386>
	else if (__tmp > 65535)
    1a5a:	69 a9       	ldd	r22, Y+49	; 0x31
    1a5c:	7a a9       	ldd	r23, Y+50	; 0x32
    1a5e:	8b a9       	ldd	r24, Y+51	; 0x33
    1a60:	9c a9       	ldd	r25, Y+52	; 0x34
    1a62:	20 e0       	ldi	r18, 0x00	; 0
    1a64:	3f ef       	ldi	r19, 0xFF	; 255
    1a66:	4f e7       	ldi	r20, 0x7F	; 127
    1a68:	57 e4       	ldi	r21, 0x47	; 71
    1a6a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1a6e:	18 16       	cp	r1, r24
    1a70:	4c f5       	brge	.+82     	; 0x1ac4 <LCD_voidInit+0x372>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1a72:	6d a9       	ldd	r22, Y+53	; 0x35
    1a74:	7e a9       	ldd	r23, Y+54	; 0x36
    1a76:	8f a9       	ldd	r24, Y+55	; 0x37
    1a78:	98 ad       	ldd	r25, Y+56	; 0x38
    1a7a:	20 e0       	ldi	r18, 0x00	; 0
    1a7c:	30 e0       	ldi	r19, 0x00	; 0
    1a7e:	40 e2       	ldi	r20, 0x20	; 32
    1a80:	51 e4       	ldi	r21, 0x41	; 65
    1a82:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a86:	dc 01       	movw	r26, r24
    1a88:	cb 01       	movw	r24, r22
    1a8a:	bc 01       	movw	r22, r24
    1a8c:	cd 01       	movw	r24, r26
    1a8e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a92:	dc 01       	movw	r26, r24
    1a94:	cb 01       	movw	r24, r22
    1a96:	98 ab       	std	Y+48, r25	; 0x30
    1a98:	8f a7       	std	Y+47, r24	; 0x2f
    1a9a:	0f c0       	rjmp	.+30     	; 0x1aba <LCD_voidInit+0x368>
    1a9c:	88 ec       	ldi	r24, 0xC8	; 200
    1a9e:	90 e0       	ldi	r25, 0x00	; 0
    1aa0:	9e a7       	std	Y+46, r25	; 0x2e
    1aa2:	8d a7       	std	Y+45, r24	; 0x2d
    1aa4:	8d a5       	ldd	r24, Y+45	; 0x2d
    1aa6:	9e a5       	ldd	r25, Y+46	; 0x2e
    1aa8:	01 97       	sbiw	r24, 0x01	; 1
    1aaa:	f1 f7       	brne	.-4      	; 0x1aa8 <LCD_voidInit+0x356>
    1aac:	9e a7       	std	Y+46, r25	; 0x2e
    1aae:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1ab0:	8f a5       	ldd	r24, Y+47	; 0x2f
    1ab2:	98 a9       	ldd	r25, Y+48	; 0x30
    1ab4:	01 97       	sbiw	r24, 0x01	; 1
    1ab6:	98 ab       	std	Y+48, r25	; 0x30
    1ab8:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1aba:	8f a5       	ldd	r24, Y+47	; 0x2f
    1abc:	98 a9       	ldd	r25, Y+48	; 0x30
    1abe:	00 97       	sbiw	r24, 0x00	; 0
    1ac0:	69 f7       	brne	.-38     	; 0x1a9c <LCD_voidInit+0x34a>
    1ac2:	14 c0       	rjmp	.+40     	; 0x1aec <LCD_voidInit+0x39a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1ac4:	69 a9       	ldd	r22, Y+49	; 0x31
    1ac6:	7a a9       	ldd	r23, Y+50	; 0x32
    1ac8:	8b a9       	ldd	r24, Y+51	; 0x33
    1aca:	9c a9       	ldd	r25, Y+52	; 0x34
    1acc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ad0:	dc 01       	movw	r26, r24
    1ad2:	cb 01       	movw	r24, r22
    1ad4:	98 ab       	std	Y+48, r25	; 0x30
    1ad6:	8f a7       	std	Y+47, r24	; 0x2f
    1ad8:	8f a5       	ldd	r24, Y+47	; 0x2f
    1ada:	98 a9       	ldd	r25, Y+48	; 0x30
    1adc:	9c a7       	std	Y+44, r25	; 0x2c
    1ade:	8b a7       	std	Y+43, r24	; 0x2b
    1ae0:	8b a5       	ldd	r24, Y+43	; 0x2b
    1ae2:	9c a5       	ldd	r25, Y+44	; 0x2c
    1ae4:	01 97       	sbiw	r24, 0x01	; 1
    1ae6:	f1 f7       	brne	.-4      	; 0x1ae4 <LCD_voidInit+0x392>
    1ae8:	9c a7       	std	Y+44, r25	; 0x2c
    1aea:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(10);

	/*Entry Mode Set */
	LCD_voidWriteCommand(0b00000110);
    1aec:	86 e0       	ldi	r24, 0x06	; 6
    1aee:	0e 94 e1 0e 	call	0x1dc2	; 0x1dc2 <LCD_voidWriteCommand>
    1af2:	80 e0       	ldi	r24, 0x00	; 0
    1af4:	90 e0       	ldi	r25, 0x00	; 0
    1af6:	a0 e2       	ldi	r26, 0x20	; 32
    1af8:	b1 e4       	ldi	r27, 0x41	; 65
    1afa:	8f a3       	std	Y+39, r24	; 0x27
    1afc:	98 a7       	std	Y+40, r25	; 0x28
    1afe:	a9 a7       	std	Y+41, r26	; 0x29
    1b00:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1b02:	6f a1       	ldd	r22, Y+39	; 0x27
    1b04:	78 a5       	ldd	r23, Y+40	; 0x28
    1b06:	89 a5       	ldd	r24, Y+41	; 0x29
    1b08:	9a a5       	ldd	r25, Y+42	; 0x2a
    1b0a:	20 e0       	ldi	r18, 0x00	; 0
    1b0c:	30 e0       	ldi	r19, 0x00	; 0
    1b0e:	4a ef       	ldi	r20, 0xFA	; 250
    1b10:	54 e4       	ldi	r21, 0x44	; 68
    1b12:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b16:	dc 01       	movw	r26, r24
    1b18:	cb 01       	movw	r24, r22
    1b1a:	8b a3       	std	Y+35, r24	; 0x23
    1b1c:	9c a3       	std	Y+36, r25	; 0x24
    1b1e:	ad a3       	std	Y+37, r26	; 0x25
    1b20:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1b22:	6b a1       	ldd	r22, Y+35	; 0x23
    1b24:	7c a1       	ldd	r23, Y+36	; 0x24
    1b26:	8d a1       	ldd	r24, Y+37	; 0x25
    1b28:	9e a1       	ldd	r25, Y+38	; 0x26
    1b2a:	20 e0       	ldi	r18, 0x00	; 0
    1b2c:	30 e0       	ldi	r19, 0x00	; 0
    1b2e:	40 e8       	ldi	r20, 0x80	; 128
    1b30:	5f e3       	ldi	r21, 0x3F	; 63
    1b32:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1b36:	88 23       	and	r24, r24
    1b38:	2c f4       	brge	.+10     	; 0x1b44 <LCD_voidInit+0x3f2>
		__ticks = 1;
    1b3a:	81 e0       	ldi	r24, 0x01	; 1
    1b3c:	90 e0       	ldi	r25, 0x00	; 0
    1b3e:	9a a3       	std	Y+34, r25	; 0x22
    1b40:	89 a3       	std	Y+33, r24	; 0x21
    1b42:	3f c0       	rjmp	.+126    	; 0x1bc2 <LCD_voidInit+0x470>
	else if (__tmp > 65535)
    1b44:	6b a1       	ldd	r22, Y+35	; 0x23
    1b46:	7c a1       	ldd	r23, Y+36	; 0x24
    1b48:	8d a1       	ldd	r24, Y+37	; 0x25
    1b4a:	9e a1       	ldd	r25, Y+38	; 0x26
    1b4c:	20 e0       	ldi	r18, 0x00	; 0
    1b4e:	3f ef       	ldi	r19, 0xFF	; 255
    1b50:	4f e7       	ldi	r20, 0x7F	; 127
    1b52:	57 e4       	ldi	r21, 0x47	; 71
    1b54:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1b58:	18 16       	cp	r1, r24
    1b5a:	4c f5       	brge	.+82     	; 0x1bae <LCD_voidInit+0x45c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1b5c:	6f a1       	ldd	r22, Y+39	; 0x27
    1b5e:	78 a5       	ldd	r23, Y+40	; 0x28
    1b60:	89 a5       	ldd	r24, Y+41	; 0x29
    1b62:	9a a5       	ldd	r25, Y+42	; 0x2a
    1b64:	20 e0       	ldi	r18, 0x00	; 0
    1b66:	30 e0       	ldi	r19, 0x00	; 0
    1b68:	40 e2       	ldi	r20, 0x20	; 32
    1b6a:	51 e4       	ldi	r21, 0x41	; 65
    1b6c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b70:	dc 01       	movw	r26, r24
    1b72:	cb 01       	movw	r24, r22
    1b74:	bc 01       	movw	r22, r24
    1b76:	cd 01       	movw	r24, r26
    1b78:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1b7c:	dc 01       	movw	r26, r24
    1b7e:	cb 01       	movw	r24, r22
    1b80:	9a a3       	std	Y+34, r25	; 0x22
    1b82:	89 a3       	std	Y+33, r24	; 0x21
    1b84:	0f c0       	rjmp	.+30     	; 0x1ba4 <LCD_voidInit+0x452>
    1b86:	88 ec       	ldi	r24, 0xC8	; 200
    1b88:	90 e0       	ldi	r25, 0x00	; 0
    1b8a:	98 a3       	std	Y+32, r25	; 0x20
    1b8c:	8f 8f       	std	Y+31, r24	; 0x1f
    1b8e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1b90:	98 a1       	ldd	r25, Y+32	; 0x20
    1b92:	01 97       	sbiw	r24, 0x01	; 1
    1b94:	f1 f7       	brne	.-4      	; 0x1b92 <LCD_voidInit+0x440>
    1b96:	98 a3       	std	Y+32, r25	; 0x20
    1b98:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1b9a:	89 a1       	ldd	r24, Y+33	; 0x21
    1b9c:	9a a1       	ldd	r25, Y+34	; 0x22
    1b9e:	01 97       	sbiw	r24, 0x01	; 1
    1ba0:	9a a3       	std	Y+34, r25	; 0x22
    1ba2:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1ba4:	89 a1       	ldd	r24, Y+33	; 0x21
    1ba6:	9a a1       	ldd	r25, Y+34	; 0x22
    1ba8:	00 97       	sbiw	r24, 0x00	; 0
    1baa:	69 f7       	brne	.-38     	; 0x1b86 <LCD_voidInit+0x434>
    1bac:	14 c0       	rjmp	.+40     	; 0x1bd6 <LCD_voidInit+0x484>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1bae:	6b a1       	ldd	r22, Y+35	; 0x23
    1bb0:	7c a1       	ldd	r23, Y+36	; 0x24
    1bb2:	8d a1       	ldd	r24, Y+37	; 0x25
    1bb4:	9e a1       	ldd	r25, Y+38	; 0x26
    1bb6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1bba:	dc 01       	movw	r26, r24
    1bbc:	cb 01       	movw	r24, r22
    1bbe:	9a a3       	std	Y+34, r25	; 0x22
    1bc0:	89 a3       	std	Y+33, r24	; 0x21
    1bc2:	89 a1       	ldd	r24, Y+33	; 0x21
    1bc4:	9a a1       	ldd	r25, Y+34	; 0x22
    1bc6:	9e 8f       	std	Y+30, r25	; 0x1e
    1bc8:	8d 8f       	std	Y+29, r24	; 0x1d
    1bca:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1bcc:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1bce:	01 97       	sbiw	r24, 0x01	; 1
    1bd0:	f1 f7       	brne	.-4      	; 0x1bce <LCD_voidInit+0x47c>
    1bd2:	9e 8f       	std	Y+30, r25	; 0x1e
    1bd4:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(10);

	/* Display ON OFF Control, crusor 0n */
	LCD_voidWriteCommand(0b00001110);
    1bd6:	8e e0       	ldi	r24, 0x0E	; 14
    1bd8:	0e 94 e1 0e 	call	0x1dc2	; 0x1dc2 <LCD_voidWriteCommand>
    1bdc:	80 e0       	ldi	r24, 0x00	; 0
    1bde:	90 e0       	ldi	r25, 0x00	; 0
    1be0:	a0 e2       	ldi	r26, 0x20	; 32
    1be2:	b1 e4       	ldi	r27, 0x41	; 65
    1be4:	89 8f       	std	Y+25, r24	; 0x19
    1be6:	9a 8f       	std	Y+26, r25	; 0x1a
    1be8:	ab 8f       	std	Y+27, r26	; 0x1b
    1bea:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1bec:	69 8d       	ldd	r22, Y+25	; 0x19
    1bee:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1bf0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1bf2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1bf4:	20 e0       	ldi	r18, 0x00	; 0
    1bf6:	30 e0       	ldi	r19, 0x00	; 0
    1bf8:	4a ef       	ldi	r20, 0xFA	; 250
    1bfa:	54 e4       	ldi	r21, 0x44	; 68
    1bfc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c00:	dc 01       	movw	r26, r24
    1c02:	cb 01       	movw	r24, r22
    1c04:	8d 8b       	std	Y+21, r24	; 0x15
    1c06:	9e 8b       	std	Y+22, r25	; 0x16
    1c08:	af 8b       	std	Y+23, r26	; 0x17
    1c0a:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1c0c:	6d 89       	ldd	r22, Y+21	; 0x15
    1c0e:	7e 89       	ldd	r23, Y+22	; 0x16
    1c10:	8f 89       	ldd	r24, Y+23	; 0x17
    1c12:	98 8d       	ldd	r25, Y+24	; 0x18
    1c14:	20 e0       	ldi	r18, 0x00	; 0
    1c16:	30 e0       	ldi	r19, 0x00	; 0
    1c18:	40 e8       	ldi	r20, 0x80	; 128
    1c1a:	5f e3       	ldi	r21, 0x3F	; 63
    1c1c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1c20:	88 23       	and	r24, r24
    1c22:	2c f4       	brge	.+10     	; 0x1c2e <LCD_voidInit+0x4dc>
		__ticks = 1;
    1c24:	81 e0       	ldi	r24, 0x01	; 1
    1c26:	90 e0       	ldi	r25, 0x00	; 0
    1c28:	9c 8b       	std	Y+20, r25	; 0x14
    1c2a:	8b 8b       	std	Y+19, r24	; 0x13
    1c2c:	3f c0       	rjmp	.+126    	; 0x1cac <LCD_voidInit+0x55a>
	else if (__tmp > 65535)
    1c2e:	6d 89       	ldd	r22, Y+21	; 0x15
    1c30:	7e 89       	ldd	r23, Y+22	; 0x16
    1c32:	8f 89       	ldd	r24, Y+23	; 0x17
    1c34:	98 8d       	ldd	r25, Y+24	; 0x18
    1c36:	20 e0       	ldi	r18, 0x00	; 0
    1c38:	3f ef       	ldi	r19, 0xFF	; 255
    1c3a:	4f e7       	ldi	r20, 0x7F	; 127
    1c3c:	57 e4       	ldi	r21, 0x47	; 71
    1c3e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1c42:	18 16       	cp	r1, r24
    1c44:	4c f5       	brge	.+82     	; 0x1c98 <LCD_voidInit+0x546>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1c46:	69 8d       	ldd	r22, Y+25	; 0x19
    1c48:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1c4a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1c4c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1c4e:	20 e0       	ldi	r18, 0x00	; 0
    1c50:	30 e0       	ldi	r19, 0x00	; 0
    1c52:	40 e2       	ldi	r20, 0x20	; 32
    1c54:	51 e4       	ldi	r21, 0x41	; 65
    1c56:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c5a:	dc 01       	movw	r26, r24
    1c5c:	cb 01       	movw	r24, r22
    1c5e:	bc 01       	movw	r22, r24
    1c60:	cd 01       	movw	r24, r26
    1c62:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c66:	dc 01       	movw	r26, r24
    1c68:	cb 01       	movw	r24, r22
    1c6a:	9c 8b       	std	Y+20, r25	; 0x14
    1c6c:	8b 8b       	std	Y+19, r24	; 0x13
    1c6e:	0f c0       	rjmp	.+30     	; 0x1c8e <LCD_voidInit+0x53c>
    1c70:	88 ec       	ldi	r24, 0xC8	; 200
    1c72:	90 e0       	ldi	r25, 0x00	; 0
    1c74:	9a 8b       	std	Y+18, r25	; 0x12
    1c76:	89 8b       	std	Y+17, r24	; 0x11
    1c78:	89 89       	ldd	r24, Y+17	; 0x11
    1c7a:	9a 89       	ldd	r25, Y+18	; 0x12
    1c7c:	01 97       	sbiw	r24, 0x01	; 1
    1c7e:	f1 f7       	brne	.-4      	; 0x1c7c <LCD_voidInit+0x52a>
    1c80:	9a 8b       	std	Y+18, r25	; 0x12
    1c82:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1c84:	8b 89       	ldd	r24, Y+19	; 0x13
    1c86:	9c 89       	ldd	r25, Y+20	; 0x14
    1c88:	01 97       	sbiw	r24, 0x01	; 1
    1c8a:	9c 8b       	std	Y+20, r25	; 0x14
    1c8c:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1c8e:	8b 89       	ldd	r24, Y+19	; 0x13
    1c90:	9c 89       	ldd	r25, Y+20	; 0x14
    1c92:	00 97       	sbiw	r24, 0x00	; 0
    1c94:	69 f7       	brne	.-38     	; 0x1c70 <LCD_voidInit+0x51e>
    1c96:	14 c0       	rjmp	.+40     	; 0x1cc0 <LCD_voidInit+0x56e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1c98:	6d 89       	ldd	r22, Y+21	; 0x15
    1c9a:	7e 89       	ldd	r23, Y+22	; 0x16
    1c9c:	8f 89       	ldd	r24, Y+23	; 0x17
    1c9e:	98 8d       	ldd	r25, Y+24	; 0x18
    1ca0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ca4:	dc 01       	movw	r26, r24
    1ca6:	cb 01       	movw	r24, r22
    1ca8:	9c 8b       	std	Y+20, r25	; 0x14
    1caa:	8b 8b       	std	Y+19, r24	; 0x13
    1cac:	8b 89       	ldd	r24, Y+19	; 0x13
    1cae:	9c 89       	ldd	r25, Y+20	; 0x14
    1cb0:	98 8b       	std	Y+16, r25	; 0x10
    1cb2:	8f 87       	std	Y+15, r24	; 0x0f
    1cb4:	8f 85       	ldd	r24, Y+15	; 0x0f
    1cb6:	98 89       	ldd	r25, Y+16	; 0x10
    1cb8:	01 97       	sbiw	r24, 0x01	; 1
    1cba:	f1 f7       	brne	.-4      	; 0x1cb8 <LCD_voidInit+0x566>
    1cbc:	98 8b       	std	Y+16, r25	; 0x10
    1cbe:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(10);

	/* Function Set  */
	LCD_voidWriteCommand(0b00111000);
    1cc0:	88 e3       	ldi	r24, 0x38	; 56
    1cc2:	0e 94 e1 0e 	call	0x1dc2	; 0x1dc2 <LCD_voidWriteCommand>
    1cc6:	80 e0       	ldi	r24, 0x00	; 0
    1cc8:	90 e0       	ldi	r25, 0x00	; 0
    1cca:	a0 e2       	ldi	r26, 0x20	; 32
    1ccc:	b1 e4       	ldi	r27, 0x41	; 65
    1cce:	8b 87       	std	Y+11, r24	; 0x0b
    1cd0:	9c 87       	std	Y+12, r25	; 0x0c
    1cd2:	ad 87       	std	Y+13, r26	; 0x0d
    1cd4:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1cd6:	6b 85       	ldd	r22, Y+11	; 0x0b
    1cd8:	7c 85       	ldd	r23, Y+12	; 0x0c
    1cda:	8d 85       	ldd	r24, Y+13	; 0x0d
    1cdc:	9e 85       	ldd	r25, Y+14	; 0x0e
    1cde:	20 e0       	ldi	r18, 0x00	; 0
    1ce0:	30 e0       	ldi	r19, 0x00	; 0
    1ce2:	4a ef       	ldi	r20, 0xFA	; 250
    1ce4:	54 e4       	ldi	r21, 0x44	; 68
    1ce6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1cea:	dc 01       	movw	r26, r24
    1cec:	cb 01       	movw	r24, r22
    1cee:	8f 83       	std	Y+7, r24	; 0x07
    1cf0:	98 87       	std	Y+8, r25	; 0x08
    1cf2:	a9 87       	std	Y+9, r26	; 0x09
    1cf4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1cf6:	6f 81       	ldd	r22, Y+7	; 0x07
    1cf8:	78 85       	ldd	r23, Y+8	; 0x08
    1cfa:	89 85       	ldd	r24, Y+9	; 0x09
    1cfc:	9a 85       	ldd	r25, Y+10	; 0x0a
    1cfe:	20 e0       	ldi	r18, 0x00	; 0
    1d00:	30 e0       	ldi	r19, 0x00	; 0
    1d02:	40 e8       	ldi	r20, 0x80	; 128
    1d04:	5f e3       	ldi	r21, 0x3F	; 63
    1d06:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1d0a:	88 23       	and	r24, r24
    1d0c:	2c f4       	brge	.+10     	; 0x1d18 <LCD_voidInit+0x5c6>
		__ticks = 1;
    1d0e:	81 e0       	ldi	r24, 0x01	; 1
    1d10:	90 e0       	ldi	r25, 0x00	; 0
    1d12:	9e 83       	std	Y+6, r25	; 0x06
    1d14:	8d 83       	std	Y+5, r24	; 0x05
    1d16:	3f c0       	rjmp	.+126    	; 0x1d96 <LCD_voidInit+0x644>
	else if (__tmp > 65535)
    1d18:	6f 81       	ldd	r22, Y+7	; 0x07
    1d1a:	78 85       	ldd	r23, Y+8	; 0x08
    1d1c:	89 85       	ldd	r24, Y+9	; 0x09
    1d1e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d20:	20 e0       	ldi	r18, 0x00	; 0
    1d22:	3f ef       	ldi	r19, 0xFF	; 255
    1d24:	4f e7       	ldi	r20, 0x7F	; 127
    1d26:	57 e4       	ldi	r21, 0x47	; 71
    1d28:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1d2c:	18 16       	cp	r1, r24
    1d2e:	4c f5       	brge	.+82     	; 0x1d82 <LCD_voidInit+0x630>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1d30:	6b 85       	ldd	r22, Y+11	; 0x0b
    1d32:	7c 85       	ldd	r23, Y+12	; 0x0c
    1d34:	8d 85       	ldd	r24, Y+13	; 0x0d
    1d36:	9e 85       	ldd	r25, Y+14	; 0x0e
    1d38:	20 e0       	ldi	r18, 0x00	; 0
    1d3a:	30 e0       	ldi	r19, 0x00	; 0
    1d3c:	40 e2       	ldi	r20, 0x20	; 32
    1d3e:	51 e4       	ldi	r21, 0x41	; 65
    1d40:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1d44:	dc 01       	movw	r26, r24
    1d46:	cb 01       	movw	r24, r22
    1d48:	bc 01       	movw	r22, r24
    1d4a:	cd 01       	movw	r24, r26
    1d4c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1d50:	dc 01       	movw	r26, r24
    1d52:	cb 01       	movw	r24, r22
    1d54:	9e 83       	std	Y+6, r25	; 0x06
    1d56:	8d 83       	std	Y+5, r24	; 0x05
    1d58:	0f c0       	rjmp	.+30     	; 0x1d78 <LCD_voidInit+0x626>
    1d5a:	88 ec       	ldi	r24, 0xC8	; 200
    1d5c:	90 e0       	ldi	r25, 0x00	; 0
    1d5e:	9c 83       	std	Y+4, r25	; 0x04
    1d60:	8b 83       	std	Y+3, r24	; 0x03
    1d62:	8b 81       	ldd	r24, Y+3	; 0x03
    1d64:	9c 81       	ldd	r25, Y+4	; 0x04
    1d66:	01 97       	sbiw	r24, 0x01	; 1
    1d68:	f1 f7       	brne	.-4      	; 0x1d66 <LCD_voidInit+0x614>
    1d6a:	9c 83       	std	Y+4, r25	; 0x04
    1d6c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1d6e:	8d 81       	ldd	r24, Y+5	; 0x05
    1d70:	9e 81       	ldd	r25, Y+6	; 0x06
    1d72:	01 97       	sbiw	r24, 0x01	; 1
    1d74:	9e 83       	std	Y+6, r25	; 0x06
    1d76:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1d78:	8d 81       	ldd	r24, Y+5	; 0x05
    1d7a:	9e 81       	ldd	r25, Y+6	; 0x06
    1d7c:	00 97       	sbiw	r24, 0x00	; 0
    1d7e:	69 f7       	brne	.-38     	; 0x1d5a <LCD_voidInit+0x608>
    1d80:	14 c0       	rjmp	.+40     	; 0x1daa <LCD_voidInit+0x658>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1d82:	6f 81       	ldd	r22, Y+7	; 0x07
    1d84:	78 85       	ldd	r23, Y+8	; 0x08
    1d86:	89 85       	ldd	r24, Y+9	; 0x09
    1d88:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d8a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1d8e:	dc 01       	movw	r26, r24
    1d90:	cb 01       	movw	r24, r22
    1d92:	9e 83       	std	Y+6, r25	; 0x06
    1d94:	8d 83       	std	Y+5, r24	; 0x05
    1d96:	8d 81       	ldd	r24, Y+5	; 0x05
    1d98:	9e 81       	ldd	r25, Y+6	; 0x06
    1d9a:	9a 83       	std	Y+2, r25	; 0x02
    1d9c:	89 83       	std	Y+1, r24	; 0x01
    1d9e:	89 81       	ldd	r24, Y+1	; 0x01
    1da0:	9a 81       	ldd	r25, Y+2	; 0x02
    1da2:	01 97       	sbiw	r24, 0x01	; 1
    1da4:	f1 f7       	brne	.-4      	; 0x1da2 <LCD_voidInit+0x650>
    1da6:	9a 83       	std	Y+2, r25	; 0x02
    1da8:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(10);


} /* end of function LCD_voidInit */
    1daa:	cc 5a       	subi	r28, 0xAC	; 172
    1dac:	df 4f       	sbci	r29, 0xFF	; 255
    1dae:	0f b6       	in	r0, 0x3f	; 63
    1db0:	f8 94       	cli
    1db2:	de bf       	out	0x3e, r29	; 62
    1db4:	0f be       	out	0x3f, r0	; 63
    1db6:	cd bf       	out	0x3d, r28	; 61
    1db8:	cf 91       	pop	r28
    1dba:	df 91       	pop	r29
    1dbc:	1f 91       	pop	r17
    1dbe:	0f 91       	pop	r16
    1dc0:	08 95       	ret

00001dc2 <LCD_voidWriteCommand>:


extern void LCD_voidWriteCommand(U8 command)
{
    1dc2:	df 93       	push	r29
    1dc4:	cf 93       	push	r28
    1dc6:	cd b7       	in	r28, 0x3d	; 61
    1dc8:	de b7       	in	r29, 0x3e	; 62
    1dca:	2f 97       	sbiw	r28, 0x0f	; 15
    1dcc:	0f b6       	in	r0, 0x3f	; 63
    1dce:	f8 94       	cli
    1dd0:	de bf       	out	0x3e, r29	; 62
    1dd2:	0f be       	out	0x3f, r0	; 63
    1dd4:	cd bf       	out	0x3d, r28	; 61
    1dd6:	8f 87       	std	Y+15, r24	; 0x0f
		/*  RS -> 0, to command */
	DIO_voidWritePin(LCD_RS,DIO_u8Low);
    1dd8:	80 e0       	ldi	r24, 0x00	; 0
    1dda:	90 e0       	ldi	r25, 0x00	; 0
    1ddc:	60 e0       	ldi	r22, 0x00	; 0
    1dde:	70 e0       	ldi	r23, 0x00	; 0
    1de0:	0e 94 7d 09 	call	0x12fa	; 0x12fa <DIO_voidWritePin>

		/* RW -> 0, to write */
	DIO_voidWritePin(LCD_RW,DIO_u8Low);
    1de4:	81 e0       	ldi	r24, 0x01	; 1
    1de6:	90 e0       	ldi	r25, 0x00	; 0
    1de8:	60 e0       	ldi	r22, 0x00	; 0
    1dea:	70 e0       	ldi	r23, 0x00	; 0
    1dec:	0e 94 7d 09 	call	0x12fa	; 0x12fa <DIO_voidWritePin>

		/* Read the command */
	DIO_voidWritePort(PORT, command);
    1df0:	83 e4       	ldi	r24, 0x43	; 67
    1df2:	6f 85       	ldd	r22, Y+15	; 0x0f
    1df4:	0e 94 65 0b 	call	0x16ca	; 0x16ca <DIO_voidWritePort>
	//	PORTD = command;

		/* Enable */
	DIO_voidWritePin(LCD_E,DIO_u8High);
    1df8:	82 e0       	ldi	r24, 0x02	; 2
    1dfa:	90 e0       	ldi	r25, 0x00	; 0
    1dfc:	61 e0       	ldi	r22, 0x01	; 1
    1dfe:	70 e0       	ldi	r23, 0x00	; 0
    1e00:	0e 94 7d 09 	call	0x12fa	; 0x12fa <DIO_voidWritePin>
    1e04:	80 e0       	ldi	r24, 0x00	; 0
    1e06:	90 e0       	ldi	r25, 0x00	; 0
    1e08:	a0 e0       	ldi	r26, 0x00	; 0
    1e0a:	b0 e4       	ldi	r27, 0x40	; 64
    1e0c:	8b 87       	std	Y+11, r24	; 0x0b
    1e0e:	9c 87       	std	Y+12, r25	; 0x0c
    1e10:	ad 87       	std	Y+13, r26	; 0x0d
    1e12:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1e14:	6b 85       	ldd	r22, Y+11	; 0x0b
    1e16:	7c 85       	ldd	r23, Y+12	; 0x0c
    1e18:	8d 85       	ldd	r24, Y+13	; 0x0d
    1e1a:	9e 85       	ldd	r25, Y+14	; 0x0e
    1e1c:	20 e0       	ldi	r18, 0x00	; 0
    1e1e:	30 e0       	ldi	r19, 0x00	; 0
    1e20:	4a ef       	ldi	r20, 0xFA	; 250
    1e22:	54 e4       	ldi	r21, 0x44	; 68
    1e24:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1e28:	dc 01       	movw	r26, r24
    1e2a:	cb 01       	movw	r24, r22
    1e2c:	8f 83       	std	Y+7, r24	; 0x07
    1e2e:	98 87       	std	Y+8, r25	; 0x08
    1e30:	a9 87       	std	Y+9, r26	; 0x09
    1e32:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1e34:	6f 81       	ldd	r22, Y+7	; 0x07
    1e36:	78 85       	ldd	r23, Y+8	; 0x08
    1e38:	89 85       	ldd	r24, Y+9	; 0x09
    1e3a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e3c:	20 e0       	ldi	r18, 0x00	; 0
    1e3e:	30 e0       	ldi	r19, 0x00	; 0
    1e40:	40 e8       	ldi	r20, 0x80	; 128
    1e42:	5f e3       	ldi	r21, 0x3F	; 63
    1e44:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1e48:	88 23       	and	r24, r24
    1e4a:	2c f4       	brge	.+10     	; 0x1e56 <LCD_voidWriteCommand+0x94>
		__ticks = 1;
    1e4c:	81 e0       	ldi	r24, 0x01	; 1
    1e4e:	90 e0       	ldi	r25, 0x00	; 0
    1e50:	9e 83       	std	Y+6, r25	; 0x06
    1e52:	8d 83       	std	Y+5, r24	; 0x05
    1e54:	3f c0       	rjmp	.+126    	; 0x1ed4 <LCD_voidWriteCommand+0x112>
	else if (__tmp > 65535)
    1e56:	6f 81       	ldd	r22, Y+7	; 0x07
    1e58:	78 85       	ldd	r23, Y+8	; 0x08
    1e5a:	89 85       	ldd	r24, Y+9	; 0x09
    1e5c:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e5e:	20 e0       	ldi	r18, 0x00	; 0
    1e60:	3f ef       	ldi	r19, 0xFF	; 255
    1e62:	4f e7       	ldi	r20, 0x7F	; 127
    1e64:	57 e4       	ldi	r21, 0x47	; 71
    1e66:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1e6a:	18 16       	cp	r1, r24
    1e6c:	4c f5       	brge	.+82     	; 0x1ec0 <LCD_voidWriteCommand+0xfe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1e6e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1e70:	7c 85       	ldd	r23, Y+12	; 0x0c
    1e72:	8d 85       	ldd	r24, Y+13	; 0x0d
    1e74:	9e 85       	ldd	r25, Y+14	; 0x0e
    1e76:	20 e0       	ldi	r18, 0x00	; 0
    1e78:	30 e0       	ldi	r19, 0x00	; 0
    1e7a:	40 e2       	ldi	r20, 0x20	; 32
    1e7c:	51 e4       	ldi	r21, 0x41	; 65
    1e7e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1e82:	dc 01       	movw	r26, r24
    1e84:	cb 01       	movw	r24, r22
    1e86:	bc 01       	movw	r22, r24
    1e88:	cd 01       	movw	r24, r26
    1e8a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e8e:	dc 01       	movw	r26, r24
    1e90:	cb 01       	movw	r24, r22
    1e92:	9e 83       	std	Y+6, r25	; 0x06
    1e94:	8d 83       	std	Y+5, r24	; 0x05
    1e96:	0f c0       	rjmp	.+30     	; 0x1eb6 <LCD_voidWriteCommand+0xf4>
    1e98:	88 ec       	ldi	r24, 0xC8	; 200
    1e9a:	90 e0       	ldi	r25, 0x00	; 0
    1e9c:	9c 83       	std	Y+4, r25	; 0x04
    1e9e:	8b 83       	std	Y+3, r24	; 0x03
    1ea0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ea2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ea4:	01 97       	sbiw	r24, 0x01	; 1
    1ea6:	f1 f7       	brne	.-4      	; 0x1ea4 <LCD_voidWriteCommand+0xe2>
    1ea8:	9c 83       	std	Y+4, r25	; 0x04
    1eaa:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1eac:	8d 81       	ldd	r24, Y+5	; 0x05
    1eae:	9e 81       	ldd	r25, Y+6	; 0x06
    1eb0:	01 97       	sbiw	r24, 0x01	; 1
    1eb2:	9e 83       	std	Y+6, r25	; 0x06
    1eb4:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1eb6:	8d 81       	ldd	r24, Y+5	; 0x05
    1eb8:	9e 81       	ldd	r25, Y+6	; 0x06
    1eba:	00 97       	sbiw	r24, 0x00	; 0
    1ebc:	69 f7       	brne	.-38     	; 0x1e98 <LCD_voidWriteCommand+0xd6>
    1ebe:	14 c0       	rjmp	.+40     	; 0x1ee8 <LCD_voidWriteCommand+0x126>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1ec0:	6f 81       	ldd	r22, Y+7	; 0x07
    1ec2:	78 85       	ldd	r23, Y+8	; 0x08
    1ec4:	89 85       	ldd	r24, Y+9	; 0x09
    1ec6:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ec8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ecc:	dc 01       	movw	r26, r24
    1ece:	cb 01       	movw	r24, r22
    1ed0:	9e 83       	std	Y+6, r25	; 0x06
    1ed2:	8d 83       	std	Y+5, r24	; 0x05
    1ed4:	8d 81       	ldd	r24, Y+5	; 0x05
    1ed6:	9e 81       	ldd	r25, Y+6	; 0x06
    1ed8:	9a 83       	std	Y+2, r25	; 0x02
    1eda:	89 83       	std	Y+1, r24	; 0x01
    1edc:	89 81       	ldd	r24, Y+1	; 0x01
    1ede:	9a 81       	ldd	r25, Y+2	; 0x02
    1ee0:	01 97       	sbiw	r24, 0x01	; 1
    1ee2:	f1 f7       	brne	.-4      	; 0x1ee0 <LCD_voidWriteCommand+0x11e>
    1ee4:	9a 83       	std	Y+2, r25	; 0x02
    1ee6:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2); // 2 ms to excute.
	DIO_voidWritePin(LCD_E,DIO_u8Low);
    1ee8:	82 e0       	ldi	r24, 0x02	; 2
    1eea:	90 e0       	ldi	r25, 0x00	; 0
    1eec:	60 e0       	ldi	r22, 0x00	; 0
    1eee:	70 e0       	ldi	r23, 0x00	; 0
    1ef0:	0e 94 7d 09 	call	0x12fa	; 0x12fa <DIO_voidWritePin>


}/* end of function LCD_voidWriteCommand */
    1ef4:	2f 96       	adiw	r28, 0x0f	; 15
    1ef6:	0f b6       	in	r0, 0x3f	; 63
    1ef8:	f8 94       	cli
    1efa:	de bf       	out	0x3e, r29	; 62
    1efc:	0f be       	out	0x3f, r0	; 63
    1efe:	cd bf       	out	0x3d, r28	; 61
    1f00:	cf 91       	pop	r28
    1f02:	df 91       	pop	r29
    1f04:	08 95       	ret

00001f06 <LCD_voidDisplay>:


extern void LCD_voidDisplay(U8 data)
{
    1f06:	df 93       	push	r29
    1f08:	cf 93       	push	r28
    1f0a:	cd b7       	in	r28, 0x3d	; 61
    1f0c:	de b7       	in	r29, 0x3e	; 62
    1f0e:	6d 97       	sbiw	r28, 0x1d	; 29
    1f10:	0f b6       	in	r0, 0x3f	; 63
    1f12:	f8 94       	cli
    1f14:	de bf       	out	0x3e, r29	; 62
    1f16:	0f be       	out	0x3f, r0	; 63
    1f18:	cd bf       	out	0x3d, r28	; 61
    1f1a:	8d 8f       	std	Y+29, r24	; 0x1d
		/*  RS -> 1, to Display Data */
	DIO_voidWritePin(LCD_RS,DIO_u8High);
    1f1c:	80 e0       	ldi	r24, 0x00	; 0
    1f1e:	90 e0       	ldi	r25, 0x00	; 0
    1f20:	61 e0       	ldi	r22, 0x01	; 1
    1f22:	70 e0       	ldi	r23, 0x00	; 0
    1f24:	0e 94 7d 09 	call	0x12fa	; 0x12fa <DIO_voidWritePin>

		/* RW -> 0, to write */
	DIO_voidWritePin(LCD_RW,DIO_u8Low);
    1f28:	81 e0       	ldi	r24, 0x01	; 1
    1f2a:	90 e0       	ldi	r25, 0x00	; 0
    1f2c:	60 e0       	ldi	r22, 0x00	; 0
    1f2e:	70 e0       	ldi	r23, 0x00	; 0
    1f30:	0e 94 7d 09 	call	0x12fa	; 0x12fa <DIO_voidWritePin>

		/* Enable */
	DIO_voidWritePin(LCD_E,DIO_u8High);
    1f34:	82 e0       	ldi	r24, 0x02	; 2
    1f36:	90 e0       	ldi	r25, 0x00	; 0
    1f38:	61 e0       	ldi	r22, 0x01	; 1
    1f3a:	70 e0       	ldi	r23, 0x00	; 0
    1f3c:	0e 94 7d 09 	call	0x12fa	; 0x12fa <DIO_voidWritePin>

		/* Read the command */
	DIO_voidWritePort(PORT, data);
    1f40:	83 e4       	ldi	r24, 0x43	; 67
    1f42:	6d 8d       	ldd	r22, Y+29	; 0x1d
    1f44:	0e 94 65 0b 	call	0x16ca	; 0x16ca <DIO_voidWritePort>
    1f48:	80 e0       	ldi	r24, 0x00	; 0
    1f4a:	90 e0       	ldi	r25, 0x00	; 0
    1f4c:	a0 e0       	ldi	r26, 0x00	; 0
    1f4e:	b0 e4       	ldi	r27, 0x40	; 64
    1f50:	89 8f       	std	Y+25, r24	; 0x19
    1f52:	9a 8f       	std	Y+26, r25	; 0x1a
    1f54:	ab 8f       	std	Y+27, r26	; 0x1b
    1f56:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1f58:	69 8d       	ldd	r22, Y+25	; 0x19
    1f5a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1f5c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1f5e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1f60:	20 e0       	ldi	r18, 0x00	; 0
    1f62:	30 e0       	ldi	r19, 0x00	; 0
    1f64:	4a ef       	ldi	r20, 0xFA	; 250
    1f66:	54 e4       	ldi	r21, 0x44	; 68
    1f68:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f6c:	dc 01       	movw	r26, r24
    1f6e:	cb 01       	movw	r24, r22
    1f70:	8d 8b       	std	Y+21, r24	; 0x15
    1f72:	9e 8b       	std	Y+22, r25	; 0x16
    1f74:	af 8b       	std	Y+23, r26	; 0x17
    1f76:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1f78:	6d 89       	ldd	r22, Y+21	; 0x15
    1f7a:	7e 89       	ldd	r23, Y+22	; 0x16
    1f7c:	8f 89       	ldd	r24, Y+23	; 0x17
    1f7e:	98 8d       	ldd	r25, Y+24	; 0x18
    1f80:	20 e0       	ldi	r18, 0x00	; 0
    1f82:	30 e0       	ldi	r19, 0x00	; 0
    1f84:	40 e8       	ldi	r20, 0x80	; 128
    1f86:	5f e3       	ldi	r21, 0x3F	; 63
    1f88:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1f8c:	88 23       	and	r24, r24
    1f8e:	2c f4       	brge	.+10     	; 0x1f9a <LCD_voidDisplay+0x94>
		__ticks = 1;
    1f90:	81 e0       	ldi	r24, 0x01	; 1
    1f92:	90 e0       	ldi	r25, 0x00	; 0
    1f94:	9c 8b       	std	Y+20, r25	; 0x14
    1f96:	8b 8b       	std	Y+19, r24	; 0x13
    1f98:	3f c0       	rjmp	.+126    	; 0x2018 <LCD_voidDisplay+0x112>
	else if (__tmp > 65535)
    1f9a:	6d 89       	ldd	r22, Y+21	; 0x15
    1f9c:	7e 89       	ldd	r23, Y+22	; 0x16
    1f9e:	8f 89       	ldd	r24, Y+23	; 0x17
    1fa0:	98 8d       	ldd	r25, Y+24	; 0x18
    1fa2:	20 e0       	ldi	r18, 0x00	; 0
    1fa4:	3f ef       	ldi	r19, 0xFF	; 255
    1fa6:	4f e7       	ldi	r20, 0x7F	; 127
    1fa8:	57 e4       	ldi	r21, 0x47	; 71
    1faa:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1fae:	18 16       	cp	r1, r24
    1fb0:	4c f5       	brge	.+82     	; 0x2004 <LCD_voidDisplay+0xfe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1fb2:	69 8d       	ldd	r22, Y+25	; 0x19
    1fb4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1fb6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1fb8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1fba:	20 e0       	ldi	r18, 0x00	; 0
    1fbc:	30 e0       	ldi	r19, 0x00	; 0
    1fbe:	40 e2       	ldi	r20, 0x20	; 32
    1fc0:	51 e4       	ldi	r21, 0x41	; 65
    1fc2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1fc6:	dc 01       	movw	r26, r24
    1fc8:	cb 01       	movw	r24, r22
    1fca:	bc 01       	movw	r22, r24
    1fcc:	cd 01       	movw	r24, r26
    1fce:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1fd2:	dc 01       	movw	r26, r24
    1fd4:	cb 01       	movw	r24, r22
    1fd6:	9c 8b       	std	Y+20, r25	; 0x14
    1fd8:	8b 8b       	std	Y+19, r24	; 0x13
    1fda:	0f c0       	rjmp	.+30     	; 0x1ffa <LCD_voidDisplay+0xf4>
    1fdc:	88 ec       	ldi	r24, 0xC8	; 200
    1fde:	90 e0       	ldi	r25, 0x00	; 0
    1fe0:	9a 8b       	std	Y+18, r25	; 0x12
    1fe2:	89 8b       	std	Y+17, r24	; 0x11
    1fe4:	89 89       	ldd	r24, Y+17	; 0x11
    1fe6:	9a 89       	ldd	r25, Y+18	; 0x12
    1fe8:	01 97       	sbiw	r24, 0x01	; 1
    1fea:	f1 f7       	brne	.-4      	; 0x1fe8 <LCD_voidDisplay+0xe2>
    1fec:	9a 8b       	std	Y+18, r25	; 0x12
    1fee:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1ff0:	8b 89       	ldd	r24, Y+19	; 0x13
    1ff2:	9c 89       	ldd	r25, Y+20	; 0x14
    1ff4:	01 97       	sbiw	r24, 0x01	; 1
    1ff6:	9c 8b       	std	Y+20, r25	; 0x14
    1ff8:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1ffa:	8b 89       	ldd	r24, Y+19	; 0x13
    1ffc:	9c 89       	ldd	r25, Y+20	; 0x14
    1ffe:	00 97       	sbiw	r24, 0x00	; 0
    2000:	69 f7       	brne	.-38     	; 0x1fdc <LCD_voidDisplay+0xd6>
    2002:	14 c0       	rjmp	.+40     	; 0x202c <LCD_voidDisplay+0x126>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2004:	6d 89       	ldd	r22, Y+21	; 0x15
    2006:	7e 89       	ldd	r23, Y+22	; 0x16
    2008:	8f 89       	ldd	r24, Y+23	; 0x17
    200a:	98 8d       	ldd	r25, Y+24	; 0x18
    200c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2010:	dc 01       	movw	r26, r24
    2012:	cb 01       	movw	r24, r22
    2014:	9c 8b       	std	Y+20, r25	; 0x14
    2016:	8b 8b       	std	Y+19, r24	; 0x13
    2018:	8b 89       	ldd	r24, Y+19	; 0x13
    201a:	9c 89       	ldd	r25, Y+20	; 0x14
    201c:	98 8b       	std	Y+16, r25	; 0x10
    201e:	8f 87       	std	Y+15, r24	; 0x0f
    2020:	8f 85       	ldd	r24, Y+15	; 0x0f
    2022:	98 89       	ldd	r25, Y+16	; 0x10
    2024:	01 97       	sbiw	r24, 0x01	; 1
    2026:	f1 f7       	brne	.-4      	; 0x2024 <LCD_voidDisplay+0x11e>
    2028:	98 8b       	std	Y+16, r25	; 0x10
    202a:	8f 87       	std	Y+15, r24	; 0x0f


	_delay_ms(2); // 2 ms to excute.
	DIO_voidWritePin(LCD_E,DIO_u8Low);
    202c:	82 e0       	ldi	r24, 0x02	; 2
    202e:	90 e0       	ldi	r25, 0x00	; 0
    2030:	60 e0       	ldi	r22, 0x00	; 0
    2032:	70 e0       	ldi	r23, 0x00	; 0
    2034:	0e 94 7d 09 	call	0x12fa	; 0x12fa <DIO_voidWritePin>
    2038:	80 e0       	ldi	r24, 0x00	; 0
    203a:	90 e0       	ldi	r25, 0x00	; 0
    203c:	a0 ea       	ldi	r26, 0xA0	; 160
    203e:	b0 e4       	ldi	r27, 0x40	; 64
    2040:	8b 87       	std	Y+11, r24	; 0x0b
    2042:	9c 87       	std	Y+12, r25	; 0x0c
    2044:	ad 87       	std	Y+13, r26	; 0x0d
    2046:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2048:	6b 85       	ldd	r22, Y+11	; 0x0b
    204a:	7c 85       	ldd	r23, Y+12	; 0x0c
    204c:	8d 85       	ldd	r24, Y+13	; 0x0d
    204e:	9e 85       	ldd	r25, Y+14	; 0x0e
    2050:	20 e0       	ldi	r18, 0x00	; 0
    2052:	30 e0       	ldi	r19, 0x00	; 0
    2054:	4a ef       	ldi	r20, 0xFA	; 250
    2056:	54 e4       	ldi	r21, 0x44	; 68
    2058:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    205c:	dc 01       	movw	r26, r24
    205e:	cb 01       	movw	r24, r22
    2060:	8f 83       	std	Y+7, r24	; 0x07
    2062:	98 87       	std	Y+8, r25	; 0x08
    2064:	a9 87       	std	Y+9, r26	; 0x09
    2066:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2068:	6f 81       	ldd	r22, Y+7	; 0x07
    206a:	78 85       	ldd	r23, Y+8	; 0x08
    206c:	89 85       	ldd	r24, Y+9	; 0x09
    206e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2070:	20 e0       	ldi	r18, 0x00	; 0
    2072:	30 e0       	ldi	r19, 0x00	; 0
    2074:	40 e8       	ldi	r20, 0x80	; 128
    2076:	5f e3       	ldi	r21, 0x3F	; 63
    2078:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    207c:	88 23       	and	r24, r24
    207e:	2c f4       	brge	.+10     	; 0x208a <LCD_voidDisplay+0x184>
		__ticks = 1;
    2080:	81 e0       	ldi	r24, 0x01	; 1
    2082:	90 e0       	ldi	r25, 0x00	; 0
    2084:	9e 83       	std	Y+6, r25	; 0x06
    2086:	8d 83       	std	Y+5, r24	; 0x05
    2088:	3f c0       	rjmp	.+126    	; 0x2108 <LCD_voidDisplay+0x202>
	else if (__tmp > 65535)
    208a:	6f 81       	ldd	r22, Y+7	; 0x07
    208c:	78 85       	ldd	r23, Y+8	; 0x08
    208e:	89 85       	ldd	r24, Y+9	; 0x09
    2090:	9a 85       	ldd	r25, Y+10	; 0x0a
    2092:	20 e0       	ldi	r18, 0x00	; 0
    2094:	3f ef       	ldi	r19, 0xFF	; 255
    2096:	4f e7       	ldi	r20, 0x7F	; 127
    2098:	57 e4       	ldi	r21, 0x47	; 71
    209a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    209e:	18 16       	cp	r1, r24
    20a0:	4c f5       	brge	.+82     	; 0x20f4 <LCD_voidDisplay+0x1ee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    20a2:	6b 85       	ldd	r22, Y+11	; 0x0b
    20a4:	7c 85       	ldd	r23, Y+12	; 0x0c
    20a6:	8d 85       	ldd	r24, Y+13	; 0x0d
    20a8:	9e 85       	ldd	r25, Y+14	; 0x0e
    20aa:	20 e0       	ldi	r18, 0x00	; 0
    20ac:	30 e0       	ldi	r19, 0x00	; 0
    20ae:	40 e2       	ldi	r20, 0x20	; 32
    20b0:	51 e4       	ldi	r21, 0x41	; 65
    20b2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    20b6:	dc 01       	movw	r26, r24
    20b8:	cb 01       	movw	r24, r22
    20ba:	bc 01       	movw	r22, r24
    20bc:	cd 01       	movw	r24, r26
    20be:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    20c2:	dc 01       	movw	r26, r24
    20c4:	cb 01       	movw	r24, r22
    20c6:	9e 83       	std	Y+6, r25	; 0x06
    20c8:	8d 83       	std	Y+5, r24	; 0x05
    20ca:	0f c0       	rjmp	.+30     	; 0x20ea <LCD_voidDisplay+0x1e4>
    20cc:	88 ec       	ldi	r24, 0xC8	; 200
    20ce:	90 e0       	ldi	r25, 0x00	; 0
    20d0:	9c 83       	std	Y+4, r25	; 0x04
    20d2:	8b 83       	std	Y+3, r24	; 0x03
    20d4:	8b 81       	ldd	r24, Y+3	; 0x03
    20d6:	9c 81       	ldd	r25, Y+4	; 0x04
    20d8:	01 97       	sbiw	r24, 0x01	; 1
    20da:	f1 f7       	brne	.-4      	; 0x20d8 <LCD_voidDisplay+0x1d2>
    20dc:	9c 83       	std	Y+4, r25	; 0x04
    20de:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    20e0:	8d 81       	ldd	r24, Y+5	; 0x05
    20e2:	9e 81       	ldd	r25, Y+6	; 0x06
    20e4:	01 97       	sbiw	r24, 0x01	; 1
    20e6:	9e 83       	std	Y+6, r25	; 0x06
    20e8:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    20ea:	8d 81       	ldd	r24, Y+5	; 0x05
    20ec:	9e 81       	ldd	r25, Y+6	; 0x06
    20ee:	00 97       	sbiw	r24, 0x00	; 0
    20f0:	69 f7       	brne	.-38     	; 0x20cc <LCD_voidDisplay+0x1c6>
    20f2:	14 c0       	rjmp	.+40     	; 0x211c <LCD_voidDisplay+0x216>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    20f4:	6f 81       	ldd	r22, Y+7	; 0x07
    20f6:	78 85       	ldd	r23, Y+8	; 0x08
    20f8:	89 85       	ldd	r24, Y+9	; 0x09
    20fa:	9a 85       	ldd	r25, Y+10	; 0x0a
    20fc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2100:	dc 01       	movw	r26, r24
    2102:	cb 01       	movw	r24, r22
    2104:	9e 83       	std	Y+6, r25	; 0x06
    2106:	8d 83       	std	Y+5, r24	; 0x05
    2108:	8d 81       	ldd	r24, Y+5	; 0x05
    210a:	9e 81       	ldd	r25, Y+6	; 0x06
    210c:	9a 83       	std	Y+2, r25	; 0x02
    210e:	89 83       	std	Y+1, r24	; 0x01
    2110:	89 81       	ldd	r24, Y+1	; 0x01
    2112:	9a 81       	ldd	r25, Y+2	; 0x02
    2114:	01 97       	sbiw	r24, 0x01	; 1
    2116:	f1 f7       	brne	.-4      	; 0x2114 <LCD_voidDisplay+0x20e>
    2118:	9a 83       	std	Y+2, r25	; 0x02
    211a:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(5);

}/* end of function LCD_voidDisplay */
    211c:	6d 96       	adiw	r28, 0x1d	; 29
    211e:	0f b6       	in	r0, 0x3f	; 63
    2120:	f8 94       	cli
    2122:	de bf       	out	0x3e, r29	; 62
    2124:	0f be       	out	0x3f, r0	; 63
    2126:	cd bf       	out	0x3d, r28	; 61
    2128:	cf 91       	pop	r28
    212a:	df 91       	pop	r29
    212c:	08 95       	ret

0000212e <LCD_voidString>:

extern void LCD_voidString(U8* const stringToPrint)
{
    212e:	df 93       	push	r29
    2130:	cf 93       	push	r28
    2132:	cd b7       	in	r28, 0x3d	; 61
    2134:	de b7       	in	r29, 0x3e	; 62
    2136:	61 97       	sbiw	r28, 0x11	; 17
    2138:	0f b6       	in	r0, 0x3f	; 63
    213a:	f8 94       	cli
    213c:	de bf       	out	0x3e, r29	; 62
    213e:	0f be       	out	0x3f, r0	; 63
    2140:	cd bf       	out	0x3d, r28	; 61
    2142:	99 8b       	std	Y+17, r25	; 0x11
    2144:	88 8b       	std	Y+16, r24	; 0x10
	U8 index =0;
    2146:	1f 86       	std	Y+15, r1	; 0x0f
    2148:	80 c0       	rjmp	.+256    	; 0x224a <LCD_voidString+0x11c>

	while(stringToPrint[index] != '\0')
	{
		/* write char on LCD */
		LCD_voidDisplay(stringToPrint[index]);
    214a:	8f 85       	ldd	r24, Y+15	; 0x0f
    214c:	28 2f       	mov	r18, r24
    214e:	30 e0       	ldi	r19, 0x00	; 0
    2150:	88 89       	ldd	r24, Y+16	; 0x10
    2152:	99 89       	ldd	r25, Y+17	; 0x11
    2154:	fc 01       	movw	r30, r24
    2156:	e2 0f       	add	r30, r18
    2158:	f3 1f       	adc	r31, r19
    215a:	80 81       	ld	r24, Z
    215c:	0e 94 83 0f 	call	0x1f06	; 0x1f06 <LCD_voidDisplay>

		/* next char */
		index++;
    2160:	8f 85       	ldd	r24, Y+15	; 0x0f
    2162:	8f 5f       	subi	r24, 0xFF	; 255
    2164:	8f 87       	std	Y+15, r24	; 0x0f
    2166:	80 e0       	ldi	r24, 0x00	; 0
    2168:	90 e0       	ldi	r25, 0x00	; 0
    216a:	a0 e0       	ldi	r26, 0x00	; 0
    216c:	b0 e4       	ldi	r27, 0x40	; 64
    216e:	8b 87       	std	Y+11, r24	; 0x0b
    2170:	9c 87       	std	Y+12, r25	; 0x0c
    2172:	ad 87       	std	Y+13, r26	; 0x0d
    2174:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2176:	6b 85       	ldd	r22, Y+11	; 0x0b
    2178:	7c 85       	ldd	r23, Y+12	; 0x0c
    217a:	8d 85       	ldd	r24, Y+13	; 0x0d
    217c:	9e 85       	ldd	r25, Y+14	; 0x0e
    217e:	20 e0       	ldi	r18, 0x00	; 0
    2180:	30 e0       	ldi	r19, 0x00	; 0
    2182:	4a ef       	ldi	r20, 0xFA	; 250
    2184:	54 e4       	ldi	r21, 0x44	; 68
    2186:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    218a:	dc 01       	movw	r26, r24
    218c:	cb 01       	movw	r24, r22
    218e:	8f 83       	std	Y+7, r24	; 0x07
    2190:	98 87       	std	Y+8, r25	; 0x08
    2192:	a9 87       	std	Y+9, r26	; 0x09
    2194:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2196:	6f 81       	ldd	r22, Y+7	; 0x07
    2198:	78 85       	ldd	r23, Y+8	; 0x08
    219a:	89 85       	ldd	r24, Y+9	; 0x09
    219c:	9a 85       	ldd	r25, Y+10	; 0x0a
    219e:	20 e0       	ldi	r18, 0x00	; 0
    21a0:	30 e0       	ldi	r19, 0x00	; 0
    21a2:	40 e8       	ldi	r20, 0x80	; 128
    21a4:	5f e3       	ldi	r21, 0x3F	; 63
    21a6:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    21aa:	88 23       	and	r24, r24
    21ac:	2c f4       	brge	.+10     	; 0x21b8 <LCD_voidString+0x8a>
		__ticks = 1;
    21ae:	81 e0       	ldi	r24, 0x01	; 1
    21b0:	90 e0       	ldi	r25, 0x00	; 0
    21b2:	9e 83       	std	Y+6, r25	; 0x06
    21b4:	8d 83       	std	Y+5, r24	; 0x05
    21b6:	3f c0       	rjmp	.+126    	; 0x2236 <LCD_voidString+0x108>
	else if (__tmp > 65535)
    21b8:	6f 81       	ldd	r22, Y+7	; 0x07
    21ba:	78 85       	ldd	r23, Y+8	; 0x08
    21bc:	89 85       	ldd	r24, Y+9	; 0x09
    21be:	9a 85       	ldd	r25, Y+10	; 0x0a
    21c0:	20 e0       	ldi	r18, 0x00	; 0
    21c2:	3f ef       	ldi	r19, 0xFF	; 255
    21c4:	4f e7       	ldi	r20, 0x7F	; 127
    21c6:	57 e4       	ldi	r21, 0x47	; 71
    21c8:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    21cc:	18 16       	cp	r1, r24
    21ce:	4c f5       	brge	.+82     	; 0x2222 <LCD_voidString+0xf4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    21d0:	6b 85       	ldd	r22, Y+11	; 0x0b
    21d2:	7c 85       	ldd	r23, Y+12	; 0x0c
    21d4:	8d 85       	ldd	r24, Y+13	; 0x0d
    21d6:	9e 85       	ldd	r25, Y+14	; 0x0e
    21d8:	20 e0       	ldi	r18, 0x00	; 0
    21da:	30 e0       	ldi	r19, 0x00	; 0
    21dc:	40 e2       	ldi	r20, 0x20	; 32
    21de:	51 e4       	ldi	r21, 0x41	; 65
    21e0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    21e4:	dc 01       	movw	r26, r24
    21e6:	cb 01       	movw	r24, r22
    21e8:	bc 01       	movw	r22, r24
    21ea:	cd 01       	movw	r24, r26
    21ec:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    21f0:	dc 01       	movw	r26, r24
    21f2:	cb 01       	movw	r24, r22
    21f4:	9e 83       	std	Y+6, r25	; 0x06
    21f6:	8d 83       	std	Y+5, r24	; 0x05
    21f8:	0f c0       	rjmp	.+30     	; 0x2218 <LCD_voidString+0xea>
    21fa:	88 ec       	ldi	r24, 0xC8	; 200
    21fc:	90 e0       	ldi	r25, 0x00	; 0
    21fe:	9c 83       	std	Y+4, r25	; 0x04
    2200:	8b 83       	std	Y+3, r24	; 0x03
    2202:	8b 81       	ldd	r24, Y+3	; 0x03
    2204:	9c 81       	ldd	r25, Y+4	; 0x04
    2206:	01 97       	sbiw	r24, 0x01	; 1
    2208:	f1 f7       	brne	.-4      	; 0x2206 <LCD_voidString+0xd8>
    220a:	9c 83       	std	Y+4, r25	; 0x04
    220c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    220e:	8d 81       	ldd	r24, Y+5	; 0x05
    2210:	9e 81       	ldd	r25, Y+6	; 0x06
    2212:	01 97       	sbiw	r24, 0x01	; 1
    2214:	9e 83       	std	Y+6, r25	; 0x06
    2216:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2218:	8d 81       	ldd	r24, Y+5	; 0x05
    221a:	9e 81       	ldd	r25, Y+6	; 0x06
    221c:	00 97       	sbiw	r24, 0x00	; 0
    221e:	69 f7       	brne	.-38     	; 0x21fa <LCD_voidString+0xcc>
    2220:	14 c0       	rjmp	.+40     	; 0x224a <LCD_voidString+0x11c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2222:	6f 81       	ldd	r22, Y+7	; 0x07
    2224:	78 85       	ldd	r23, Y+8	; 0x08
    2226:	89 85       	ldd	r24, Y+9	; 0x09
    2228:	9a 85       	ldd	r25, Y+10	; 0x0a
    222a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    222e:	dc 01       	movw	r26, r24
    2230:	cb 01       	movw	r24, r22
    2232:	9e 83       	std	Y+6, r25	; 0x06
    2234:	8d 83       	std	Y+5, r24	; 0x05
    2236:	8d 81       	ldd	r24, Y+5	; 0x05
    2238:	9e 81       	ldd	r25, Y+6	; 0x06
    223a:	9a 83       	std	Y+2, r25	; 0x02
    223c:	89 83       	std	Y+1, r24	; 0x01
    223e:	89 81       	ldd	r24, Y+1	; 0x01
    2240:	9a 81       	ldd	r25, Y+2	; 0x02
    2242:	01 97       	sbiw	r24, 0x01	; 1
    2244:	f1 f7       	brne	.-4      	; 0x2242 <LCD_voidString+0x114>
    2246:	9a 83       	std	Y+2, r25	; 0x02
    2248:	89 83       	std	Y+1, r24	; 0x01

extern void LCD_voidString(U8* const stringToPrint)
{
	U8 index =0;

	while(stringToPrint[index] != '\0')
    224a:	8f 85       	ldd	r24, Y+15	; 0x0f
    224c:	28 2f       	mov	r18, r24
    224e:	30 e0       	ldi	r19, 0x00	; 0
    2250:	88 89       	ldd	r24, Y+16	; 0x10
    2252:	99 89       	ldd	r25, Y+17	; 0x11
    2254:	fc 01       	movw	r30, r24
    2256:	e2 0f       	add	r30, r18
    2258:	f3 1f       	adc	r31, r19
    225a:	80 81       	ld	r24, Z
    225c:	88 23       	and	r24, r24
    225e:	09 f0       	breq	.+2      	; 0x2262 <LCD_voidString+0x134>
    2260:	74 cf       	rjmp	.-280    	; 0x214a <LCD_voidString+0x1c>
		/* next char */
		index++;

		_delay_ms(2);
	}	/* end While */
}/* end of function LCD_voidDisplay */
    2262:	61 96       	adiw	r28, 0x11	; 17
    2264:	0f b6       	in	r0, 0x3f	; 63
    2266:	f8 94       	cli
    2268:	de bf       	out	0x3e, r29	; 62
    226a:	0f be       	out	0x3f, r0	; 63
    226c:	cd bf       	out	0x3d, r28	; 61
    226e:	cf 91       	pop	r28
    2270:	df 91       	pop	r29
    2272:	08 95       	ret

00002274 <LCD_voidInteger>:

extern void LCD_voidInteger(S32 const IntegerToPrint)
{
    2274:	df 93       	push	r29
    2276:	cf 93       	push	r28
    2278:	cd b7       	in	r28, 0x3d	; 61
    227a:	de b7       	in	r29, 0x3e	; 62
    227c:	65 97       	sbiw	r28, 0x15	; 21
    227e:	0f b6       	in	r0, 0x3f	; 63
    2280:	f8 94       	cli
    2282:	de bf       	out	0x3e, r29	; 62
    2284:	0f be       	out	0x3f, r0	; 63
    2286:	cd bf       	out	0x3d, r28	; 61
    2288:	6a 8b       	std	Y+18, r22	; 0x12
    228a:	7b 8b       	std	Y+19, r23	; 0x13
    228c:	8c 8b       	std	Y+20, r24	; 0x14
    228e:	9d 8b       	std	Y+21, r25	; 0x15
	U8 intToStr[3];
	itoa(IntegerToPrint, intToStr, 10); //convert decimal integer to string
    2290:	8a 89       	ldd	r24, Y+18	; 0x12
    2292:	9b 89       	ldd	r25, Y+19	; 0x13
    2294:	9e 01       	movw	r18, r28
    2296:	21 5f       	subi	r18, 0xF1	; 241
    2298:	3f 4f       	sbci	r19, 0xFF	; 255
    229a:	b9 01       	movw	r22, r18
    229c:	4a e0       	ldi	r20, 0x0A	; 10
    229e:	50 e0       	ldi	r21, 0x00	; 0
    22a0:	0e 94 49 28 	call	0x5092	; 0x5092 <itoa>
	LCD_voidString(intToStr);
    22a4:	ce 01       	movw	r24, r28
    22a6:	0f 96       	adiw	r24, 0x0f	; 15
    22a8:	0e 94 97 10 	call	0x212e	; 0x212e <LCD_voidString>
    22ac:	80 e0       	ldi	r24, 0x00	; 0
    22ae:	90 e0       	ldi	r25, 0x00	; 0
    22b0:	a0 e0       	ldi	r26, 0x00	; 0
    22b2:	b0 e4       	ldi	r27, 0x40	; 64
    22b4:	8b 87       	std	Y+11, r24	; 0x0b
    22b6:	9c 87       	std	Y+12, r25	; 0x0c
    22b8:	ad 87       	std	Y+13, r26	; 0x0d
    22ba:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    22bc:	6b 85       	ldd	r22, Y+11	; 0x0b
    22be:	7c 85       	ldd	r23, Y+12	; 0x0c
    22c0:	8d 85       	ldd	r24, Y+13	; 0x0d
    22c2:	9e 85       	ldd	r25, Y+14	; 0x0e
    22c4:	20 e0       	ldi	r18, 0x00	; 0
    22c6:	30 e0       	ldi	r19, 0x00	; 0
    22c8:	4a ef       	ldi	r20, 0xFA	; 250
    22ca:	54 e4       	ldi	r21, 0x44	; 68
    22cc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    22d0:	dc 01       	movw	r26, r24
    22d2:	cb 01       	movw	r24, r22
    22d4:	8f 83       	std	Y+7, r24	; 0x07
    22d6:	98 87       	std	Y+8, r25	; 0x08
    22d8:	a9 87       	std	Y+9, r26	; 0x09
    22da:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    22dc:	6f 81       	ldd	r22, Y+7	; 0x07
    22de:	78 85       	ldd	r23, Y+8	; 0x08
    22e0:	89 85       	ldd	r24, Y+9	; 0x09
    22e2:	9a 85       	ldd	r25, Y+10	; 0x0a
    22e4:	20 e0       	ldi	r18, 0x00	; 0
    22e6:	30 e0       	ldi	r19, 0x00	; 0
    22e8:	40 e8       	ldi	r20, 0x80	; 128
    22ea:	5f e3       	ldi	r21, 0x3F	; 63
    22ec:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    22f0:	88 23       	and	r24, r24
    22f2:	2c f4       	brge	.+10     	; 0x22fe <LCD_voidInteger+0x8a>
		__ticks = 1;
    22f4:	81 e0       	ldi	r24, 0x01	; 1
    22f6:	90 e0       	ldi	r25, 0x00	; 0
    22f8:	9e 83       	std	Y+6, r25	; 0x06
    22fa:	8d 83       	std	Y+5, r24	; 0x05
    22fc:	3f c0       	rjmp	.+126    	; 0x237c <LCD_voidInteger+0x108>
	else if (__tmp > 65535)
    22fe:	6f 81       	ldd	r22, Y+7	; 0x07
    2300:	78 85       	ldd	r23, Y+8	; 0x08
    2302:	89 85       	ldd	r24, Y+9	; 0x09
    2304:	9a 85       	ldd	r25, Y+10	; 0x0a
    2306:	20 e0       	ldi	r18, 0x00	; 0
    2308:	3f ef       	ldi	r19, 0xFF	; 255
    230a:	4f e7       	ldi	r20, 0x7F	; 127
    230c:	57 e4       	ldi	r21, 0x47	; 71
    230e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2312:	18 16       	cp	r1, r24
    2314:	4c f5       	brge	.+82     	; 0x2368 <LCD_voidInteger+0xf4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2316:	6b 85       	ldd	r22, Y+11	; 0x0b
    2318:	7c 85       	ldd	r23, Y+12	; 0x0c
    231a:	8d 85       	ldd	r24, Y+13	; 0x0d
    231c:	9e 85       	ldd	r25, Y+14	; 0x0e
    231e:	20 e0       	ldi	r18, 0x00	; 0
    2320:	30 e0       	ldi	r19, 0x00	; 0
    2322:	40 e2       	ldi	r20, 0x20	; 32
    2324:	51 e4       	ldi	r21, 0x41	; 65
    2326:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    232a:	dc 01       	movw	r26, r24
    232c:	cb 01       	movw	r24, r22
    232e:	bc 01       	movw	r22, r24
    2330:	cd 01       	movw	r24, r26
    2332:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2336:	dc 01       	movw	r26, r24
    2338:	cb 01       	movw	r24, r22
    233a:	9e 83       	std	Y+6, r25	; 0x06
    233c:	8d 83       	std	Y+5, r24	; 0x05
    233e:	0f c0       	rjmp	.+30     	; 0x235e <LCD_voidInteger+0xea>
    2340:	88 ec       	ldi	r24, 0xC8	; 200
    2342:	90 e0       	ldi	r25, 0x00	; 0
    2344:	9c 83       	std	Y+4, r25	; 0x04
    2346:	8b 83       	std	Y+3, r24	; 0x03
    2348:	8b 81       	ldd	r24, Y+3	; 0x03
    234a:	9c 81       	ldd	r25, Y+4	; 0x04
    234c:	01 97       	sbiw	r24, 0x01	; 1
    234e:	f1 f7       	brne	.-4      	; 0x234c <LCD_voidInteger+0xd8>
    2350:	9c 83       	std	Y+4, r25	; 0x04
    2352:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2354:	8d 81       	ldd	r24, Y+5	; 0x05
    2356:	9e 81       	ldd	r25, Y+6	; 0x06
    2358:	01 97       	sbiw	r24, 0x01	; 1
    235a:	9e 83       	std	Y+6, r25	; 0x06
    235c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    235e:	8d 81       	ldd	r24, Y+5	; 0x05
    2360:	9e 81       	ldd	r25, Y+6	; 0x06
    2362:	00 97       	sbiw	r24, 0x00	; 0
    2364:	69 f7       	brne	.-38     	; 0x2340 <LCD_voidInteger+0xcc>
    2366:	14 c0       	rjmp	.+40     	; 0x2390 <LCD_voidInteger+0x11c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2368:	6f 81       	ldd	r22, Y+7	; 0x07
    236a:	78 85       	ldd	r23, Y+8	; 0x08
    236c:	89 85       	ldd	r24, Y+9	; 0x09
    236e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2370:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2374:	dc 01       	movw	r26, r24
    2376:	cb 01       	movw	r24, r22
    2378:	9e 83       	std	Y+6, r25	; 0x06
    237a:	8d 83       	std	Y+5, r24	; 0x05
    237c:	8d 81       	ldd	r24, Y+5	; 0x05
    237e:	9e 81       	ldd	r25, Y+6	; 0x06
    2380:	9a 83       	std	Y+2, r25	; 0x02
    2382:	89 83       	std	Y+1, r24	; 0x01
    2384:	89 81       	ldd	r24, Y+1	; 0x01
    2386:	9a 81       	ldd	r25, Y+2	; 0x02
    2388:	01 97       	sbiw	r24, 0x01	; 1
    238a:	f1 f7       	brne	.-4      	; 0x2388 <LCD_voidInteger+0x114>
    238c:	9a 83       	std	Y+2, r25	; 0x02
    238e:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);

}/* end of function LCD_voidDisplay */
    2390:	65 96       	adiw	r28, 0x15	; 21
    2392:	0f b6       	in	r0, 0x3f	; 63
    2394:	f8 94       	cli
    2396:	de bf       	out	0x3e, r29	; 62
    2398:	0f be       	out	0x3f, r0	; 63
    239a:	cd bf       	out	0x3d, r28	; 61
    239c:	cf 91       	pop	r28
    239e:	df 91       	pop	r29
    23a0:	08 95       	ret

000023a2 <LCD_voidClear>:

extern void LCD_voidClear()
{
    23a2:	df 93       	push	r29
    23a4:	cf 93       	push	r28
    23a6:	cd b7       	in	r28, 0x3d	; 61
    23a8:	de b7       	in	r29, 0x3e	; 62
    23aa:	2e 97       	sbiw	r28, 0x0e	; 14
    23ac:	0f b6       	in	r0, 0x3f	; 63
    23ae:	f8 94       	cli
    23b0:	de bf       	out	0x3e, r29	; 62
    23b2:	0f be       	out	0x3f, r0	; 63
    23b4:	cd bf       	out	0x3d, r28	; 61
	/* Display Clear */
	LCD_voidWriteCommand(0b00000001);
    23b6:	81 e0       	ldi	r24, 0x01	; 1
    23b8:	0e 94 e1 0e 	call	0x1dc2	; 0x1dc2 <LCD_voidWriteCommand>
    23bc:	80 e0       	ldi	r24, 0x00	; 0
    23be:	90 e0       	ldi	r25, 0x00	; 0
    23c0:	a0 e2       	ldi	r26, 0x20	; 32
    23c2:	b1 e4       	ldi	r27, 0x41	; 65
    23c4:	8b 87       	std	Y+11, r24	; 0x0b
    23c6:	9c 87       	std	Y+12, r25	; 0x0c
    23c8:	ad 87       	std	Y+13, r26	; 0x0d
    23ca:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    23cc:	6b 85       	ldd	r22, Y+11	; 0x0b
    23ce:	7c 85       	ldd	r23, Y+12	; 0x0c
    23d0:	8d 85       	ldd	r24, Y+13	; 0x0d
    23d2:	9e 85       	ldd	r25, Y+14	; 0x0e
    23d4:	20 e0       	ldi	r18, 0x00	; 0
    23d6:	30 e0       	ldi	r19, 0x00	; 0
    23d8:	4a ef       	ldi	r20, 0xFA	; 250
    23da:	54 e4       	ldi	r21, 0x44	; 68
    23dc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    23e0:	dc 01       	movw	r26, r24
    23e2:	cb 01       	movw	r24, r22
    23e4:	8f 83       	std	Y+7, r24	; 0x07
    23e6:	98 87       	std	Y+8, r25	; 0x08
    23e8:	a9 87       	std	Y+9, r26	; 0x09
    23ea:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    23ec:	6f 81       	ldd	r22, Y+7	; 0x07
    23ee:	78 85       	ldd	r23, Y+8	; 0x08
    23f0:	89 85       	ldd	r24, Y+9	; 0x09
    23f2:	9a 85       	ldd	r25, Y+10	; 0x0a
    23f4:	20 e0       	ldi	r18, 0x00	; 0
    23f6:	30 e0       	ldi	r19, 0x00	; 0
    23f8:	40 e8       	ldi	r20, 0x80	; 128
    23fa:	5f e3       	ldi	r21, 0x3F	; 63
    23fc:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2400:	88 23       	and	r24, r24
    2402:	2c f4       	brge	.+10     	; 0x240e <LCD_voidClear+0x6c>
		__ticks = 1;
    2404:	81 e0       	ldi	r24, 0x01	; 1
    2406:	90 e0       	ldi	r25, 0x00	; 0
    2408:	9e 83       	std	Y+6, r25	; 0x06
    240a:	8d 83       	std	Y+5, r24	; 0x05
    240c:	3f c0       	rjmp	.+126    	; 0x248c <LCD_voidClear+0xea>
	else if (__tmp > 65535)
    240e:	6f 81       	ldd	r22, Y+7	; 0x07
    2410:	78 85       	ldd	r23, Y+8	; 0x08
    2412:	89 85       	ldd	r24, Y+9	; 0x09
    2414:	9a 85       	ldd	r25, Y+10	; 0x0a
    2416:	20 e0       	ldi	r18, 0x00	; 0
    2418:	3f ef       	ldi	r19, 0xFF	; 255
    241a:	4f e7       	ldi	r20, 0x7F	; 127
    241c:	57 e4       	ldi	r21, 0x47	; 71
    241e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2422:	18 16       	cp	r1, r24
    2424:	4c f5       	brge	.+82     	; 0x2478 <LCD_voidClear+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2426:	6b 85       	ldd	r22, Y+11	; 0x0b
    2428:	7c 85       	ldd	r23, Y+12	; 0x0c
    242a:	8d 85       	ldd	r24, Y+13	; 0x0d
    242c:	9e 85       	ldd	r25, Y+14	; 0x0e
    242e:	20 e0       	ldi	r18, 0x00	; 0
    2430:	30 e0       	ldi	r19, 0x00	; 0
    2432:	40 e2       	ldi	r20, 0x20	; 32
    2434:	51 e4       	ldi	r21, 0x41	; 65
    2436:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    243a:	dc 01       	movw	r26, r24
    243c:	cb 01       	movw	r24, r22
    243e:	bc 01       	movw	r22, r24
    2440:	cd 01       	movw	r24, r26
    2442:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2446:	dc 01       	movw	r26, r24
    2448:	cb 01       	movw	r24, r22
    244a:	9e 83       	std	Y+6, r25	; 0x06
    244c:	8d 83       	std	Y+5, r24	; 0x05
    244e:	0f c0       	rjmp	.+30     	; 0x246e <LCD_voidClear+0xcc>
    2450:	88 ec       	ldi	r24, 0xC8	; 200
    2452:	90 e0       	ldi	r25, 0x00	; 0
    2454:	9c 83       	std	Y+4, r25	; 0x04
    2456:	8b 83       	std	Y+3, r24	; 0x03
    2458:	8b 81       	ldd	r24, Y+3	; 0x03
    245a:	9c 81       	ldd	r25, Y+4	; 0x04
    245c:	01 97       	sbiw	r24, 0x01	; 1
    245e:	f1 f7       	brne	.-4      	; 0x245c <LCD_voidClear+0xba>
    2460:	9c 83       	std	Y+4, r25	; 0x04
    2462:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2464:	8d 81       	ldd	r24, Y+5	; 0x05
    2466:	9e 81       	ldd	r25, Y+6	; 0x06
    2468:	01 97       	sbiw	r24, 0x01	; 1
    246a:	9e 83       	std	Y+6, r25	; 0x06
    246c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    246e:	8d 81       	ldd	r24, Y+5	; 0x05
    2470:	9e 81       	ldd	r25, Y+6	; 0x06
    2472:	00 97       	sbiw	r24, 0x00	; 0
    2474:	69 f7       	brne	.-38     	; 0x2450 <LCD_voidClear+0xae>
    2476:	14 c0       	rjmp	.+40     	; 0x24a0 <LCD_voidClear+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2478:	6f 81       	ldd	r22, Y+7	; 0x07
    247a:	78 85       	ldd	r23, Y+8	; 0x08
    247c:	89 85       	ldd	r24, Y+9	; 0x09
    247e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2480:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2484:	dc 01       	movw	r26, r24
    2486:	cb 01       	movw	r24, r22
    2488:	9e 83       	std	Y+6, r25	; 0x06
    248a:	8d 83       	std	Y+5, r24	; 0x05
    248c:	8d 81       	ldd	r24, Y+5	; 0x05
    248e:	9e 81       	ldd	r25, Y+6	; 0x06
    2490:	9a 83       	std	Y+2, r25	; 0x02
    2492:	89 83       	std	Y+1, r24	; 0x01
    2494:	89 81       	ldd	r24, Y+1	; 0x01
    2496:	9a 81       	ldd	r25, Y+2	; 0x02
    2498:	01 97       	sbiw	r24, 0x01	; 1
    249a:	f1 f7       	brne	.-4      	; 0x2498 <LCD_voidClear+0xf6>
    249c:	9a 83       	std	Y+2, r25	; 0x02
    249e:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(10);
}/* end of function LCD_voidClear */
    24a0:	2e 96       	adiw	r28, 0x0e	; 14
    24a2:	0f b6       	in	r0, 0x3f	; 63
    24a4:	f8 94       	cli
    24a6:	de bf       	out	0x3e, r29	; 62
    24a8:	0f be       	out	0x3f, r0	; 63
    24aa:	cd bf       	out	0x3d, r28	; 61
    24ac:	cf 91       	pop	r28
    24ae:	df 91       	pop	r29
    24b0:	08 95       	ret

000024b2 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    24b2:	df 93       	push	r29
    24b4:	cf 93       	push	r28
    24b6:	cd b7       	in	r28, 0x3d	; 61
    24b8:	de b7       	in	r29, 0x3e	; 62
    24ba:	27 97       	sbiw	r28, 0x07	; 7
    24bc:	0f b6       	in	r0, 0x3f	; 63
    24be:	f8 94       	cli
    24c0:	de bf       	out	0x3e, r29	; 62
    24c2:	0f be       	out	0x3f, r0	; 63
    24c4:	cd bf       	out	0x3d, r28	; 61
    24c6:	9d 83       	std	Y+5, r25	; 0x05
    24c8:	8c 83       	std	Y+4, r24	; 0x04
    24ca:	6e 83       	std	Y+6, r22	; 0x06
    24cc:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    24ce:	8a e1       	ldi	r24, 0x1A	; 26
    24d0:	90 e0       	ldi	r25, 0x00	; 0
    24d2:	0e 94 31 15 	call	0x2a62	; 0x2a62 <pvPortMalloc>
    24d6:	9a 83       	std	Y+2, r25	; 0x02
    24d8:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    24da:	89 81       	ldd	r24, Y+1	; 0x01
    24dc:	9a 81       	ldd	r25, Y+2	; 0x02
    24de:	00 97       	sbiw	r24, 0x00	; 0
    24e0:	09 f4       	brne	.+2      	; 0x24e4 <xCoRoutineCreate+0x32>
    24e2:	6f c0       	rjmp	.+222    	; 0x25c2 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    24e4:	80 91 b2 00 	lds	r24, 0x00B2
    24e8:	90 91 b3 00 	lds	r25, 0x00B3
    24ec:	00 97       	sbiw	r24, 0x00	; 0
    24ee:	41 f4       	brne	.+16     	; 0x2500 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    24f0:	89 81       	ldd	r24, Y+1	; 0x01
    24f2:	9a 81       	ldd	r25, Y+2	; 0x02
    24f4:	90 93 b3 00 	sts	0x00B3, r25
    24f8:	80 93 b2 00 	sts	0x00B2, r24
			prvInitialiseCoRoutineLists();
    24fc:	0e 94 c0 14 	call	0x2980	; 0x2980 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    2500:	8e 81       	ldd	r24, Y+6	; 0x06
    2502:	82 30       	cpi	r24, 0x02	; 2
    2504:	10 f0       	brcs	.+4      	; 0x250a <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    2506:	81 e0       	ldi	r24, 0x01	; 1
    2508:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    250a:	e9 81       	ldd	r30, Y+1	; 0x01
    250c:	fa 81       	ldd	r31, Y+2	; 0x02
    250e:	11 8e       	std	Z+25, r1	; 0x19
    2510:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    2512:	e9 81       	ldd	r30, Y+1	; 0x01
    2514:	fa 81       	ldd	r31, Y+2	; 0x02
    2516:	8e 81       	ldd	r24, Y+6	; 0x06
    2518:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    251a:	e9 81       	ldd	r30, Y+1	; 0x01
    251c:	fa 81       	ldd	r31, Y+2	; 0x02
    251e:	8f 81       	ldd	r24, Y+7	; 0x07
    2520:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    2522:	e9 81       	ldd	r30, Y+1	; 0x01
    2524:	fa 81       	ldd	r31, Y+2	; 0x02
    2526:	8c 81       	ldd	r24, Y+4	; 0x04
    2528:	9d 81       	ldd	r25, Y+5	; 0x05
    252a:	91 83       	std	Z+1, r25	; 0x01
    252c:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    252e:	89 81       	ldd	r24, Y+1	; 0x01
    2530:	9a 81       	ldd	r25, Y+2	; 0x02
    2532:	02 96       	adiw	r24, 0x02	; 2
    2534:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2538:	89 81       	ldd	r24, Y+1	; 0x01
    253a:	9a 81       	ldd	r25, Y+2	; 0x02
    253c:	0c 96       	adiw	r24, 0x0c	; 12
    253e:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    2542:	e9 81       	ldd	r30, Y+1	; 0x01
    2544:	fa 81       	ldd	r31, Y+2	; 0x02
    2546:	89 81       	ldd	r24, Y+1	; 0x01
    2548:	9a 81       	ldd	r25, Y+2	; 0x02
    254a:	91 87       	std	Z+9, r25	; 0x09
    254c:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    254e:	e9 81       	ldd	r30, Y+1	; 0x01
    2550:	fa 81       	ldd	r31, Y+2	; 0x02
    2552:	89 81       	ldd	r24, Y+1	; 0x01
    2554:	9a 81       	ldd	r25, Y+2	; 0x02
    2556:	93 8b       	std	Z+19, r25	; 0x13
    2558:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    255a:	8e 81       	ldd	r24, Y+6	; 0x06
    255c:	28 2f       	mov	r18, r24
    255e:	30 e0       	ldi	r19, 0x00	; 0
    2560:	85 e0       	ldi	r24, 0x05	; 5
    2562:	90 e0       	ldi	r25, 0x00	; 0
    2564:	82 1b       	sub	r24, r18
    2566:	93 0b       	sbc	r25, r19
    2568:	e9 81       	ldd	r30, Y+1	; 0x01
    256a:	fa 81       	ldd	r31, Y+2	; 0x02
    256c:	95 87       	std	Z+13, r25	; 0x0d
    256e:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    2570:	e9 81       	ldd	r30, Y+1	; 0x01
    2572:	fa 81       	ldd	r31, Y+2	; 0x02
    2574:	96 89       	ldd	r25, Z+22	; 0x16
    2576:	80 91 b4 00 	lds	r24, 0x00B4
    257a:	89 17       	cp	r24, r25
    257c:	28 f4       	brcc	.+10     	; 0x2588 <xCoRoutineCreate+0xd6>
    257e:	e9 81       	ldd	r30, Y+1	; 0x01
    2580:	fa 81       	ldd	r31, Y+2	; 0x02
    2582:	86 89       	ldd	r24, Z+22	; 0x16
    2584:	80 93 b4 00 	sts	0x00B4, r24
    2588:	e9 81       	ldd	r30, Y+1	; 0x01
    258a:	fa 81       	ldd	r31, Y+2	; 0x02
    258c:	86 89       	ldd	r24, Z+22	; 0x16
    258e:	28 2f       	mov	r18, r24
    2590:	30 e0       	ldi	r19, 0x00	; 0
    2592:	c9 01       	movw	r24, r18
    2594:	88 0f       	add	r24, r24
    2596:	99 1f       	adc	r25, r25
    2598:	88 0f       	add	r24, r24
    259a:	99 1f       	adc	r25, r25
    259c:	88 0f       	add	r24, r24
    259e:	99 1f       	adc	r25, r25
    25a0:	82 0f       	add	r24, r18
    25a2:	93 1f       	adc	r25, r19
    25a4:	ac 01       	movw	r20, r24
    25a6:	45 54       	subi	r20, 0x45	; 69
    25a8:	5f 4f       	sbci	r21, 0xFF	; 255
    25aa:	89 81       	ldd	r24, Y+1	; 0x01
    25ac:	9a 81       	ldd	r25, Y+2	; 0x02
    25ae:	9c 01       	movw	r18, r24
    25b0:	2e 5f       	subi	r18, 0xFE	; 254
    25b2:	3f 4f       	sbci	r19, 0xFF	; 255
    25b4:	ca 01       	movw	r24, r20
    25b6:	b9 01       	movw	r22, r18
    25b8:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <vListInsertEnd>

		xReturn = pdPASS;
    25bc:	81 e0       	ldi	r24, 0x01	; 1
    25be:	8b 83       	std	Y+3, r24	; 0x03
    25c0:	02 c0       	rjmp	.+4      	; 0x25c6 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    25c2:	8f ef       	ldi	r24, 0xFF	; 255
    25c4:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    25c6:	8b 81       	ldd	r24, Y+3	; 0x03
}
    25c8:	27 96       	adiw	r28, 0x07	; 7
    25ca:	0f b6       	in	r0, 0x3f	; 63
    25cc:	f8 94       	cli
    25ce:	de bf       	out	0x3e, r29	; 62
    25d0:	0f be       	out	0x3f, r0	; 63
    25d2:	cd bf       	out	0x3d, r28	; 61
    25d4:	cf 91       	pop	r28
    25d6:	df 91       	pop	r29
    25d8:	08 95       	ret

000025da <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    25da:	df 93       	push	r29
    25dc:	cf 93       	push	r28
    25de:	00 d0       	rcall	.+0      	; 0x25e0 <vCoRoutineAddToDelayedList+0x6>
    25e0:	00 d0       	rcall	.+0      	; 0x25e2 <vCoRoutineAddToDelayedList+0x8>
    25e2:	00 d0       	rcall	.+0      	; 0x25e4 <vCoRoutineAddToDelayedList+0xa>
    25e4:	cd b7       	in	r28, 0x3d	; 61
    25e6:	de b7       	in	r29, 0x3e	; 62
    25e8:	9c 83       	std	Y+4, r25	; 0x04
    25ea:	8b 83       	std	Y+3, r24	; 0x03
    25ec:	7e 83       	std	Y+6, r23	; 0x06
    25ee:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    25f0:	20 91 b5 00 	lds	r18, 0x00B5
    25f4:	30 91 b6 00 	lds	r19, 0x00B6
    25f8:	8b 81       	ldd	r24, Y+3	; 0x03
    25fa:	9c 81       	ldd	r25, Y+4	; 0x04
    25fc:	82 0f       	add	r24, r18
    25fe:	93 1f       	adc	r25, r19
    2600:	9a 83       	std	Y+2, r25	; 0x02
    2602:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2604:	80 91 b2 00 	lds	r24, 0x00B2
    2608:	90 91 b3 00 	lds	r25, 0x00B3
    260c:	02 96       	adiw	r24, 0x02	; 2
    260e:	0e 94 56 16 	call	0x2cac	; 0x2cac <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    2612:	e0 91 b2 00 	lds	r30, 0x00B2
    2616:	f0 91 b3 00 	lds	r31, 0x00B3
    261a:	89 81       	ldd	r24, Y+1	; 0x01
    261c:	9a 81       	ldd	r25, Y+2	; 0x02
    261e:	93 83       	std	Z+3, r25	; 0x03
    2620:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    2622:	20 91 b5 00 	lds	r18, 0x00B5
    2626:	30 91 b6 00 	lds	r19, 0x00B6
    262a:	89 81       	ldd	r24, Y+1	; 0x01
    262c:	9a 81       	ldd	r25, Y+2	; 0x02
    262e:	82 17       	cp	r24, r18
    2630:	93 07       	cpc	r25, r19
    2632:	70 f4       	brcc	.+28     	; 0x2650 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2634:	80 91 e1 00 	lds	r24, 0x00E1
    2638:	90 91 e2 00 	lds	r25, 0x00E2
    263c:	20 91 b2 00 	lds	r18, 0x00B2
    2640:	30 91 b3 00 	lds	r19, 0x00B3
    2644:	2e 5f       	subi	r18, 0xFE	; 254
    2646:	3f 4f       	sbci	r19, 0xFF	; 255
    2648:	b9 01       	movw	r22, r18
    264a:	0e 94 ea 15 	call	0x2bd4	; 0x2bd4 <vListInsert>
    264e:	0d c0       	rjmp	.+26     	; 0x266a <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2650:	80 91 df 00 	lds	r24, 0x00DF
    2654:	90 91 e0 00 	lds	r25, 0x00E0
    2658:	20 91 b2 00 	lds	r18, 0x00B2
    265c:	30 91 b3 00 	lds	r19, 0x00B3
    2660:	2e 5f       	subi	r18, 0xFE	; 254
    2662:	3f 4f       	sbci	r19, 0xFF	; 255
    2664:	b9 01       	movw	r22, r18
    2666:	0e 94 ea 15 	call	0x2bd4	; 0x2bd4 <vListInsert>
	}

	if( pxEventList )
    266a:	8d 81       	ldd	r24, Y+5	; 0x05
    266c:	9e 81       	ldd	r25, Y+6	; 0x06
    266e:	00 97       	sbiw	r24, 0x00	; 0
    2670:	61 f0       	breq	.+24     	; 0x268a <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    2672:	80 91 b2 00 	lds	r24, 0x00B2
    2676:	90 91 b3 00 	lds	r25, 0x00B3
    267a:	9c 01       	movw	r18, r24
    267c:	24 5f       	subi	r18, 0xF4	; 244
    267e:	3f 4f       	sbci	r19, 0xFF	; 255
    2680:	8d 81       	ldd	r24, Y+5	; 0x05
    2682:	9e 81       	ldd	r25, Y+6	; 0x06
    2684:	b9 01       	movw	r22, r18
    2686:	0e 94 ea 15 	call	0x2bd4	; 0x2bd4 <vListInsert>
	}
}
    268a:	26 96       	adiw	r28, 0x06	; 6
    268c:	0f b6       	in	r0, 0x3f	; 63
    268e:	f8 94       	cli
    2690:	de bf       	out	0x3e, r29	; 62
    2692:	0f be       	out	0x3f, r0	; 63
    2694:	cd bf       	out	0x3d, r28	; 61
    2696:	cf 91       	pop	r28
    2698:	df 91       	pop	r29
    269a:	08 95       	ret

0000269c <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    269c:	df 93       	push	r29
    269e:	cf 93       	push	r28
    26a0:	00 d0       	rcall	.+0      	; 0x26a2 <prvCheckPendingReadyList+0x6>
    26a2:	cd b7       	in	r28, 0x3d	; 61
    26a4:	de b7       	in	r29, 0x3e	; 62
    26a6:	3a c0       	rjmp	.+116    	; 0x271c <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    26a8:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    26aa:	e0 91 e8 00 	lds	r30, 0x00E8
    26ae:	f0 91 e9 00 	lds	r31, 0x00E9
    26b2:	86 81       	ldd	r24, Z+6	; 0x06
    26b4:	97 81       	ldd	r25, Z+7	; 0x07
    26b6:	9a 83       	std	Y+2, r25	; 0x02
    26b8:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    26ba:	89 81       	ldd	r24, Y+1	; 0x01
    26bc:	9a 81       	ldd	r25, Y+2	; 0x02
    26be:	0c 96       	adiw	r24, 0x0c	; 12
    26c0:	0e 94 56 16 	call	0x2cac	; 0x2cac <vListRemove>
		}
		portENABLE_INTERRUPTS();
    26c4:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    26c6:	89 81       	ldd	r24, Y+1	; 0x01
    26c8:	9a 81       	ldd	r25, Y+2	; 0x02
    26ca:	02 96       	adiw	r24, 0x02	; 2
    26cc:	0e 94 56 16 	call	0x2cac	; 0x2cac <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    26d0:	e9 81       	ldd	r30, Y+1	; 0x01
    26d2:	fa 81       	ldd	r31, Y+2	; 0x02
    26d4:	96 89       	ldd	r25, Z+22	; 0x16
    26d6:	80 91 b4 00 	lds	r24, 0x00B4
    26da:	89 17       	cp	r24, r25
    26dc:	28 f4       	brcc	.+10     	; 0x26e8 <prvCheckPendingReadyList+0x4c>
    26de:	e9 81       	ldd	r30, Y+1	; 0x01
    26e0:	fa 81       	ldd	r31, Y+2	; 0x02
    26e2:	86 89       	ldd	r24, Z+22	; 0x16
    26e4:	80 93 b4 00 	sts	0x00B4, r24
    26e8:	e9 81       	ldd	r30, Y+1	; 0x01
    26ea:	fa 81       	ldd	r31, Y+2	; 0x02
    26ec:	86 89       	ldd	r24, Z+22	; 0x16
    26ee:	28 2f       	mov	r18, r24
    26f0:	30 e0       	ldi	r19, 0x00	; 0
    26f2:	c9 01       	movw	r24, r18
    26f4:	88 0f       	add	r24, r24
    26f6:	99 1f       	adc	r25, r25
    26f8:	88 0f       	add	r24, r24
    26fa:	99 1f       	adc	r25, r25
    26fc:	88 0f       	add	r24, r24
    26fe:	99 1f       	adc	r25, r25
    2700:	82 0f       	add	r24, r18
    2702:	93 1f       	adc	r25, r19
    2704:	ac 01       	movw	r20, r24
    2706:	45 54       	subi	r20, 0x45	; 69
    2708:	5f 4f       	sbci	r21, 0xFF	; 255
    270a:	89 81       	ldd	r24, Y+1	; 0x01
    270c:	9a 81       	ldd	r25, Y+2	; 0x02
    270e:	9c 01       	movw	r18, r24
    2710:	2e 5f       	subi	r18, 0xFE	; 254
    2712:	3f 4f       	sbci	r19, 0xFF	; 255
    2714:	ca 01       	movw	r24, r20
    2716:	b9 01       	movw	r22, r18
    2718:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    271c:	80 91 e3 00 	lds	r24, 0x00E3
    2720:	88 23       	and	r24, r24
    2722:	09 f0       	breq	.+2      	; 0x2726 <prvCheckPendingReadyList+0x8a>
    2724:	c1 cf       	rjmp	.-126    	; 0x26a8 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    2726:	0f 90       	pop	r0
    2728:	0f 90       	pop	r0
    272a:	cf 91       	pop	r28
    272c:	df 91       	pop	r29
    272e:	08 95       	ret

00002730 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    2730:	df 93       	push	r29
    2732:	cf 93       	push	r28
    2734:	00 d0       	rcall	.+0      	; 0x2736 <prvCheckDelayedList+0x6>
    2736:	00 d0       	rcall	.+0      	; 0x2738 <prvCheckDelayedList+0x8>
    2738:	cd b7       	in	r28, 0x3d	; 61
    273a:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    273c:	0e 94 b9 21 	call	0x4372	; 0x4372 <xTaskGetTickCount>
    2740:	20 91 b7 00 	lds	r18, 0x00B7
    2744:	30 91 b8 00 	lds	r19, 0x00B8
    2748:	82 1b       	sub	r24, r18
    274a:	93 0b       	sbc	r25, r19
    274c:	90 93 ba 00 	sts	0x00BA, r25
    2750:	80 93 b9 00 	sts	0x00B9, r24
    2754:	85 c0       	rjmp	.+266    	; 0x2860 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    2756:	80 91 b5 00 	lds	r24, 0x00B5
    275a:	90 91 b6 00 	lds	r25, 0x00B6
    275e:	01 96       	adiw	r24, 0x01	; 1
    2760:	90 93 b6 00 	sts	0x00B6, r25
    2764:	80 93 b5 00 	sts	0x00B5, r24
		xPassedTicks--;
    2768:	80 91 b9 00 	lds	r24, 0x00B9
    276c:	90 91 ba 00 	lds	r25, 0x00BA
    2770:	01 97       	sbiw	r24, 0x01	; 1
    2772:	90 93 ba 00 	sts	0x00BA, r25
    2776:	80 93 b9 00 	sts	0x00B9, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    277a:	80 91 b5 00 	lds	r24, 0x00B5
    277e:	90 91 b6 00 	lds	r25, 0x00B6
    2782:	00 97       	sbiw	r24, 0x00	; 0
    2784:	09 f0       	breq	.+2      	; 0x2788 <prvCheckDelayedList+0x58>
    2786:	64 c0       	rjmp	.+200    	; 0x2850 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2788:	80 91 df 00 	lds	r24, 0x00DF
    278c:	90 91 e0 00 	lds	r25, 0x00E0
    2790:	9a 83       	std	Y+2, r25	; 0x02
    2792:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2794:	80 91 e1 00 	lds	r24, 0x00E1
    2798:	90 91 e2 00 	lds	r25, 0x00E2
    279c:	90 93 e0 00 	sts	0x00E0, r25
    27a0:	80 93 df 00 	sts	0x00DF, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    27a4:	89 81       	ldd	r24, Y+1	; 0x01
    27a6:	9a 81       	ldd	r25, Y+2	; 0x02
    27a8:	90 93 e2 00 	sts	0x00E2, r25
    27ac:	80 93 e1 00 	sts	0x00E1, r24
    27b0:	4f c0       	rjmp	.+158    	; 0x2850 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    27b2:	e0 91 df 00 	lds	r30, 0x00DF
    27b6:	f0 91 e0 00 	lds	r31, 0x00E0
    27ba:	05 80       	ldd	r0, Z+5	; 0x05
    27bc:	f6 81       	ldd	r31, Z+6	; 0x06
    27be:	e0 2d       	mov	r30, r0
    27c0:	86 81       	ldd	r24, Z+6	; 0x06
    27c2:	97 81       	ldd	r25, Z+7	; 0x07
    27c4:	9c 83       	std	Y+4, r25	; 0x04
    27c6:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    27c8:	eb 81       	ldd	r30, Y+3	; 0x03
    27ca:	fc 81       	ldd	r31, Y+4	; 0x04
    27cc:	22 81       	ldd	r18, Z+2	; 0x02
    27ce:	33 81       	ldd	r19, Z+3	; 0x03
    27d0:	80 91 b5 00 	lds	r24, 0x00B5
    27d4:	90 91 b6 00 	lds	r25, 0x00B6
    27d8:	82 17       	cp	r24, r18
    27da:	93 07       	cpc	r25, r19
    27dc:	08 f4       	brcc	.+2      	; 0x27e0 <prvCheckDelayedList+0xb0>
    27de:	40 c0       	rjmp	.+128    	; 0x2860 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    27e0:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    27e2:	8b 81       	ldd	r24, Y+3	; 0x03
    27e4:	9c 81       	ldd	r25, Y+4	; 0x04
    27e6:	02 96       	adiw	r24, 0x02	; 2
    27e8:	0e 94 56 16 	call	0x2cac	; 0x2cac <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    27ec:	eb 81       	ldd	r30, Y+3	; 0x03
    27ee:	fc 81       	ldd	r31, Y+4	; 0x04
    27f0:	84 89       	ldd	r24, Z+20	; 0x14
    27f2:	95 89       	ldd	r25, Z+21	; 0x15
    27f4:	00 97       	sbiw	r24, 0x00	; 0
    27f6:	29 f0       	breq	.+10     	; 0x2802 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    27f8:	8b 81       	ldd	r24, Y+3	; 0x03
    27fa:	9c 81       	ldd	r25, Y+4	; 0x04
    27fc:	0c 96       	adiw	r24, 0x0c	; 12
    27fe:	0e 94 56 16 	call	0x2cac	; 0x2cac <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2802:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2804:	eb 81       	ldd	r30, Y+3	; 0x03
    2806:	fc 81       	ldd	r31, Y+4	; 0x04
    2808:	96 89       	ldd	r25, Z+22	; 0x16
    280a:	80 91 b4 00 	lds	r24, 0x00B4
    280e:	89 17       	cp	r24, r25
    2810:	28 f4       	brcc	.+10     	; 0x281c <prvCheckDelayedList+0xec>
    2812:	eb 81       	ldd	r30, Y+3	; 0x03
    2814:	fc 81       	ldd	r31, Y+4	; 0x04
    2816:	86 89       	ldd	r24, Z+22	; 0x16
    2818:	80 93 b4 00 	sts	0x00B4, r24
    281c:	eb 81       	ldd	r30, Y+3	; 0x03
    281e:	fc 81       	ldd	r31, Y+4	; 0x04
    2820:	86 89       	ldd	r24, Z+22	; 0x16
    2822:	28 2f       	mov	r18, r24
    2824:	30 e0       	ldi	r19, 0x00	; 0
    2826:	c9 01       	movw	r24, r18
    2828:	88 0f       	add	r24, r24
    282a:	99 1f       	adc	r25, r25
    282c:	88 0f       	add	r24, r24
    282e:	99 1f       	adc	r25, r25
    2830:	88 0f       	add	r24, r24
    2832:	99 1f       	adc	r25, r25
    2834:	82 0f       	add	r24, r18
    2836:	93 1f       	adc	r25, r19
    2838:	ac 01       	movw	r20, r24
    283a:	45 54       	subi	r20, 0x45	; 69
    283c:	5f 4f       	sbci	r21, 0xFF	; 255
    283e:	8b 81       	ldd	r24, Y+3	; 0x03
    2840:	9c 81       	ldd	r25, Y+4	; 0x04
    2842:	9c 01       	movw	r18, r24
    2844:	2e 5f       	subi	r18, 0xFE	; 254
    2846:	3f 4f       	sbci	r19, 0xFF	; 255
    2848:	ca 01       	movw	r24, r20
    284a:	b9 01       	movw	r22, r18
    284c:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2850:	e0 91 df 00 	lds	r30, 0x00DF
    2854:	f0 91 e0 00 	lds	r31, 0x00E0
    2858:	80 81       	ld	r24, Z
    285a:	88 23       	and	r24, r24
    285c:	09 f0       	breq	.+2      	; 0x2860 <prvCheckDelayedList+0x130>
    285e:	a9 cf       	rjmp	.-174    	; 0x27b2 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2860:	80 91 b9 00 	lds	r24, 0x00B9
    2864:	90 91 ba 00 	lds	r25, 0x00BA
    2868:	00 97       	sbiw	r24, 0x00	; 0
    286a:	09 f0       	breq	.+2      	; 0x286e <prvCheckDelayedList+0x13e>
    286c:	74 cf       	rjmp	.-280    	; 0x2756 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    286e:	80 91 b5 00 	lds	r24, 0x00B5
    2872:	90 91 b6 00 	lds	r25, 0x00B6
    2876:	90 93 b8 00 	sts	0x00B8, r25
    287a:	80 93 b7 00 	sts	0x00B7, r24
}
    287e:	0f 90       	pop	r0
    2880:	0f 90       	pop	r0
    2882:	0f 90       	pop	r0
    2884:	0f 90       	pop	r0
    2886:	cf 91       	pop	r28
    2888:	df 91       	pop	r29
    288a:	08 95       	ret

0000288c <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    288c:	df 93       	push	r29
    288e:	cf 93       	push	r28
    2890:	00 d0       	rcall	.+0      	; 0x2892 <vCoRoutineSchedule+0x6>
    2892:	cd b7       	in	r28, 0x3d	; 61
    2894:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    2896:	0e 94 4e 13 	call	0x269c	; 0x269c <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    289a:	0e 94 98 13 	call	0x2730	; 0x2730 <prvCheckDelayedList>
    289e:	0a c0       	rjmp	.+20     	; 0x28b4 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    28a0:	80 91 b4 00 	lds	r24, 0x00B4
    28a4:	88 23       	and	r24, r24
    28a6:	09 f4       	brne	.+2      	; 0x28aa <vCoRoutineSchedule+0x1e>
    28a8:	66 c0       	rjmp	.+204    	; 0x2976 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    28aa:	80 91 b4 00 	lds	r24, 0x00B4
    28ae:	81 50       	subi	r24, 0x01	; 1
    28b0:	80 93 b4 00 	sts	0x00B4, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    28b4:	80 91 b4 00 	lds	r24, 0x00B4
    28b8:	28 2f       	mov	r18, r24
    28ba:	30 e0       	ldi	r19, 0x00	; 0
    28bc:	c9 01       	movw	r24, r18
    28be:	88 0f       	add	r24, r24
    28c0:	99 1f       	adc	r25, r25
    28c2:	88 0f       	add	r24, r24
    28c4:	99 1f       	adc	r25, r25
    28c6:	88 0f       	add	r24, r24
    28c8:	99 1f       	adc	r25, r25
    28ca:	82 0f       	add	r24, r18
    28cc:	93 1f       	adc	r25, r19
    28ce:	fc 01       	movw	r30, r24
    28d0:	e5 54       	subi	r30, 0x45	; 69
    28d2:	ff 4f       	sbci	r31, 0xFF	; 255
    28d4:	80 81       	ld	r24, Z
    28d6:	88 23       	and	r24, r24
    28d8:	19 f3       	breq	.-58     	; 0x28a0 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    28da:	80 91 b4 00 	lds	r24, 0x00B4
    28de:	28 2f       	mov	r18, r24
    28e0:	30 e0       	ldi	r19, 0x00	; 0
    28e2:	c9 01       	movw	r24, r18
    28e4:	88 0f       	add	r24, r24
    28e6:	99 1f       	adc	r25, r25
    28e8:	88 0f       	add	r24, r24
    28ea:	99 1f       	adc	r25, r25
    28ec:	88 0f       	add	r24, r24
    28ee:	99 1f       	adc	r25, r25
    28f0:	82 0f       	add	r24, r18
    28f2:	93 1f       	adc	r25, r19
    28f4:	85 54       	subi	r24, 0x45	; 69
    28f6:	9f 4f       	sbci	r25, 0xFF	; 255
    28f8:	9a 83       	std	Y+2, r25	; 0x02
    28fa:	89 83       	std	Y+1, r24	; 0x01
    28fc:	e9 81       	ldd	r30, Y+1	; 0x01
    28fe:	fa 81       	ldd	r31, Y+2	; 0x02
    2900:	01 80       	ldd	r0, Z+1	; 0x01
    2902:	f2 81       	ldd	r31, Z+2	; 0x02
    2904:	e0 2d       	mov	r30, r0
    2906:	82 81       	ldd	r24, Z+2	; 0x02
    2908:	93 81       	ldd	r25, Z+3	; 0x03
    290a:	e9 81       	ldd	r30, Y+1	; 0x01
    290c:	fa 81       	ldd	r31, Y+2	; 0x02
    290e:	92 83       	std	Z+2, r25	; 0x02
    2910:	81 83       	std	Z+1, r24	; 0x01
    2912:	e9 81       	ldd	r30, Y+1	; 0x01
    2914:	fa 81       	ldd	r31, Y+2	; 0x02
    2916:	21 81       	ldd	r18, Z+1	; 0x01
    2918:	32 81       	ldd	r19, Z+2	; 0x02
    291a:	89 81       	ldd	r24, Y+1	; 0x01
    291c:	9a 81       	ldd	r25, Y+2	; 0x02
    291e:	03 96       	adiw	r24, 0x03	; 3
    2920:	28 17       	cp	r18, r24
    2922:	39 07       	cpc	r19, r25
    2924:	59 f4       	brne	.+22     	; 0x293c <vCoRoutineSchedule+0xb0>
    2926:	e9 81       	ldd	r30, Y+1	; 0x01
    2928:	fa 81       	ldd	r31, Y+2	; 0x02
    292a:	01 80       	ldd	r0, Z+1	; 0x01
    292c:	f2 81       	ldd	r31, Z+2	; 0x02
    292e:	e0 2d       	mov	r30, r0
    2930:	82 81       	ldd	r24, Z+2	; 0x02
    2932:	93 81       	ldd	r25, Z+3	; 0x03
    2934:	e9 81       	ldd	r30, Y+1	; 0x01
    2936:	fa 81       	ldd	r31, Y+2	; 0x02
    2938:	92 83       	std	Z+2, r25	; 0x02
    293a:	81 83       	std	Z+1, r24	; 0x01
    293c:	e9 81       	ldd	r30, Y+1	; 0x01
    293e:	fa 81       	ldd	r31, Y+2	; 0x02
    2940:	01 80       	ldd	r0, Z+1	; 0x01
    2942:	f2 81       	ldd	r31, Z+2	; 0x02
    2944:	e0 2d       	mov	r30, r0
    2946:	86 81       	ldd	r24, Z+6	; 0x06
    2948:	97 81       	ldd	r25, Z+7	; 0x07
    294a:	90 93 b3 00 	sts	0x00B3, r25
    294e:	80 93 b2 00 	sts	0x00B2, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2952:	e0 91 b2 00 	lds	r30, 0x00B2
    2956:	f0 91 b3 00 	lds	r31, 0x00B3
    295a:	40 81       	ld	r20, Z
    295c:	51 81       	ldd	r21, Z+1	; 0x01
    295e:	80 91 b2 00 	lds	r24, 0x00B2
    2962:	90 91 b3 00 	lds	r25, 0x00B3
    2966:	e0 91 b2 00 	lds	r30, 0x00B2
    296a:	f0 91 b3 00 	lds	r31, 0x00B3
    296e:	27 89       	ldd	r18, Z+23	; 0x17
    2970:	62 2f       	mov	r22, r18
    2972:	fa 01       	movw	r30, r20
    2974:	09 95       	icall

	return;
}
    2976:	0f 90       	pop	r0
    2978:	0f 90       	pop	r0
    297a:	cf 91       	pop	r28
    297c:	df 91       	pop	r29
    297e:	08 95       	ret

00002980 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    2980:	df 93       	push	r29
    2982:	cf 93       	push	r28
    2984:	0f 92       	push	r0
    2986:	cd b7       	in	r28, 0x3d	; 61
    2988:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    298a:	19 82       	std	Y+1, r1	; 0x01
    298c:	13 c0       	rjmp	.+38     	; 0x29b4 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    298e:	89 81       	ldd	r24, Y+1	; 0x01
    2990:	28 2f       	mov	r18, r24
    2992:	30 e0       	ldi	r19, 0x00	; 0
    2994:	c9 01       	movw	r24, r18
    2996:	88 0f       	add	r24, r24
    2998:	99 1f       	adc	r25, r25
    299a:	88 0f       	add	r24, r24
    299c:	99 1f       	adc	r25, r25
    299e:	88 0f       	add	r24, r24
    29a0:	99 1f       	adc	r25, r25
    29a2:	82 0f       	add	r24, r18
    29a4:	93 1f       	adc	r25, r19
    29a6:	85 54       	subi	r24, 0x45	; 69
    29a8:	9f 4f       	sbci	r25, 0xFF	; 255
    29aa:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    29ae:	89 81       	ldd	r24, Y+1	; 0x01
    29b0:	8f 5f       	subi	r24, 0xFF	; 255
    29b2:	89 83       	std	Y+1, r24	; 0x01
    29b4:	89 81       	ldd	r24, Y+1	; 0x01
    29b6:	82 30       	cpi	r24, 0x02	; 2
    29b8:	50 f3       	brcs	.-44     	; 0x298e <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    29ba:	8d ec       	ldi	r24, 0xCD	; 205
    29bc:	90 e0       	ldi	r25, 0x00	; 0
    29be:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    29c2:	86 ed       	ldi	r24, 0xD6	; 214
    29c4:	90 e0       	ldi	r25, 0x00	; 0
    29c6:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    29ca:	83 ee       	ldi	r24, 0xE3	; 227
    29cc:	90 e0       	ldi	r25, 0x00	; 0
    29ce:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    29d2:	8d ec       	ldi	r24, 0xCD	; 205
    29d4:	90 e0       	ldi	r25, 0x00	; 0
    29d6:	90 93 e0 00 	sts	0x00E0, r25
    29da:	80 93 df 00 	sts	0x00DF, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    29de:	86 ed       	ldi	r24, 0xD6	; 214
    29e0:	90 e0       	ldi	r25, 0x00	; 0
    29e2:	90 93 e2 00 	sts	0x00E2, r25
    29e6:	80 93 e1 00 	sts	0x00E1, r24
}
    29ea:	0f 90       	pop	r0
    29ec:	cf 91       	pop	r28
    29ee:	df 91       	pop	r29
    29f0:	08 95       	ret

000029f2 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    29f2:	df 93       	push	r29
    29f4:	cf 93       	push	r28
    29f6:	00 d0       	rcall	.+0      	; 0x29f8 <xCoRoutineRemoveFromEventList+0x6>
    29f8:	00 d0       	rcall	.+0      	; 0x29fa <xCoRoutineRemoveFromEventList+0x8>
    29fa:	0f 92       	push	r0
    29fc:	cd b7       	in	r28, 0x3d	; 61
    29fe:	de b7       	in	r29, 0x3e	; 62
    2a00:	9d 83       	std	Y+5, r25	; 0x05
    2a02:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2a04:	ec 81       	ldd	r30, Y+4	; 0x04
    2a06:	fd 81       	ldd	r31, Y+5	; 0x05
    2a08:	05 80       	ldd	r0, Z+5	; 0x05
    2a0a:	f6 81       	ldd	r31, Z+6	; 0x06
    2a0c:	e0 2d       	mov	r30, r0
    2a0e:	86 81       	ldd	r24, Z+6	; 0x06
    2a10:	97 81       	ldd	r25, Z+7	; 0x07
    2a12:	9b 83       	std	Y+3, r25	; 0x03
    2a14:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2a16:	8a 81       	ldd	r24, Y+2	; 0x02
    2a18:	9b 81       	ldd	r25, Y+3	; 0x03
    2a1a:	0c 96       	adiw	r24, 0x0c	; 12
    2a1c:	0e 94 56 16 	call	0x2cac	; 0x2cac <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2a20:	8a 81       	ldd	r24, Y+2	; 0x02
    2a22:	9b 81       	ldd	r25, Y+3	; 0x03
    2a24:	9c 01       	movw	r18, r24
    2a26:	24 5f       	subi	r18, 0xF4	; 244
    2a28:	3f 4f       	sbci	r19, 0xFF	; 255
    2a2a:	83 ee       	ldi	r24, 0xE3	; 227
    2a2c:	90 e0       	ldi	r25, 0x00	; 0
    2a2e:	b9 01       	movw	r22, r18
    2a30:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2a34:	ea 81       	ldd	r30, Y+2	; 0x02
    2a36:	fb 81       	ldd	r31, Y+3	; 0x03
    2a38:	96 89       	ldd	r25, Z+22	; 0x16
    2a3a:	e0 91 b2 00 	lds	r30, 0x00B2
    2a3e:	f0 91 b3 00 	lds	r31, 0x00B3
    2a42:	86 89       	ldd	r24, Z+22	; 0x16
    2a44:	98 17       	cp	r25, r24
    2a46:	18 f0       	brcs	.+6      	; 0x2a4e <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    2a48:	81 e0       	ldi	r24, 0x01	; 1
    2a4a:	89 83       	std	Y+1, r24	; 0x01
    2a4c:	01 c0       	rjmp	.+2      	; 0x2a50 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    2a4e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2a50:	89 81       	ldd	r24, Y+1	; 0x01
}
    2a52:	0f 90       	pop	r0
    2a54:	0f 90       	pop	r0
    2a56:	0f 90       	pop	r0
    2a58:	0f 90       	pop	r0
    2a5a:	0f 90       	pop	r0
    2a5c:	cf 91       	pop	r28
    2a5e:	df 91       	pop	r29
    2a60:	08 95       	ret

00002a62 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2a62:	df 93       	push	r29
    2a64:	cf 93       	push	r28
    2a66:	00 d0       	rcall	.+0      	; 0x2a68 <pvPortMalloc+0x6>
    2a68:	00 d0       	rcall	.+0      	; 0x2a6a <pvPortMalloc+0x8>
    2a6a:	cd b7       	in	r28, 0x3d	; 61
    2a6c:	de b7       	in	r29, 0x3e	; 62
    2a6e:	9c 83       	std	Y+4, r25	; 0x04
    2a70:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn;

	vTaskSuspendAll();
    2a72:	0e 94 23 21 	call	0x4246	; 0x4246 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
    2a76:	8b 81       	ldd	r24, Y+3	; 0x03
    2a78:	9c 81       	ldd	r25, Y+4	; 0x04
    2a7a:	0e 94 25 27 	call	0x4e4a	; 0x4e4a <malloc>
    2a7e:	9a 83       	std	Y+2, r25	; 0x02
    2a80:	89 83       	std	Y+1, r24	; 0x01
	}
	xTaskResumeAll();
    2a82:	0e 94 2f 21 	call	0x425e	; 0x425e <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif
	
	return pvReturn;
    2a86:	89 81       	ldd	r24, Y+1	; 0x01
    2a88:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2a8a:	0f 90       	pop	r0
    2a8c:	0f 90       	pop	r0
    2a8e:	0f 90       	pop	r0
    2a90:	0f 90       	pop	r0
    2a92:	cf 91       	pop	r28
    2a94:	df 91       	pop	r29
    2a96:	08 95       	ret

00002a98 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2a98:	df 93       	push	r29
    2a9a:	cf 93       	push	r28
    2a9c:	00 d0       	rcall	.+0      	; 0x2a9e <vPortFree+0x6>
    2a9e:	cd b7       	in	r28, 0x3d	; 61
    2aa0:	de b7       	in	r29, 0x3e	; 62
    2aa2:	9a 83       	std	Y+2, r25	; 0x02
    2aa4:	89 83       	std	Y+1, r24	; 0x01
	if( pv )
    2aa6:	89 81       	ldd	r24, Y+1	; 0x01
    2aa8:	9a 81       	ldd	r25, Y+2	; 0x02
    2aaa:	00 97       	sbiw	r24, 0x00	; 0
    2aac:	41 f0       	breq	.+16     	; 0x2abe <vPortFree+0x26>
	{
		vTaskSuspendAll();
    2aae:	0e 94 23 21 	call	0x4246	; 0x4246 <vTaskSuspendAll>
		{
			free( pv );
    2ab2:	89 81       	ldd	r24, Y+1	; 0x01
    2ab4:	9a 81       	ldd	r25, Y+2	; 0x02
    2ab6:	0e 94 d2 27 	call	0x4fa4	; 0x4fa4 <free>
		}
		xTaskResumeAll();
    2aba:	0e 94 2f 21 	call	0x425e	; 0x425e <xTaskResumeAll>
	}
}
    2abe:	0f 90       	pop	r0
    2ac0:	0f 90       	pop	r0
    2ac2:	cf 91       	pop	r28
    2ac4:	df 91       	pop	r29
    2ac6:	08 95       	ret

00002ac8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2ac8:	df 93       	push	r29
    2aca:	cf 93       	push	r28
    2acc:	00 d0       	rcall	.+0      	; 0x2ace <vListInitialise+0x6>
    2ace:	cd b7       	in	r28, 0x3d	; 61
    2ad0:	de b7       	in	r29, 0x3e	; 62
    2ad2:	9a 83       	std	Y+2, r25	; 0x02
    2ad4:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2ad6:	89 81       	ldd	r24, Y+1	; 0x01
    2ad8:	9a 81       	ldd	r25, Y+2	; 0x02
    2ada:	03 96       	adiw	r24, 0x03	; 3
    2adc:	e9 81       	ldd	r30, Y+1	; 0x01
    2ade:	fa 81       	ldd	r31, Y+2	; 0x02
    2ae0:	92 83       	std	Z+2, r25	; 0x02
    2ae2:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2ae4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ae6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ae8:	8f ef       	ldi	r24, 0xFF	; 255
    2aea:	9f ef       	ldi	r25, 0xFF	; 255
    2aec:	94 83       	std	Z+4, r25	; 0x04
    2aee:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    2af0:	89 81       	ldd	r24, Y+1	; 0x01
    2af2:	9a 81       	ldd	r25, Y+2	; 0x02
    2af4:	03 96       	adiw	r24, 0x03	; 3
    2af6:	e9 81       	ldd	r30, Y+1	; 0x01
    2af8:	fa 81       	ldd	r31, Y+2	; 0x02
    2afa:	96 83       	std	Z+6, r25	; 0x06
    2afc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    2afe:	89 81       	ldd	r24, Y+1	; 0x01
    2b00:	9a 81       	ldd	r25, Y+2	; 0x02
    2b02:	03 96       	adiw	r24, 0x03	; 3
    2b04:	e9 81       	ldd	r30, Y+1	; 0x01
    2b06:	fa 81       	ldd	r31, Y+2	; 0x02
    2b08:	90 87       	std	Z+8, r25	; 0x08
    2b0a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    2b0c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b0e:	fa 81       	ldd	r31, Y+2	; 0x02
    2b10:	10 82       	st	Z, r1
}
    2b12:	0f 90       	pop	r0
    2b14:	0f 90       	pop	r0
    2b16:	cf 91       	pop	r28
    2b18:	df 91       	pop	r29
    2b1a:	08 95       	ret

00002b1c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    2b1c:	df 93       	push	r29
    2b1e:	cf 93       	push	r28
    2b20:	00 d0       	rcall	.+0      	; 0x2b22 <vListInitialiseItem+0x6>
    2b22:	cd b7       	in	r28, 0x3d	; 61
    2b24:	de b7       	in	r29, 0x3e	; 62
    2b26:	9a 83       	std	Y+2, r25	; 0x02
    2b28:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2b2a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b2c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b2e:	11 86       	std	Z+9, r1	; 0x09
    2b30:	10 86       	std	Z+8, r1	; 0x08
}
    2b32:	0f 90       	pop	r0
    2b34:	0f 90       	pop	r0
    2b36:	cf 91       	pop	r28
    2b38:	df 91       	pop	r29
    2b3a:	08 95       	ret

00002b3c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    2b3c:	df 93       	push	r29
    2b3e:	cf 93       	push	r28
    2b40:	00 d0       	rcall	.+0      	; 0x2b42 <vListInsertEnd+0x6>
    2b42:	00 d0       	rcall	.+0      	; 0x2b44 <vListInsertEnd+0x8>
    2b44:	00 d0       	rcall	.+0      	; 0x2b46 <vListInsertEnd+0xa>
    2b46:	cd b7       	in	r28, 0x3d	; 61
    2b48:	de b7       	in	r29, 0x3e	; 62
    2b4a:	9c 83       	std	Y+4, r25	; 0x04
    2b4c:	8b 83       	std	Y+3, r24	; 0x03
    2b4e:	7e 83       	std	Y+6, r23	; 0x06
    2b50:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2b52:	eb 81       	ldd	r30, Y+3	; 0x03
    2b54:	fc 81       	ldd	r31, Y+4	; 0x04
    2b56:	81 81       	ldd	r24, Z+1	; 0x01
    2b58:	92 81       	ldd	r25, Z+2	; 0x02
    2b5a:	9a 83       	std	Y+2, r25	; 0x02
    2b5c:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    2b5e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b60:	fa 81       	ldd	r31, Y+2	; 0x02
    2b62:	82 81       	ldd	r24, Z+2	; 0x02
    2b64:	93 81       	ldd	r25, Z+3	; 0x03
    2b66:	ed 81       	ldd	r30, Y+5	; 0x05
    2b68:	fe 81       	ldd	r31, Y+6	; 0x06
    2b6a:	93 83       	std	Z+3, r25	; 0x03
    2b6c:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    2b6e:	eb 81       	ldd	r30, Y+3	; 0x03
    2b70:	fc 81       	ldd	r31, Y+4	; 0x04
    2b72:	81 81       	ldd	r24, Z+1	; 0x01
    2b74:	92 81       	ldd	r25, Z+2	; 0x02
    2b76:	ed 81       	ldd	r30, Y+5	; 0x05
    2b78:	fe 81       	ldd	r31, Y+6	; 0x06
    2b7a:	95 83       	std	Z+5, r25	; 0x05
    2b7c:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2b7e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b80:	fa 81       	ldd	r31, Y+2	; 0x02
    2b82:	02 80       	ldd	r0, Z+2	; 0x02
    2b84:	f3 81       	ldd	r31, Z+3	; 0x03
    2b86:	e0 2d       	mov	r30, r0
    2b88:	8d 81       	ldd	r24, Y+5	; 0x05
    2b8a:	9e 81       	ldd	r25, Y+6	; 0x06
    2b8c:	95 83       	std	Z+5, r25	; 0x05
    2b8e:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    2b90:	8d 81       	ldd	r24, Y+5	; 0x05
    2b92:	9e 81       	ldd	r25, Y+6	; 0x06
    2b94:	e9 81       	ldd	r30, Y+1	; 0x01
    2b96:	fa 81       	ldd	r31, Y+2	; 0x02
    2b98:	93 83       	std	Z+3, r25	; 0x03
    2b9a:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    2b9c:	8d 81       	ldd	r24, Y+5	; 0x05
    2b9e:	9e 81       	ldd	r25, Y+6	; 0x06
    2ba0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ba2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ba4:	92 83       	std	Z+2, r25	; 0x02
    2ba6:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2ba8:	ed 81       	ldd	r30, Y+5	; 0x05
    2baa:	fe 81       	ldd	r31, Y+6	; 0x06
    2bac:	8b 81       	ldd	r24, Y+3	; 0x03
    2bae:	9c 81       	ldd	r25, Y+4	; 0x04
    2bb0:	91 87       	std	Z+9, r25	; 0x09
    2bb2:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2bb4:	eb 81       	ldd	r30, Y+3	; 0x03
    2bb6:	fc 81       	ldd	r31, Y+4	; 0x04
    2bb8:	80 81       	ld	r24, Z
    2bba:	8f 5f       	subi	r24, 0xFF	; 255
    2bbc:	eb 81       	ldd	r30, Y+3	; 0x03
    2bbe:	fc 81       	ldd	r31, Y+4	; 0x04
    2bc0:	80 83       	st	Z, r24
}
    2bc2:	26 96       	adiw	r28, 0x06	; 6
    2bc4:	0f b6       	in	r0, 0x3f	; 63
    2bc6:	f8 94       	cli
    2bc8:	de bf       	out	0x3e, r29	; 62
    2bca:	0f be       	out	0x3f, r0	; 63
    2bcc:	cd bf       	out	0x3d, r28	; 61
    2bce:	cf 91       	pop	r28
    2bd0:	df 91       	pop	r29
    2bd2:	08 95       	ret

00002bd4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    2bd4:	df 93       	push	r29
    2bd6:	cf 93       	push	r28
    2bd8:	cd b7       	in	r28, 0x3d	; 61
    2bda:	de b7       	in	r29, 0x3e	; 62
    2bdc:	28 97       	sbiw	r28, 0x08	; 8
    2bde:	0f b6       	in	r0, 0x3f	; 63
    2be0:	f8 94       	cli
    2be2:	de bf       	out	0x3e, r29	; 62
    2be4:	0f be       	out	0x3f, r0	; 63
    2be6:	cd bf       	out	0x3d, r28	; 61
    2be8:	9e 83       	std	Y+6, r25	; 0x06
    2bea:	8d 83       	std	Y+5, r24	; 0x05
    2bec:	78 87       	std	Y+8, r23	; 0x08
    2bee:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    2bf0:	ef 81       	ldd	r30, Y+7	; 0x07
    2bf2:	f8 85       	ldd	r31, Y+8	; 0x08
    2bf4:	80 81       	ld	r24, Z
    2bf6:	91 81       	ldd	r25, Z+1	; 0x01
    2bf8:	9a 83       	std	Y+2, r25	; 0x02
    2bfa:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2bfc:	89 81       	ldd	r24, Y+1	; 0x01
    2bfe:	9a 81       	ldd	r25, Y+2	; 0x02
    2c00:	2f ef       	ldi	r18, 0xFF	; 255
    2c02:	8f 3f       	cpi	r24, 0xFF	; 255
    2c04:	92 07       	cpc	r25, r18
    2c06:	39 f4       	brne	.+14     	; 0x2c16 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2c08:	ed 81       	ldd	r30, Y+5	; 0x05
    2c0a:	fe 81       	ldd	r31, Y+6	; 0x06
    2c0c:	87 81       	ldd	r24, Z+7	; 0x07
    2c0e:	90 85       	ldd	r25, Z+8	; 0x08
    2c10:	9c 83       	std	Y+4, r25	; 0x04
    2c12:	8b 83       	std	Y+3, r24	; 0x03
    2c14:	18 c0       	rjmp	.+48     	; 0x2c46 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    2c16:	8d 81       	ldd	r24, Y+5	; 0x05
    2c18:	9e 81       	ldd	r25, Y+6	; 0x06
    2c1a:	03 96       	adiw	r24, 0x03	; 3
    2c1c:	9c 83       	std	Y+4, r25	; 0x04
    2c1e:	8b 83       	std	Y+3, r24	; 0x03
    2c20:	06 c0       	rjmp	.+12     	; 0x2c2e <vListInsert+0x5a>
    2c22:	eb 81       	ldd	r30, Y+3	; 0x03
    2c24:	fc 81       	ldd	r31, Y+4	; 0x04
    2c26:	82 81       	ldd	r24, Z+2	; 0x02
    2c28:	93 81       	ldd	r25, Z+3	; 0x03
    2c2a:	9c 83       	std	Y+4, r25	; 0x04
    2c2c:	8b 83       	std	Y+3, r24	; 0x03
    2c2e:	eb 81       	ldd	r30, Y+3	; 0x03
    2c30:	fc 81       	ldd	r31, Y+4	; 0x04
    2c32:	02 80       	ldd	r0, Z+2	; 0x02
    2c34:	f3 81       	ldd	r31, Z+3	; 0x03
    2c36:	e0 2d       	mov	r30, r0
    2c38:	20 81       	ld	r18, Z
    2c3a:	31 81       	ldd	r19, Z+1	; 0x01
    2c3c:	89 81       	ldd	r24, Y+1	; 0x01
    2c3e:	9a 81       	ldd	r25, Y+2	; 0x02
    2c40:	82 17       	cp	r24, r18
    2c42:	93 07       	cpc	r25, r19
    2c44:	70 f7       	brcc	.-36     	; 0x2c22 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2c46:	eb 81       	ldd	r30, Y+3	; 0x03
    2c48:	fc 81       	ldd	r31, Y+4	; 0x04
    2c4a:	82 81       	ldd	r24, Z+2	; 0x02
    2c4c:	93 81       	ldd	r25, Z+3	; 0x03
    2c4e:	ef 81       	ldd	r30, Y+7	; 0x07
    2c50:	f8 85       	ldd	r31, Y+8	; 0x08
    2c52:	93 83       	std	Z+3, r25	; 0x03
    2c54:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2c56:	ef 81       	ldd	r30, Y+7	; 0x07
    2c58:	f8 85       	ldd	r31, Y+8	; 0x08
    2c5a:	02 80       	ldd	r0, Z+2	; 0x02
    2c5c:	f3 81       	ldd	r31, Z+3	; 0x03
    2c5e:	e0 2d       	mov	r30, r0
    2c60:	8f 81       	ldd	r24, Y+7	; 0x07
    2c62:	98 85       	ldd	r25, Y+8	; 0x08
    2c64:	95 83       	std	Z+5, r25	; 0x05
    2c66:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2c68:	ef 81       	ldd	r30, Y+7	; 0x07
    2c6a:	f8 85       	ldd	r31, Y+8	; 0x08
    2c6c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c6e:	9c 81       	ldd	r25, Y+4	; 0x04
    2c70:	95 83       	std	Z+5, r25	; 0x05
    2c72:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    2c74:	8f 81       	ldd	r24, Y+7	; 0x07
    2c76:	98 85       	ldd	r25, Y+8	; 0x08
    2c78:	eb 81       	ldd	r30, Y+3	; 0x03
    2c7a:	fc 81       	ldd	r31, Y+4	; 0x04
    2c7c:	93 83       	std	Z+3, r25	; 0x03
    2c7e:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2c80:	ef 81       	ldd	r30, Y+7	; 0x07
    2c82:	f8 85       	ldd	r31, Y+8	; 0x08
    2c84:	8d 81       	ldd	r24, Y+5	; 0x05
    2c86:	9e 81       	ldd	r25, Y+6	; 0x06
    2c88:	91 87       	std	Z+9, r25	; 0x09
    2c8a:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2c8c:	ed 81       	ldd	r30, Y+5	; 0x05
    2c8e:	fe 81       	ldd	r31, Y+6	; 0x06
    2c90:	80 81       	ld	r24, Z
    2c92:	8f 5f       	subi	r24, 0xFF	; 255
    2c94:	ed 81       	ldd	r30, Y+5	; 0x05
    2c96:	fe 81       	ldd	r31, Y+6	; 0x06
    2c98:	80 83       	st	Z, r24
}
    2c9a:	28 96       	adiw	r28, 0x08	; 8
    2c9c:	0f b6       	in	r0, 0x3f	; 63
    2c9e:	f8 94       	cli
    2ca0:	de bf       	out	0x3e, r29	; 62
    2ca2:	0f be       	out	0x3f, r0	; 63
    2ca4:	cd bf       	out	0x3d, r28	; 61
    2ca6:	cf 91       	pop	r28
    2ca8:	df 91       	pop	r29
    2caa:	08 95       	ret

00002cac <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    2cac:	df 93       	push	r29
    2cae:	cf 93       	push	r28
    2cb0:	00 d0       	rcall	.+0      	; 0x2cb2 <vListRemove+0x6>
    2cb2:	00 d0       	rcall	.+0      	; 0x2cb4 <vListRemove+0x8>
    2cb4:	cd b7       	in	r28, 0x3d	; 61
    2cb6:	de b7       	in	r29, 0x3e	; 62
    2cb8:	9c 83       	std	Y+4, r25	; 0x04
    2cba:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2cbc:	eb 81       	ldd	r30, Y+3	; 0x03
    2cbe:	fc 81       	ldd	r31, Y+4	; 0x04
    2cc0:	a2 81       	ldd	r26, Z+2	; 0x02
    2cc2:	b3 81       	ldd	r27, Z+3	; 0x03
    2cc4:	eb 81       	ldd	r30, Y+3	; 0x03
    2cc6:	fc 81       	ldd	r31, Y+4	; 0x04
    2cc8:	84 81       	ldd	r24, Z+4	; 0x04
    2cca:	95 81       	ldd	r25, Z+5	; 0x05
    2ccc:	15 96       	adiw	r26, 0x05	; 5
    2cce:	9c 93       	st	X, r25
    2cd0:	8e 93       	st	-X, r24
    2cd2:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2cd4:	eb 81       	ldd	r30, Y+3	; 0x03
    2cd6:	fc 81       	ldd	r31, Y+4	; 0x04
    2cd8:	a4 81       	ldd	r26, Z+4	; 0x04
    2cda:	b5 81       	ldd	r27, Z+5	; 0x05
    2cdc:	eb 81       	ldd	r30, Y+3	; 0x03
    2cde:	fc 81       	ldd	r31, Y+4	; 0x04
    2ce0:	82 81       	ldd	r24, Z+2	; 0x02
    2ce2:	93 81       	ldd	r25, Z+3	; 0x03
    2ce4:	13 96       	adiw	r26, 0x03	; 3
    2ce6:	9c 93       	st	X, r25
    2ce8:	8e 93       	st	-X, r24
    2cea:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    2cec:	eb 81       	ldd	r30, Y+3	; 0x03
    2cee:	fc 81       	ldd	r31, Y+4	; 0x04
    2cf0:	80 85       	ldd	r24, Z+8	; 0x08
    2cf2:	91 85       	ldd	r25, Z+9	; 0x09
    2cf4:	9a 83       	std	Y+2, r25	; 0x02
    2cf6:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2cf8:	e9 81       	ldd	r30, Y+1	; 0x01
    2cfa:	fa 81       	ldd	r31, Y+2	; 0x02
    2cfc:	21 81       	ldd	r18, Z+1	; 0x01
    2cfe:	32 81       	ldd	r19, Z+2	; 0x02
    2d00:	8b 81       	ldd	r24, Y+3	; 0x03
    2d02:	9c 81       	ldd	r25, Y+4	; 0x04
    2d04:	28 17       	cp	r18, r24
    2d06:	39 07       	cpc	r19, r25
    2d08:	41 f4       	brne	.+16     	; 0x2d1a <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2d0a:	eb 81       	ldd	r30, Y+3	; 0x03
    2d0c:	fc 81       	ldd	r31, Y+4	; 0x04
    2d0e:	84 81       	ldd	r24, Z+4	; 0x04
    2d10:	95 81       	ldd	r25, Z+5	; 0x05
    2d12:	e9 81       	ldd	r30, Y+1	; 0x01
    2d14:	fa 81       	ldd	r31, Y+2	; 0x02
    2d16:	92 83       	std	Z+2, r25	; 0x02
    2d18:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    2d1a:	eb 81       	ldd	r30, Y+3	; 0x03
    2d1c:	fc 81       	ldd	r31, Y+4	; 0x04
    2d1e:	11 86       	std	Z+9, r1	; 0x09
    2d20:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2d22:	e9 81       	ldd	r30, Y+1	; 0x01
    2d24:	fa 81       	ldd	r31, Y+2	; 0x02
    2d26:	80 81       	ld	r24, Z
    2d28:	81 50       	subi	r24, 0x01	; 1
    2d2a:	e9 81       	ldd	r30, Y+1	; 0x01
    2d2c:	fa 81       	ldd	r31, Y+2	; 0x02
    2d2e:	80 83       	st	Z, r24
}
    2d30:	0f 90       	pop	r0
    2d32:	0f 90       	pop	r0
    2d34:	0f 90       	pop	r0
    2d36:	0f 90       	pop	r0
    2d38:	cf 91       	pop	r28
    2d3a:	df 91       	pop	r29
    2d3c:	08 95       	ret

00002d3e <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    2d3e:	df 93       	push	r29
    2d40:	cf 93       	push	r28
    2d42:	cd b7       	in	r28, 0x3d	; 61
    2d44:	de b7       	in	r29, 0x3e	; 62
    2d46:	28 97       	sbiw	r28, 0x08	; 8
    2d48:	0f b6       	in	r0, 0x3f	; 63
    2d4a:	f8 94       	cli
    2d4c:	de bf       	out	0x3e, r29	; 62
    2d4e:	0f be       	out	0x3f, r0	; 63
    2d50:	cd bf       	out	0x3d, r28	; 61
    2d52:	9c 83       	std	Y+4, r25	; 0x04
    2d54:	8b 83       	std	Y+3, r24	; 0x03
    2d56:	7e 83       	std	Y+6, r23	; 0x06
    2d58:	6d 83       	std	Y+5, r22	; 0x05
    2d5a:	58 87       	std	Y+8, r21	; 0x08
    2d5c:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2d5e:	eb 81       	ldd	r30, Y+3	; 0x03
    2d60:	fc 81       	ldd	r31, Y+4	; 0x04
    2d62:	81 e1       	ldi	r24, 0x11	; 17
    2d64:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d66:	8b 81       	ldd	r24, Y+3	; 0x03
    2d68:	9c 81       	ldd	r25, Y+4	; 0x04
    2d6a:	01 97       	sbiw	r24, 0x01	; 1
    2d6c:	9c 83       	std	Y+4, r25	; 0x04
    2d6e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    2d70:	eb 81       	ldd	r30, Y+3	; 0x03
    2d72:	fc 81       	ldd	r31, Y+4	; 0x04
    2d74:	82 e2       	ldi	r24, 0x22	; 34
    2d76:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d78:	8b 81       	ldd	r24, Y+3	; 0x03
    2d7a:	9c 81       	ldd	r25, Y+4	; 0x04
    2d7c:	01 97       	sbiw	r24, 0x01	; 1
    2d7e:	9c 83       	std	Y+4, r25	; 0x04
    2d80:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    2d82:	eb 81       	ldd	r30, Y+3	; 0x03
    2d84:	fc 81       	ldd	r31, Y+4	; 0x04
    2d86:	83 e3       	ldi	r24, 0x33	; 51
    2d88:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d8a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d8c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d8e:	01 97       	sbiw	r24, 0x01	; 1
    2d90:	9c 83       	std	Y+4, r25	; 0x04
    2d92:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    2d94:	8d 81       	ldd	r24, Y+5	; 0x05
    2d96:	9e 81       	ldd	r25, Y+6	; 0x06
    2d98:	9a 83       	std	Y+2, r25	; 0x02
    2d9a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2d9c:	89 81       	ldd	r24, Y+1	; 0x01
    2d9e:	eb 81       	ldd	r30, Y+3	; 0x03
    2da0:	fc 81       	ldd	r31, Y+4	; 0x04
    2da2:	80 83       	st	Z, r24
	pxTopOfStack--;
    2da4:	8b 81       	ldd	r24, Y+3	; 0x03
    2da6:	9c 81       	ldd	r25, Y+4	; 0x04
    2da8:	01 97       	sbiw	r24, 0x01	; 1
    2daa:	9c 83       	std	Y+4, r25	; 0x04
    2dac:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2dae:	89 81       	ldd	r24, Y+1	; 0x01
    2db0:	9a 81       	ldd	r25, Y+2	; 0x02
    2db2:	89 2f       	mov	r24, r25
    2db4:	99 27       	eor	r25, r25
    2db6:	9a 83       	std	Y+2, r25	; 0x02
    2db8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2dba:	89 81       	ldd	r24, Y+1	; 0x01
    2dbc:	eb 81       	ldd	r30, Y+3	; 0x03
    2dbe:	fc 81       	ldd	r31, Y+4	; 0x04
    2dc0:	80 83       	st	Z, r24
	pxTopOfStack--;
    2dc2:	8b 81       	ldd	r24, Y+3	; 0x03
    2dc4:	9c 81       	ldd	r25, Y+4	; 0x04
    2dc6:	01 97       	sbiw	r24, 0x01	; 1
    2dc8:	9c 83       	std	Y+4, r25	; 0x04
    2dca:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    2dcc:	eb 81       	ldd	r30, Y+3	; 0x03
    2dce:	fc 81       	ldd	r31, Y+4	; 0x04
    2dd0:	10 82       	st	Z, r1
	pxTopOfStack--;
    2dd2:	8b 81       	ldd	r24, Y+3	; 0x03
    2dd4:	9c 81       	ldd	r25, Y+4	; 0x04
    2dd6:	01 97       	sbiw	r24, 0x01	; 1
    2dd8:	9c 83       	std	Y+4, r25	; 0x04
    2dda:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2ddc:	eb 81       	ldd	r30, Y+3	; 0x03
    2dde:	fc 81       	ldd	r31, Y+4	; 0x04
    2de0:	80 e8       	ldi	r24, 0x80	; 128
    2de2:	80 83       	st	Z, r24
	pxTopOfStack--;
    2de4:	8b 81       	ldd	r24, Y+3	; 0x03
    2de6:	9c 81       	ldd	r25, Y+4	; 0x04
    2de8:	01 97       	sbiw	r24, 0x01	; 1
    2dea:	9c 83       	std	Y+4, r25	; 0x04
    2dec:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    2dee:	eb 81       	ldd	r30, Y+3	; 0x03
    2df0:	fc 81       	ldd	r31, Y+4	; 0x04
    2df2:	10 82       	st	Z, r1
	pxTopOfStack--;
    2df4:	8b 81       	ldd	r24, Y+3	; 0x03
    2df6:	9c 81       	ldd	r25, Y+4	; 0x04
    2df8:	01 97       	sbiw	r24, 0x01	; 1
    2dfa:	9c 83       	std	Y+4, r25	; 0x04
    2dfc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    2dfe:	eb 81       	ldd	r30, Y+3	; 0x03
    2e00:	fc 81       	ldd	r31, Y+4	; 0x04
    2e02:	82 e0       	ldi	r24, 0x02	; 2
    2e04:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e06:	8b 81       	ldd	r24, Y+3	; 0x03
    2e08:	9c 81       	ldd	r25, Y+4	; 0x04
    2e0a:	01 97       	sbiw	r24, 0x01	; 1
    2e0c:	9c 83       	std	Y+4, r25	; 0x04
    2e0e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    2e10:	eb 81       	ldd	r30, Y+3	; 0x03
    2e12:	fc 81       	ldd	r31, Y+4	; 0x04
    2e14:	83 e0       	ldi	r24, 0x03	; 3
    2e16:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e18:	8b 81       	ldd	r24, Y+3	; 0x03
    2e1a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e1c:	01 97       	sbiw	r24, 0x01	; 1
    2e1e:	9c 83       	std	Y+4, r25	; 0x04
    2e20:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    2e22:	eb 81       	ldd	r30, Y+3	; 0x03
    2e24:	fc 81       	ldd	r31, Y+4	; 0x04
    2e26:	84 e0       	ldi	r24, 0x04	; 4
    2e28:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e2e:	01 97       	sbiw	r24, 0x01	; 1
    2e30:	9c 83       	std	Y+4, r25	; 0x04
    2e32:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    2e34:	eb 81       	ldd	r30, Y+3	; 0x03
    2e36:	fc 81       	ldd	r31, Y+4	; 0x04
    2e38:	85 e0       	ldi	r24, 0x05	; 5
    2e3a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e3e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e40:	01 97       	sbiw	r24, 0x01	; 1
    2e42:	9c 83       	std	Y+4, r25	; 0x04
    2e44:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    2e46:	eb 81       	ldd	r30, Y+3	; 0x03
    2e48:	fc 81       	ldd	r31, Y+4	; 0x04
    2e4a:	86 e0       	ldi	r24, 0x06	; 6
    2e4c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e50:	9c 81       	ldd	r25, Y+4	; 0x04
    2e52:	01 97       	sbiw	r24, 0x01	; 1
    2e54:	9c 83       	std	Y+4, r25	; 0x04
    2e56:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    2e58:	eb 81       	ldd	r30, Y+3	; 0x03
    2e5a:	fc 81       	ldd	r31, Y+4	; 0x04
    2e5c:	87 e0       	ldi	r24, 0x07	; 7
    2e5e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e60:	8b 81       	ldd	r24, Y+3	; 0x03
    2e62:	9c 81       	ldd	r25, Y+4	; 0x04
    2e64:	01 97       	sbiw	r24, 0x01	; 1
    2e66:	9c 83       	std	Y+4, r25	; 0x04
    2e68:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    2e6a:	eb 81       	ldd	r30, Y+3	; 0x03
    2e6c:	fc 81       	ldd	r31, Y+4	; 0x04
    2e6e:	88 e0       	ldi	r24, 0x08	; 8
    2e70:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e72:	8b 81       	ldd	r24, Y+3	; 0x03
    2e74:	9c 81       	ldd	r25, Y+4	; 0x04
    2e76:	01 97       	sbiw	r24, 0x01	; 1
    2e78:	9c 83       	std	Y+4, r25	; 0x04
    2e7a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    2e7c:	eb 81       	ldd	r30, Y+3	; 0x03
    2e7e:	fc 81       	ldd	r31, Y+4	; 0x04
    2e80:	89 e0       	ldi	r24, 0x09	; 9
    2e82:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e84:	8b 81       	ldd	r24, Y+3	; 0x03
    2e86:	9c 81       	ldd	r25, Y+4	; 0x04
    2e88:	01 97       	sbiw	r24, 0x01	; 1
    2e8a:	9c 83       	std	Y+4, r25	; 0x04
    2e8c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    2e8e:	eb 81       	ldd	r30, Y+3	; 0x03
    2e90:	fc 81       	ldd	r31, Y+4	; 0x04
    2e92:	80 e1       	ldi	r24, 0x10	; 16
    2e94:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e96:	8b 81       	ldd	r24, Y+3	; 0x03
    2e98:	9c 81       	ldd	r25, Y+4	; 0x04
    2e9a:	01 97       	sbiw	r24, 0x01	; 1
    2e9c:	9c 83       	std	Y+4, r25	; 0x04
    2e9e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    2ea0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ea2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ea4:	81 e1       	ldi	r24, 0x11	; 17
    2ea6:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ea8:	8b 81       	ldd	r24, Y+3	; 0x03
    2eaa:	9c 81       	ldd	r25, Y+4	; 0x04
    2eac:	01 97       	sbiw	r24, 0x01	; 1
    2eae:	9c 83       	std	Y+4, r25	; 0x04
    2eb0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    2eb2:	eb 81       	ldd	r30, Y+3	; 0x03
    2eb4:	fc 81       	ldd	r31, Y+4	; 0x04
    2eb6:	82 e1       	ldi	r24, 0x12	; 18
    2eb8:	80 83       	st	Z, r24
	pxTopOfStack--;
    2eba:	8b 81       	ldd	r24, Y+3	; 0x03
    2ebc:	9c 81       	ldd	r25, Y+4	; 0x04
    2ebe:	01 97       	sbiw	r24, 0x01	; 1
    2ec0:	9c 83       	std	Y+4, r25	; 0x04
    2ec2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    2ec4:	eb 81       	ldd	r30, Y+3	; 0x03
    2ec6:	fc 81       	ldd	r31, Y+4	; 0x04
    2ec8:	83 e1       	ldi	r24, 0x13	; 19
    2eca:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ecc:	8b 81       	ldd	r24, Y+3	; 0x03
    2ece:	9c 81       	ldd	r25, Y+4	; 0x04
    2ed0:	01 97       	sbiw	r24, 0x01	; 1
    2ed2:	9c 83       	std	Y+4, r25	; 0x04
    2ed4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    2ed6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ed8:	fc 81       	ldd	r31, Y+4	; 0x04
    2eda:	84 e1       	ldi	r24, 0x14	; 20
    2edc:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ede:	8b 81       	ldd	r24, Y+3	; 0x03
    2ee0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ee2:	01 97       	sbiw	r24, 0x01	; 1
    2ee4:	9c 83       	std	Y+4, r25	; 0x04
    2ee6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    2ee8:	eb 81       	ldd	r30, Y+3	; 0x03
    2eea:	fc 81       	ldd	r31, Y+4	; 0x04
    2eec:	85 e1       	ldi	r24, 0x15	; 21
    2eee:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ef0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ef2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ef4:	01 97       	sbiw	r24, 0x01	; 1
    2ef6:	9c 83       	std	Y+4, r25	; 0x04
    2ef8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    2efa:	eb 81       	ldd	r30, Y+3	; 0x03
    2efc:	fc 81       	ldd	r31, Y+4	; 0x04
    2efe:	86 e1       	ldi	r24, 0x16	; 22
    2f00:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f02:	8b 81       	ldd	r24, Y+3	; 0x03
    2f04:	9c 81       	ldd	r25, Y+4	; 0x04
    2f06:	01 97       	sbiw	r24, 0x01	; 1
    2f08:	9c 83       	std	Y+4, r25	; 0x04
    2f0a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    2f0c:	eb 81       	ldd	r30, Y+3	; 0x03
    2f0e:	fc 81       	ldd	r31, Y+4	; 0x04
    2f10:	87 e1       	ldi	r24, 0x17	; 23
    2f12:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f14:	8b 81       	ldd	r24, Y+3	; 0x03
    2f16:	9c 81       	ldd	r25, Y+4	; 0x04
    2f18:	01 97       	sbiw	r24, 0x01	; 1
    2f1a:	9c 83       	std	Y+4, r25	; 0x04
    2f1c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    2f1e:	eb 81       	ldd	r30, Y+3	; 0x03
    2f20:	fc 81       	ldd	r31, Y+4	; 0x04
    2f22:	88 e1       	ldi	r24, 0x18	; 24
    2f24:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f26:	8b 81       	ldd	r24, Y+3	; 0x03
    2f28:	9c 81       	ldd	r25, Y+4	; 0x04
    2f2a:	01 97       	sbiw	r24, 0x01	; 1
    2f2c:	9c 83       	std	Y+4, r25	; 0x04
    2f2e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    2f30:	eb 81       	ldd	r30, Y+3	; 0x03
    2f32:	fc 81       	ldd	r31, Y+4	; 0x04
    2f34:	89 e1       	ldi	r24, 0x19	; 25
    2f36:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f38:	8b 81       	ldd	r24, Y+3	; 0x03
    2f3a:	9c 81       	ldd	r25, Y+4	; 0x04
    2f3c:	01 97       	sbiw	r24, 0x01	; 1
    2f3e:	9c 83       	std	Y+4, r25	; 0x04
    2f40:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    2f42:	eb 81       	ldd	r30, Y+3	; 0x03
    2f44:	fc 81       	ldd	r31, Y+4	; 0x04
    2f46:	80 e2       	ldi	r24, 0x20	; 32
    2f48:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f4a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f4c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f4e:	01 97       	sbiw	r24, 0x01	; 1
    2f50:	9c 83       	std	Y+4, r25	; 0x04
    2f52:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    2f54:	eb 81       	ldd	r30, Y+3	; 0x03
    2f56:	fc 81       	ldd	r31, Y+4	; 0x04
    2f58:	81 e2       	ldi	r24, 0x21	; 33
    2f5a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f5c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f5e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f60:	01 97       	sbiw	r24, 0x01	; 1
    2f62:	9c 83       	std	Y+4, r25	; 0x04
    2f64:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    2f66:	eb 81       	ldd	r30, Y+3	; 0x03
    2f68:	fc 81       	ldd	r31, Y+4	; 0x04
    2f6a:	82 e2       	ldi	r24, 0x22	; 34
    2f6c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f6e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f70:	9c 81       	ldd	r25, Y+4	; 0x04
    2f72:	01 97       	sbiw	r24, 0x01	; 1
    2f74:	9c 83       	std	Y+4, r25	; 0x04
    2f76:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    2f78:	eb 81       	ldd	r30, Y+3	; 0x03
    2f7a:	fc 81       	ldd	r31, Y+4	; 0x04
    2f7c:	83 e2       	ldi	r24, 0x23	; 35
    2f7e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f80:	8b 81       	ldd	r24, Y+3	; 0x03
    2f82:	9c 81       	ldd	r25, Y+4	; 0x04
    2f84:	01 97       	sbiw	r24, 0x01	; 1
    2f86:	9c 83       	std	Y+4, r25	; 0x04
    2f88:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    2f8a:	8f 81       	ldd	r24, Y+7	; 0x07
    2f8c:	98 85       	ldd	r25, Y+8	; 0x08
    2f8e:	9a 83       	std	Y+2, r25	; 0x02
    2f90:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2f92:	89 81       	ldd	r24, Y+1	; 0x01
    2f94:	eb 81       	ldd	r30, Y+3	; 0x03
    2f96:	fc 81       	ldd	r31, Y+4	; 0x04
    2f98:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f9a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f9c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f9e:	01 97       	sbiw	r24, 0x01	; 1
    2fa0:	9c 83       	std	Y+4, r25	; 0x04
    2fa2:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2fa4:	89 81       	ldd	r24, Y+1	; 0x01
    2fa6:	9a 81       	ldd	r25, Y+2	; 0x02
    2fa8:	89 2f       	mov	r24, r25
    2faa:	99 27       	eor	r25, r25
    2fac:	9a 83       	std	Y+2, r25	; 0x02
    2fae:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2fb0:	89 81       	ldd	r24, Y+1	; 0x01
    2fb2:	eb 81       	ldd	r30, Y+3	; 0x03
    2fb4:	fc 81       	ldd	r31, Y+4	; 0x04
    2fb6:	80 83       	st	Z, r24
	pxTopOfStack--;
    2fb8:	8b 81       	ldd	r24, Y+3	; 0x03
    2fba:	9c 81       	ldd	r25, Y+4	; 0x04
    2fbc:	01 97       	sbiw	r24, 0x01	; 1
    2fbe:	9c 83       	std	Y+4, r25	; 0x04
    2fc0:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    2fc2:	eb 81       	ldd	r30, Y+3	; 0x03
    2fc4:	fc 81       	ldd	r31, Y+4	; 0x04
    2fc6:	86 e2       	ldi	r24, 0x26	; 38
    2fc8:	80 83       	st	Z, r24
	pxTopOfStack--;
    2fca:	8b 81       	ldd	r24, Y+3	; 0x03
    2fcc:	9c 81       	ldd	r25, Y+4	; 0x04
    2fce:	01 97       	sbiw	r24, 0x01	; 1
    2fd0:	9c 83       	std	Y+4, r25	; 0x04
    2fd2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    2fd4:	eb 81       	ldd	r30, Y+3	; 0x03
    2fd6:	fc 81       	ldd	r31, Y+4	; 0x04
    2fd8:	87 e2       	ldi	r24, 0x27	; 39
    2fda:	80 83       	st	Z, r24
	pxTopOfStack--;
    2fdc:	8b 81       	ldd	r24, Y+3	; 0x03
    2fde:	9c 81       	ldd	r25, Y+4	; 0x04
    2fe0:	01 97       	sbiw	r24, 0x01	; 1
    2fe2:	9c 83       	std	Y+4, r25	; 0x04
    2fe4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    2fe6:	eb 81       	ldd	r30, Y+3	; 0x03
    2fe8:	fc 81       	ldd	r31, Y+4	; 0x04
    2fea:	88 e2       	ldi	r24, 0x28	; 40
    2fec:	80 83       	st	Z, r24
	pxTopOfStack--;
    2fee:	8b 81       	ldd	r24, Y+3	; 0x03
    2ff0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ff2:	01 97       	sbiw	r24, 0x01	; 1
    2ff4:	9c 83       	std	Y+4, r25	; 0x04
    2ff6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    2ff8:	eb 81       	ldd	r30, Y+3	; 0x03
    2ffa:	fc 81       	ldd	r31, Y+4	; 0x04
    2ffc:	89 e2       	ldi	r24, 0x29	; 41
    2ffe:	80 83       	st	Z, r24
	pxTopOfStack--;
    3000:	8b 81       	ldd	r24, Y+3	; 0x03
    3002:	9c 81       	ldd	r25, Y+4	; 0x04
    3004:	01 97       	sbiw	r24, 0x01	; 1
    3006:	9c 83       	std	Y+4, r25	; 0x04
    3008:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    300a:	eb 81       	ldd	r30, Y+3	; 0x03
    300c:	fc 81       	ldd	r31, Y+4	; 0x04
    300e:	80 e3       	ldi	r24, 0x30	; 48
    3010:	80 83       	st	Z, r24
	pxTopOfStack--;
    3012:	8b 81       	ldd	r24, Y+3	; 0x03
    3014:	9c 81       	ldd	r25, Y+4	; 0x04
    3016:	01 97       	sbiw	r24, 0x01	; 1
    3018:	9c 83       	std	Y+4, r25	; 0x04
    301a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    301c:	eb 81       	ldd	r30, Y+3	; 0x03
    301e:	fc 81       	ldd	r31, Y+4	; 0x04
    3020:	81 e3       	ldi	r24, 0x31	; 49
    3022:	80 83       	st	Z, r24
	pxTopOfStack--;
    3024:	8b 81       	ldd	r24, Y+3	; 0x03
    3026:	9c 81       	ldd	r25, Y+4	; 0x04
    3028:	01 97       	sbiw	r24, 0x01	; 1
    302a:	9c 83       	std	Y+4, r25	; 0x04
    302c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    302e:	8b 81       	ldd	r24, Y+3	; 0x03
    3030:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3032:	28 96       	adiw	r28, 0x08	; 8
    3034:	0f b6       	in	r0, 0x3f	; 63
    3036:	f8 94       	cli
    3038:	de bf       	out	0x3e, r29	; 62
    303a:	0f be       	out	0x3f, r0	; 63
    303c:	cd bf       	out	0x3d, r28	; 61
    303e:	cf 91       	pop	r28
    3040:	df 91       	pop	r29
    3042:	08 95       	ret

00003044 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    3044:	df 93       	push	r29
    3046:	cf 93       	push	r28
    3048:	cd b7       	in	r28, 0x3d	; 61
    304a:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    304c:	0e 94 12 19 	call	0x3224	; 0x3224 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3050:	a0 91 ec 00 	lds	r26, 0x00EC
    3054:	b0 91 ed 00 	lds	r27, 0x00ED
    3058:	cd 91       	ld	r28, X+
    305a:	cd bf       	out	0x3d, r28	; 61
    305c:	dd 91       	ld	r29, X+
    305e:	de bf       	out	0x3e, r29	; 62
    3060:	ff 91       	pop	r31
    3062:	ef 91       	pop	r30
    3064:	df 91       	pop	r29
    3066:	cf 91       	pop	r28
    3068:	bf 91       	pop	r27
    306a:	af 91       	pop	r26
    306c:	9f 91       	pop	r25
    306e:	8f 91       	pop	r24
    3070:	7f 91       	pop	r23
    3072:	6f 91       	pop	r22
    3074:	5f 91       	pop	r21
    3076:	4f 91       	pop	r20
    3078:	3f 91       	pop	r19
    307a:	2f 91       	pop	r18
    307c:	1f 91       	pop	r17
    307e:	0f 91       	pop	r16
    3080:	ff 90       	pop	r15
    3082:	ef 90       	pop	r14
    3084:	df 90       	pop	r13
    3086:	cf 90       	pop	r12
    3088:	bf 90       	pop	r11
    308a:	af 90       	pop	r10
    308c:	9f 90       	pop	r9
    308e:	8f 90       	pop	r8
    3090:	7f 90       	pop	r7
    3092:	6f 90       	pop	r6
    3094:	5f 90       	pop	r5
    3096:	4f 90       	pop	r4
    3098:	3f 90       	pop	r3
    309a:	2f 90       	pop	r2
    309c:	1f 90       	pop	r1
    309e:	0f 90       	pop	r0
    30a0:	0f be       	out	0x3f, r0	; 63
    30a2:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    30a4:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    30a6:	81 e0       	ldi	r24, 0x01	; 1
}
    30a8:	cf 91       	pop	r28
    30aa:	df 91       	pop	r29
    30ac:	08 95       	ret

000030ae <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    30ae:	df 93       	push	r29
    30b0:	cf 93       	push	r28
    30b2:	cd b7       	in	r28, 0x3d	; 61
    30b4:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    30b6:	cf 91       	pop	r28
    30b8:	df 91       	pop	r29
    30ba:	08 95       	ret

000030bc <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    30bc:	0f 92       	push	r0
    30be:	0f b6       	in	r0, 0x3f	; 63
    30c0:	f8 94       	cli
    30c2:	0f 92       	push	r0
    30c4:	1f 92       	push	r1
    30c6:	11 24       	eor	r1, r1
    30c8:	2f 92       	push	r2
    30ca:	3f 92       	push	r3
    30cc:	4f 92       	push	r4
    30ce:	5f 92       	push	r5
    30d0:	6f 92       	push	r6
    30d2:	7f 92       	push	r7
    30d4:	8f 92       	push	r8
    30d6:	9f 92       	push	r9
    30d8:	af 92       	push	r10
    30da:	bf 92       	push	r11
    30dc:	cf 92       	push	r12
    30de:	df 92       	push	r13
    30e0:	ef 92       	push	r14
    30e2:	ff 92       	push	r15
    30e4:	0f 93       	push	r16
    30e6:	1f 93       	push	r17
    30e8:	2f 93       	push	r18
    30ea:	3f 93       	push	r19
    30ec:	4f 93       	push	r20
    30ee:	5f 93       	push	r21
    30f0:	6f 93       	push	r22
    30f2:	7f 93       	push	r23
    30f4:	8f 93       	push	r24
    30f6:	9f 93       	push	r25
    30f8:	af 93       	push	r26
    30fa:	bf 93       	push	r27
    30fc:	cf 93       	push	r28
    30fe:	df 93       	push	r29
    3100:	ef 93       	push	r30
    3102:	ff 93       	push	r31
    3104:	a0 91 ec 00 	lds	r26, 0x00EC
    3108:	b0 91 ed 00 	lds	r27, 0x00ED
    310c:	0d b6       	in	r0, 0x3d	; 61
    310e:	0d 92       	st	X+, r0
    3110:	0e b6       	in	r0, 0x3e	; 62
    3112:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3114:	0e 94 c3 22 	call	0x4586	; 0x4586 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3118:	a0 91 ec 00 	lds	r26, 0x00EC
    311c:	b0 91 ed 00 	lds	r27, 0x00ED
    3120:	cd 91       	ld	r28, X+
    3122:	cd bf       	out	0x3d, r28	; 61
    3124:	dd 91       	ld	r29, X+
    3126:	de bf       	out	0x3e, r29	; 62
    3128:	ff 91       	pop	r31
    312a:	ef 91       	pop	r30
    312c:	df 91       	pop	r29
    312e:	cf 91       	pop	r28
    3130:	bf 91       	pop	r27
    3132:	af 91       	pop	r26
    3134:	9f 91       	pop	r25
    3136:	8f 91       	pop	r24
    3138:	7f 91       	pop	r23
    313a:	6f 91       	pop	r22
    313c:	5f 91       	pop	r21
    313e:	4f 91       	pop	r20
    3140:	3f 91       	pop	r19
    3142:	2f 91       	pop	r18
    3144:	1f 91       	pop	r17
    3146:	0f 91       	pop	r16
    3148:	ff 90       	pop	r15
    314a:	ef 90       	pop	r14
    314c:	df 90       	pop	r13
    314e:	cf 90       	pop	r12
    3150:	bf 90       	pop	r11
    3152:	af 90       	pop	r10
    3154:	9f 90       	pop	r9
    3156:	8f 90       	pop	r8
    3158:	7f 90       	pop	r7
    315a:	6f 90       	pop	r6
    315c:	5f 90       	pop	r5
    315e:	4f 90       	pop	r4
    3160:	3f 90       	pop	r3
    3162:	2f 90       	pop	r2
    3164:	1f 90       	pop	r1
    3166:	0f 90       	pop	r0
    3168:	0f be       	out	0x3f, r0	; 63
    316a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    316c:	08 95       	ret

0000316e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    316e:	0f 92       	push	r0
    3170:	0f b6       	in	r0, 0x3f	; 63
    3172:	f8 94       	cli
    3174:	0f 92       	push	r0
    3176:	1f 92       	push	r1
    3178:	11 24       	eor	r1, r1
    317a:	2f 92       	push	r2
    317c:	3f 92       	push	r3
    317e:	4f 92       	push	r4
    3180:	5f 92       	push	r5
    3182:	6f 92       	push	r6
    3184:	7f 92       	push	r7
    3186:	8f 92       	push	r8
    3188:	9f 92       	push	r9
    318a:	af 92       	push	r10
    318c:	bf 92       	push	r11
    318e:	cf 92       	push	r12
    3190:	df 92       	push	r13
    3192:	ef 92       	push	r14
    3194:	ff 92       	push	r15
    3196:	0f 93       	push	r16
    3198:	1f 93       	push	r17
    319a:	2f 93       	push	r18
    319c:	3f 93       	push	r19
    319e:	4f 93       	push	r20
    31a0:	5f 93       	push	r21
    31a2:	6f 93       	push	r22
    31a4:	7f 93       	push	r23
    31a6:	8f 93       	push	r24
    31a8:	9f 93       	push	r25
    31aa:	af 93       	push	r26
    31ac:	bf 93       	push	r27
    31ae:	cf 93       	push	r28
    31b0:	df 93       	push	r29
    31b2:	ef 93       	push	r30
    31b4:	ff 93       	push	r31
    31b6:	a0 91 ec 00 	lds	r26, 0x00EC
    31ba:	b0 91 ed 00 	lds	r27, 0x00ED
    31be:	0d b6       	in	r0, 0x3d	; 61
    31c0:	0d 92       	st	X+, r0
    31c2:	0e b6       	in	r0, 0x3e	; 62
    31c4:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    31c6:	0e 94 ee 21 	call	0x43dc	; 0x43dc <vTaskIncrementTick>
	vTaskSwitchContext();
    31ca:	0e 94 c3 22 	call	0x4586	; 0x4586 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    31ce:	a0 91 ec 00 	lds	r26, 0x00EC
    31d2:	b0 91 ed 00 	lds	r27, 0x00ED
    31d6:	cd 91       	ld	r28, X+
    31d8:	cd bf       	out	0x3d, r28	; 61
    31da:	dd 91       	ld	r29, X+
    31dc:	de bf       	out	0x3e, r29	; 62
    31de:	ff 91       	pop	r31
    31e0:	ef 91       	pop	r30
    31e2:	df 91       	pop	r29
    31e4:	cf 91       	pop	r28
    31e6:	bf 91       	pop	r27
    31e8:	af 91       	pop	r26
    31ea:	9f 91       	pop	r25
    31ec:	8f 91       	pop	r24
    31ee:	7f 91       	pop	r23
    31f0:	6f 91       	pop	r22
    31f2:	5f 91       	pop	r21
    31f4:	4f 91       	pop	r20
    31f6:	3f 91       	pop	r19
    31f8:	2f 91       	pop	r18
    31fa:	1f 91       	pop	r17
    31fc:	0f 91       	pop	r16
    31fe:	ff 90       	pop	r15
    3200:	ef 90       	pop	r14
    3202:	df 90       	pop	r13
    3204:	cf 90       	pop	r12
    3206:	bf 90       	pop	r11
    3208:	af 90       	pop	r10
    320a:	9f 90       	pop	r9
    320c:	8f 90       	pop	r8
    320e:	7f 90       	pop	r7
    3210:	6f 90       	pop	r6
    3212:	5f 90       	pop	r5
    3214:	4f 90       	pop	r4
    3216:	3f 90       	pop	r3
    3218:	2f 90       	pop	r2
    321a:	1f 90       	pop	r1
    321c:	0f 90       	pop	r0
    321e:	0f be       	out	0x3f, r0	; 63
    3220:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3222:	08 95       	ret

00003224 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    3224:	df 93       	push	r29
    3226:	cf 93       	push	r28
    3228:	00 d0       	rcall	.+0      	; 0x322a <prvSetupTimerInterrupt+0x6>
    322a:	00 d0       	rcall	.+0      	; 0x322c <prvSetupTimerInterrupt+0x8>
    322c:	00 d0       	rcall	.+0      	; 0x322e <prvSetupTimerInterrupt+0xa>
    322e:	cd b7       	in	r28, 0x3d	; 61
    3230:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    3232:	80 e8       	ldi	r24, 0x80	; 128
    3234:	98 e3       	ldi	r25, 0x38	; 56
    3236:	a1 e0       	ldi	r26, 0x01	; 1
    3238:	b0 e0       	ldi	r27, 0x00	; 0
    323a:	8b 83       	std	Y+3, r24	; 0x03
    323c:	9c 83       	std	Y+4, r25	; 0x04
    323e:	ad 83       	std	Y+5, r26	; 0x05
    3240:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    3242:	8b 81       	ldd	r24, Y+3	; 0x03
    3244:	9c 81       	ldd	r25, Y+4	; 0x04
    3246:	ad 81       	ldd	r26, Y+5	; 0x05
    3248:	be 81       	ldd	r27, Y+6	; 0x06
    324a:	68 94       	set
    324c:	15 f8       	bld	r1, 5
    324e:	b6 95       	lsr	r27
    3250:	a7 95       	ror	r26
    3252:	97 95       	ror	r25
    3254:	87 95       	ror	r24
    3256:	16 94       	lsr	r1
    3258:	d1 f7       	brne	.-12     	; 0x324e <prvSetupTimerInterrupt+0x2a>
    325a:	8b 83       	std	Y+3, r24	; 0x03
    325c:	9c 83       	std	Y+4, r25	; 0x04
    325e:	ad 83       	std	Y+5, r26	; 0x05
    3260:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    3262:	8b 81       	ldd	r24, Y+3	; 0x03
    3264:	9c 81       	ldd	r25, Y+4	; 0x04
    3266:	ad 81       	ldd	r26, Y+5	; 0x05
    3268:	be 81       	ldd	r27, Y+6	; 0x06
    326a:	01 97       	sbiw	r24, 0x01	; 1
    326c:	a1 09       	sbc	r26, r1
    326e:	b1 09       	sbc	r27, r1
    3270:	8b 83       	std	Y+3, r24	; 0x03
    3272:	9c 83       	std	Y+4, r25	; 0x04
    3274:	ad 83       	std	Y+5, r26	; 0x05
    3276:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    3278:	8b 81       	ldd	r24, Y+3	; 0x03
    327a:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    327c:	8b 81       	ldd	r24, Y+3	; 0x03
    327e:	9c 81       	ldd	r25, Y+4	; 0x04
    3280:	ad 81       	ldd	r26, Y+5	; 0x05
    3282:	be 81       	ldd	r27, Y+6	; 0x06
    3284:	89 2f       	mov	r24, r25
    3286:	9a 2f       	mov	r25, r26
    3288:	ab 2f       	mov	r26, r27
    328a:	bb 27       	eor	r27, r27
    328c:	8b 83       	std	Y+3, r24	; 0x03
    328e:	9c 83       	std	Y+4, r25	; 0x04
    3290:	ad 83       	std	Y+5, r26	; 0x05
    3292:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    3294:	8b 81       	ldd	r24, Y+3	; 0x03
    3296:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    3298:	eb e4       	ldi	r30, 0x4B	; 75
    329a:	f0 e0       	ldi	r31, 0x00	; 0
    329c:	8a 81       	ldd	r24, Y+2	; 0x02
    329e:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    32a0:	ea e4       	ldi	r30, 0x4A	; 74
    32a2:	f0 e0       	ldi	r31, 0x00	; 0
    32a4:	89 81       	ldd	r24, Y+1	; 0x01
    32a6:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    32a8:	8b e0       	ldi	r24, 0x0B	; 11
    32aa:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    32ac:	ee e4       	ldi	r30, 0x4E	; 78
    32ae:	f0 e0       	ldi	r31, 0x00	; 0
    32b0:	89 81       	ldd	r24, Y+1	; 0x01
    32b2:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    32b4:	e9 e5       	ldi	r30, 0x59	; 89
    32b6:	f0 e0       	ldi	r31, 0x00	; 0
    32b8:	80 81       	ld	r24, Z
    32ba:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    32bc:	89 81       	ldd	r24, Y+1	; 0x01
    32be:	80 61       	ori	r24, 0x10	; 16
    32c0:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    32c2:	e9 e5       	ldi	r30, 0x59	; 89
    32c4:	f0 e0       	ldi	r31, 0x00	; 0
    32c6:	89 81       	ldd	r24, Y+1	; 0x01
    32c8:	80 83       	st	Z, r24
}
    32ca:	26 96       	adiw	r28, 0x06	; 6
    32cc:	0f b6       	in	r0, 0x3f	; 63
    32ce:	f8 94       	cli
    32d0:	de bf       	out	0x3e, r29	; 62
    32d2:	0f be       	out	0x3f, r0	; 63
    32d4:	cd bf       	out	0x3d, r28	; 61
    32d6:	cf 91       	pop	r28
    32d8:	df 91       	pop	r29
    32da:	08 95       	ret

000032dc <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    32dc:	0e 94 b7 18 	call	0x316e	; 0x316e <vPortYieldFromTick>
		asm volatile ( "reti" );
    32e0:	18 95       	reti

000032e2 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    32e2:	df 93       	push	r29
    32e4:	cf 93       	push	r28
    32e6:	cd b7       	in	r28, 0x3d	; 61
    32e8:	de b7       	in	r29, 0x3e	; 62
    32ea:	28 97       	sbiw	r28, 0x08	; 8
    32ec:	0f b6       	in	r0, 0x3f	; 63
    32ee:	f8 94       	cli
    32f0:	de bf       	out	0x3e, r29	; 62
    32f2:	0f be       	out	0x3f, r0	; 63
    32f4:	cd bf       	out	0x3d, r28	; 61
    32f6:	8f 83       	std	Y+7, r24	; 0x07
    32f8:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    32fa:	1a 82       	std	Y+2, r1	; 0x02
    32fc:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    32fe:	8f 81       	ldd	r24, Y+7	; 0x07
    3300:	88 23       	and	r24, r24
    3302:	09 f4       	brne	.+2      	; 0x3306 <xQueueCreate+0x24>
    3304:	8c c0       	rjmp	.+280    	; 0x341e <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    3306:	8f e1       	ldi	r24, 0x1F	; 31
    3308:	90 e0       	ldi	r25, 0x00	; 0
    330a:	0e 94 31 15 	call	0x2a62	; 0x2a62 <pvPortMalloc>
    330e:	9e 83       	std	Y+6, r25	; 0x06
    3310:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    3312:	8d 81       	ldd	r24, Y+5	; 0x05
    3314:	9e 81       	ldd	r25, Y+6	; 0x06
    3316:	00 97       	sbiw	r24, 0x00	; 0
    3318:	09 f4       	brne	.+2      	; 0x331c <xQueueCreate+0x3a>
    331a:	81 c0       	rjmp	.+258    	; 0x341e <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    331c:	8f 81       	ldd	r24, Y+7	; 0x07
    331e:	28 2f       	mov	r18, r24
    3320:	30 e0       	ldi	r19, 0x00	; 0
    3322:	88 85       	ldd	r24, Y+8	; 0x08
    3324:	88 2f       	mov	r24, r24
    3326:	90 e0       	ldi	r25, 0x00	; 0
    3328:	ac 01       	movw	r20, r24
    332a:	24 9f       	mul	r18, r20
    332c:	c0 01       	movw	r24, r0
    332e:	25 9f       	mul	r18, r21
    3330:	90 0d       	add	r25, r0
    3332:	34 9f       	mul	r19, r20
    3334:	90 0d       	add	r25, r0
    3336:	11 24       	eor	r1, r1
    3338:	01 96       	adiw	r24, 0x01	; 1
    333a:	9c 83       	std	Y+4, r25	; 0x04
    333c:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    333e:	8b 81       	ldd	r24, Y+3	; 0x03
    3340:	9c 81       	ldd	r25, Y+4	; 0x04
    3342:	0e 94 31 15 	call	0x2a62	; 0x2a62 <pvPortMalloc>
    3346:	ed 81       	ldd	r30, Y+5	; 0x05
    3348:	fe 81       	ldd	r31, Y+6	; 0x06
    334a:	91 83       	std	Z+1, r25	; 0x01
    334c:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    334e:	ed 81       	ldd	r30, Y+5	; 0x05
    3350:	fe 81       	ldd	r31, Y+6	; 0x06
    3352:	80 81       	ld	r24, Z
    3354:	91 81       	ldd	r25, Z+1	; 0x01
    3356:	00 97       	sbiw	r24, 0x00	; 0
    3358:	09 f4       	brne	.+2      	; 0x335c <xQueueCreate+0x7a>
    335a:	5d c0       	rjmp	.+186    	; 0x3416 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    335c:	ed 81       	ldd	r30, Y+5	; 0x05
    335e:	fe 81       	ldd	r31, Y+6	; 0x06
    3360:	40 81       	ld	r20, Z
    3362:	51 81       	ldd	r21, Z+1	; 0x01
    3364:	8f 81       	ldd	r24, Y+7	; 0x07
    3366:	28 2f       	mov	r18, r24
    3368:	30 e0       	ldi	r19, 0x00	; 0
    336a:	88 85       	ldd	r24, Y+8	; 0x08
    336c:	88 2f       	mov	r24, r24
    336e:	90 e0       	ldi	r25, 0x00	; 0
    3370:	bc 01       	movw	r22, r24
    3372:	26 9f       	mul	r18, r22
    3374:	c0 01       	movw	r24, r0
    3376:	27 9f       	mul	r18, r23
    3378:	90 0d       	add	r25, r0
    337a:	36 9f       	mul	r19, r22
    337c:	90 0d       	add	r25, r0
    337e:	11 24       	eor	r1, r1
    3380:	84 0f       	add	r24, r20
    3382:	95 1f       	adc	r25, r21
    3384:	ed 81       	ldd	r30, Y+5	; 0x05
    3386:	fe 81       	ldd	r31, Y+6	; 0x06
    3388:	93 83       	std	Z+3, r25	; 0x03
    338a:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    338c:	ed 81       	ldd	r30, Y+5	; 0x05
    338e:	fe 81       	ldd	r31, Y+6	; 0x06
    3390:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    3392:	ed 81       	ldd	r30, Y+5	; 0x05
    3394:	fe 81       	ldd	r31, Y+6	; 0x06
    3396:	80 81       	ld	r24, Z
    3398:	91 81       	ldd	r25, Z+1	; 0x01
    339a:	ed 81       	ldd	r30, Y+5	; 0x05
    339c:	fe 81       	ldd	r31, Y+6	; 0x06
    339e:	95 83       	std	Z+5, r25	; 0x05
    33a0:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    33a2:	ed 81       	ldd	r30, Y+5	; 0x05
    33a4:	fe 81       	ldd	r31, Y+6	; 0x06
    33a6:	40 81       	ld	r20, Z
    33a8:	51 81       	ldd	r21, Z+1	; 0x01
    33aa:	8f 81       	ldd	r24, Y+7	; 0x07
    33ac:	88 2f       	mov	r24, r24
    33ae:	90 e0       	ldi	r25, 0x00	; 0
    33b0:	9c 01       	movw	r18, r24
    33b2:	21 50       	subi	r18, 0x01	; 1
    33b4:	30 40       	sbci	r19, 0x00	; 0
    33b6:	88 85       	ldd	r24, Y+8	; 0x08
    33b8:	88 2f       	mov	r24, r24
    33ba:	90 e0       	ldi	r25, 0x00	; 0
    33bc:	bc 01       	movw	r22, r24
    33be:	26 9f       	mul	r18, r22
    33c0:	c0 01       	movw	r24, r0
    33c2:	27 9f       	mul	r18, r23
    33c4:	90 0d       	add	r25, r0
    33c6:	36 9f       	mul	r19, r22
    33c8:	90 0d       	add	r25, r0
    33ca:	11 24       	eor	r1, r1
    33cc:	84 0f       	add	r24, r20
    33ce:	95 1f       	adc	r25, r21
    33d0:	ed 81       	ldd	r30, Y+5	; 0x05
    33d2:	fe 81       	ldd	r31, Y+6	; 0x06
    33d4:	97 83       	std	Z+7, r25	; 0x07
    33d6:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    33d8:	ed 81       	ldd	r30, Y+5	; 0x05
    33da:	fe 81       	ldd	r31, Y+6	; 0x06
    33dc:	8f 81       	ldd	r24, Y+7	; 0x07
    33de:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    33e0:	ed 81       	ldd	r30, Y+5	; 0x05
    33e2:	fe 81       	ldd	r31, Y+6	; 0x06
    33e4:	88 85       	ldd	r24, Y+8	; 0x08
    33e6:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    33e8:	ed 81       	ldd	r30, Y+5	; 0x05
    33ea:	fe 81       	ldd	r31, Y+6	; 0x06
    33ec:	8f ef       	ldi	r24, 0xFF	; 255
    33ee:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    33f0:	ed 81       	ldd	r30, Y+5	; 0x05
    33f2:	fe 81       	ldd	r31, Y+6	; 0x06
    33f4:	8f ef       	ldi	r24, 0xFF	; 255
    33f6:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    33f8:	8d 81       	ldd	r24, Y+5	; 0x05
    33fa:	9e 81       	ldd	r25, Y+6	; 0x06
    33fc:	08 96       	adiw	r24, 0x08	; 8
    33fe:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    3402:	8d 81       	ldd	r24, Y+5	; 0x05
    3404:	9e 81       	ldd	r25, Y+6	; 0x06
    3406:	41 96       	adiw	r24, 0x11	; 17
    3408:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    340c:	8d 81       	ldd	r24, Y+5	; 0x05
    340e:	9e 81       	ldd	r25, Y+6	; 0x06
    3410:	9a 83       	std	Y+2, r25	; 0x02
    3412:	89 83       	std	Y+1, r24	; 0x01
    3414:	04 c0       	rjmp	.+8      	; 0x341e <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    3416:	8d 81       	ldd	r24, Y+5	; 0x05
    3418:	9e 81       	ldd	r25, Y+6	; 0x06
    341a:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    341e:	89 81       	ldd	r24, Y+1	; 0x01
    3420:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3422:	28 96       	adiw	r28, 0x08	; 8
    3424:	0f b6       	in	r0, 0x3f	; 63
    3426:	f8 94       	cli
    3428:	de bf       	out	0x3e, r29	; 62
    342a:	0f be       	out	0x3f, r0	; 63
    342c:	cd bf       	out	0x3d, r28	; 61
    342e:	cf 91       	pop	r28
    3430:	df 91       	pop	r29
    3432:	08 95       	ret

00003434 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
    3434:	df 93       	push	r29
    3436:	cf 93       	push	r28
    3438:	00 d0       	rcall	.+0      	; 0x343a <xQueueCreateMutex+0x6>
    343a:	cd b7       	in	r28, 0x3d	; 61
    343c:	de b7       	in	r29, 0x3e	; 62
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    343e:	8f e1       	ldi	r24, 0x1F	; 31
    3440:	90 e0       	ldi	r25, 0x00	; 0
    3442:	0e 94 31 15 	call	0x2a62	; 0x2a62 <pvPortMalloc>
    3446:	9a 83       	std	Y+2, r25	; 0x02
    3448:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    344a:	89 81       	ldd	r24, Y+1	; 0x01
    344c:	9a 81       	ldd	r25, Y+2	; 0x02
    344e:	00 97       	sbiw	r24, 0x00	; 0
    3450:	a9 f1       	breq	.+106    	; 0x34bc <xQueueCreateMutex+0x88>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    3452:	e9 81       	ldd	r30, Y+1	; 0x01
    3454:	fa 81       	ldd	r31, Y+2	; 0x02
    3456:	13 82       	std	Z+3, r1	; 0x03
    3458:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    345a:	e9 81       	ldd	r30, Y+1	; 0x01
    345c:	fa 81       	ldd	r31, Y+2	; 0x02
    345e:	11 82       	std	Z+1, r1	; 0x01
    3460:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    3462:	e9 81       	ldd	r30, Y+1	; 0x01
    3464:	fa 81       	ldd	r31, Y+2	; 0x02
    3466:	15 82       	std	Z+5, r1	; 0x05
    3468:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
    346a:	e9 81       	ldd	r30, Y+1	; 0x01
    346c:	fa 81       	ldd	r31, Y+2	; 0x02
    346e:	17 82       	std	Z+7, r1	; 0x07
    3470:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    3472:	e9 81       	ldd	r30, Y+1	; 0x01
    3474:	fa 81       	ldd	r31, Y+2	; 0x02
    3476:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    3478:	e9 81       	ldd	r30, Y+1	; 0x01
    347a:	fa 81       	ldd	r31, Y+2	; 0x02
    347c:	81 e0       	ldi	r24, 0x01	; 1
    347e:	83 8f       	std	Z+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    3480:	e9 81       	ldd	r30, Y+1	; 0x01
    3482:	fa 81       	ldd	r31, Y+2	; 0x02
    3484:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    3486:	e9 81       	ldd	r30, Y+1	; 0x01
    3488:	fa 81       	ldd	r31, Y+2	; 0x02
    348a:	8f ef       	ldi	r24, 0xFF	; 255
    348c:	85 8f       	std	Z+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    348e:	e9 81       	ldd	r30, Y+1	; 0x01
    3490:	fa 81       	ldd	r31, Y+2	; 0x02
    3492:	8f ef       	ldi	r24, 0xFF	; 255
    3494:	86 8f       	std	Z+30, r24	; 0x1e

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    3496:	89 81       	ldd	r24, Y+1	; 0x01
    3498:	9a 81       	ldd	r25, Y+2	; 0x02
    349a:	08 96       	adiw	r24, 0x08	; 8
    349c:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    34a0:	89 81       	ldd	r24, Y+1	; 0x01
    34a2:	9a 81       	ldd	r25, Y+2	; 0x02
    34a4:	41 96       	adiw	r24, 0x11	; 17
    34a6:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <vListInitialise>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    34aa:	89 81       	ldd	r24, Y+1	; 0x01
    34ac:	9a 81       	ldd	r25, Y+2	; 0x02
    34ae:	60 e0       	ldi	r22, 0x00	; 0
    34b0:	70 e0       	ldi	r23, 0x00	; 0
    34b2:	40 e0       	ldi	r20, 0x00	; 0
    34b4:	50 e0       	ldi	r21, 0x00	; 0
    34b6:	20 e0       	ldi	r18, 0x00	; 0
    34b8:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
    34bc:	89 81       	ldd	r24, Y+1	; 0x01
    34be:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    34c0:	0f 90       	pop	r0
    34c2:	0f 90       	pop	r0
    34c4:	cf 91       	pop	r28
    34c6:	df 91       	pop	r29
    34c8:	08 95       	ret

000034ca <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if configUSE_RECURSIVE_MUTEXES == 1

	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle pxMutex )
	{
    34ca:	0f 93       	push	r16
    34cc:	1f 93       	push	r17
    34ce:	df 93       	push	r29
    34d0:	cf 93       	push	r28
    34d2:	00 d0       	rcall	.+0      	; 0x34d4 <xQueueGiveMutexRecursive+0xa>
    34d4:	0f 92       	push	r0
    34d6:	cd b7       	in	r28, 0x3d	; 61
    34d8:	de b7       	in	r29, 0x3e	; 62
    34da:	9b 83       	std	Y+3, r25	; 0x03
    34dc:	8a 83       	std	Y+2, r24	; 0x02
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
    34de:	ea 81       	ldd	r30, Y+2	; 0x02
    34e0:	fb 81       	ldd	r31, Y+3	; 0x03
    34e2:	02 81       	ldd	r16, Z+2	; 0x02
    34e4:	13 81       	ldd	r17, Z+3	; 0x03
    34e6:	0e 94 d6 25 	call	0x4bac	; 0x4bac <xTaskGetCurrentTaskHandle>
    34ea:	08 17       	cp	r16, r24
    34ec:	19 07       	cpc	r17, r25
    34ee:	d9 f4       	brne	.+54     	; 0x3526 <xQueueGiveMutexRecursive+0x5c>
			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->uxRecursiveCallCount )--;
    34f0:	ea 81       	ldd	r30, Y+2	; 0x02
    34f2:	fb 81       	ldd	r31, Y+3	; 0x03
    34f4:	86 81       	ldd	r24, Z+6	; 0x06
    34f6:	97 81       	ldd	r25, Z+7	; 0x07
    34f8:	01 97       	sbiw	r24, 0x01	; 1
    34fa:	ea 81       	ldd	r30, Y+2	; 0x02
    34fc:	fb 81       	ldd	r31, Y+3	; 0x03
    34fe:	97 83       	std	Z+7, r25	; 0x07
    3500:	86 83       	std	Z+6, r24	; 0x06

			/* Have we unwound the call count? */
			if( pxMutex->uxRecursiveCallCount == 0 )
    3502:	ea 81       	ldd	r30, Y+2	; 0x02
    3504:	fb 81       	ldd	r31, Y+3	; 0x03
    3506:	86 81       	ldd	r24, Z+6	; 0x06
    3508:	97 81       	ldd	r25, Z+7	; 0x07
    350a:	00 97       	sbiw	r24, 0x00	; 0
    350c:	49 f4       	brne	.+18     	; 0x3520 <xQueueGiveMutexRecursive+0x56>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
    350e:	8a 81       	ldd	r24, Y+2	; 0x02
    3510:	9b 81       	ldd	r25, Y+3	; 0x03
    3512:	60 e0       	ldi	r22, 0x00	; 0
    3514:	70 e0       	ldi	r23, 0x00	; 0
    3516:	40 e0       	ldi	r20, 0x00	; 0
    3518:	50 e0       	ldi	r21, 0x00	; 0
    351a:	20 e0       	ldi	r18, 0x00	; 0
    351c:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <xQueueGenericSend>
			}

			xReturn = pdPASS;
    3520:	81 e0       	ldi	r24, 0x01	; 1
    3522:	89 83       	std	Y+1, r24	; 0x01
    3524:	01 c0       	rjmp	.+2      	; 0x3528 <xQueueGiveMutexRecursive+0x5e>
		}
		else
		{
			/* We cannot give the mutex because we are not the holder. */
			xReturn = pdFAIL;
    3526:	19 82       	std	Y+1, r1	; 0x01

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
    3528:	89 81       	ldd	r24, Y+1	; 0x01
	}
    352a:	0f 90       	pop	r0
    352c:	0f 90       	pop	r0
    352e:	0f 90       	pop	r0
    3530:	cf 91       	pop	r28
    3532:	df 91       	pop	r29
    3534:	1f 91       	pop	r17
    3536:	0f 91       	pop	r16
    3538:	08 95       	ret

0000353a <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if configUSE_RECURSIVE_MUTEXES == 1

	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle pxMutex, portTickType xBlockTime )
	{
    353a:	0f 93       	push	r16
    353c:	1f 93       	push	r17
    353e:	df 93       	push	r29
    3540:	cf 93       	push	r28
    3542:	00 d0       	rcall	.+0      	; 0x3544 <xQueueTakeMutexRecursive+0xa>
    3544:	00 d0       	rcall	.+0      	; 0x3546 <xQueueTakeMutexRecursive+0xc>
    3546:	0f 92       	push	r0
    3548:	cd b7       	in	r28, 0x3d	; 61
    354a:	de b7       	in	r29, 0x3e	; 62
    354c:	9b 83       	std	Y+3, r25	; 0x03
    354e:	8a 83       	std	Y+2, r24	; 0x02
    3550:	7d 83       	std	Y+5, r23	; 0x05
    3552:	6c 83       	std	Y+4, r22	; 0x04
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
    3554:	ea 81       	ldd	r30, Y+2	; 0x02
    3556:	fb 81       	ldd	r31, Y+3	; 0x03
    3558:	02 81       	ldd	r16, Z+2	; 0x02
    355a:	13 81       	ldd	r17, Z+3	; 0x03
    355c:	0e 94 d6 25 	call	0x4bac	; 0x4bac <xTaskGetCurrentTaskHandle>
    3560:	08 17       	cp	r16, r24
    3562:	19 07       	cpc	r17, r25
    3564:	61 f4       	brne	.+24     	; 0x357e <xQueueTakeMutexRecursive+0x44>
		{
			( pxMutex->uxRecursiveCallCount )++;
    3566:	ea 81       	ldd	r30, Y+2	; 0x02
    3568:	fb 81       	ldd	r31, Y+3	; 0x03
    356a:	86 81       	ldd	r24, Z+6	; 0x06
    356c:	97 81       	ldd	r25, Z+7	; 0x07
    356e:	01 96       	adiw	r24, 0x01	; 1
    3570:	ea 81       	ldd	r30, Y+2	; 0x02
    3572:	fb 81       	ldd	r31, Y+3	; 0x03
    3574:	97 83       	std	Z+7, r25	; 0x07
    3576:	86 83       	std	Z+6, r24	; 0x06
			xReturn = pdPASS;
    3578:	81 e0       	ldi	r24, 0x01	; 1
    357a:	89 83       	std	Y+1, r24	; 0x01
    357c:	17 c0       	rjmp	.+46     	; 0x35ac <xQueueTakeMutexRecursive+0x72>
		}
		else
		{
			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
    357e:	8a 81       	ldd	r24, Y+2	; 0x02
    3580:	9b 81       	ldd	r25, Y+3	; 0x03
    3582:	2c 81       	ldd	r18, Y+4	; 0x04
    3584:	3d 81       	ldd	r19, Y+5	; 0x05
    3586:	60 e0       	ldi	r22, 0x00	; 0
    3588:	70 e0       	ldi	r23, 0x00	; 0
    358a:	a9 01       	movw	r20, r18
    358c:	20 e0       	ldi	r18, 0x00	; 0
    358e:	0e 94 cc 1b 	call	0x3798	; 0x3798 <xQueueGenericReceive>
    3592:	89 83       	std	Y+1, r24	; 0x01

			/* pdPASS will only be returned if we successfully obtained the mutex,
			we may have blocked to reach here. */
			if( xReturn == pdPASS )
    3594:	89 81       	ldd	r24, Y+1	; 0x01
    3596:	81 30       	cpi	r24, 0x01	; 1
    3598:	49 f4       	brne	.+18     	; 0x35ac <xQueueTakeMutexRecursive+0x72>
			{
				( pxMutex->uxRecursiveCallCount )++;
    359a:	ea 81       	ldd	r30, Y+2	; 0x02
    359c:	fb 81       	ldd	r31, Y+3	; 0x03
    359e:	86 81       	ldd	r24, Z+6	; 0x06
    35a0:	97 81       	ldd	r25, Z+7	; 0x07
    35a2:	01 96       	adiw	r24, 0x01	; 1
    35a4:	ea 81       	ldd	r30, Y+2	; 0x02
    35a6:	fb 81       	ldd	r31, Y+3	; 0x03
    35a8:	97 83       	std	Z+7, r25	; 0x07
    35aa:	86 83       	std	Z+6, r24	; 0x06
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
    35ac:	89 81       	ldd	r24, Y+1	; 0x01
	}
    35ae:	0f 90       	pop	r0
    35b0:	0f 90       	pop	r0
    35b2:	0f 90       	pop	r0
    35b4:	0f 90       	pop	r0
    35b6:	0f 90       	pop	r0
    35b8:	cf 91       	pop	r28
    35ba:	df 91       	pop	r29
    35bc:	1f 91       	pop	r17
    35be:	0f 91       	pop	r16
    35c0:	08 95       	ret

000035c2 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    35c2:	df 93       	push	r29
    35c4:	cf 93       	push	r28
    35c6:	cd b7       	in	r28, 0x3d	; 61
    35c8:	de b7       	in	r29, 0x3e	; 62
    35ca:	2c 97       	sbiw	r28, 0x0c	; 12
    35cc:	0f b6       	in	r0, 0x3f	; 63
    35ce:	f8 94       	cli
    35d0:	de bf       	out	0x3e, r29	; 62
    35d2:	0f be       	out	0x3f, r0	; 63
    35d4:	cd bf       	out	0x3d, r28	; 61
    35d6:	9e 83       	std	Y+6, r25	; 0x06
    35d8:	8d 83       	std	Y+5, r24	; 0x05
    35da:	78 87       	std	Y+8, r23	; 0x08
    35dc:	6f 83       	std	Y+7, r22	; 0x07
    35de:	5a 87       	std	Y+10, r21	; 0x0a
    35e0:	49 87       	std	Y+9, r20	; 0x09
    35e2:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    35e4:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    35e6:	0f b6       	in	r0, 0x3f	; 63
    35e8:	f8 94       	cli
    35ea:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    35ec:	ed 81       	ldd	r30, Y+5	; 0x05
    35ee:	fe 81       	ldd	r31, Y+6	; 0x06
    35f0:	92 8d       	ldd	r25, Z+26	; 0x1a
    35f2:	ed 81       	ldd	r30, Y+5	; 0x05
    35f4:	fe 81       	ldd	r31, Y+6	; 0x06
    35f6:	83 8d       	ldd	r24, Z+27	; 0x1b
    35f8:	98 17       	cp	r25, r24
    35fa:	d8 f4       	brcc	.+54     	; 0x3632 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    35fc:	8d 81       	ldd	r24, Y+5	; 0x05
    35fe:	9e 81       	ldd	r25, Y+6	; 0x06
    3600:	2f 81       	ldd	r18, Y+7	; 0x07
    3602:	38 85       	ldd	r19, Y+8	; 0x08
    3604:	b9 01       	movw	r22, r18
    3606:	4b 85       	ldd	r20, Y+11	; 0x0b
    3608:	0e 94 39 1d 	call	0x3a72	; 0x3a72 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    360c:	ed 81       	ldd	r30, Y+5	; 0x05
    360e:	fe 81       	ldd	r31, Y+6	; 0x06
    3610:	81 89       	ldd	r24, Z+17	; 0x11
    3612:	88 23       	and	r24, r24
    3614:	49 f0       	breq	.+18     	; 0x3628 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    3616:	8d 81       	ldd	r24, Y+5	; 0x05
    3618:	9e 81       	ldd	r25, Y+6	; 0x06
    361a:	41 96       	adiw	r24, 0x11	; 17
    361c:	0e 94 5f 23 	call	0x46be	; 0x46be <xTaskRemoveFromEventList>
    3620:	81 30       	cpi	r24, 0x01	; 1
    3622:	11 f4       	brne	.+4      	; 0x3628 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    3624:	0e 94 5e 18 	call	0x30bc	; 0x30bc <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    3628:	0f 90       	pop	r0
    362a:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    362c:	81 e0       	ldi	r24, 0x01	; 1
    362e:	8c 87       	std	Y+12, r24	; 0x0c
    3630:	5c c0       	rjmp	.+184    	; 0x36ea <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    3632:	89 85       	ldd	r24, Y+9	; 0x09
    3634:	9a 85       	ldd	r25, Y+10	; 0x0a
    3636:	00 97       	sbiw	r24, 0x00	; 0
    3638:	21 f4       	brne	.+8      	; 0x3642 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    363a:	0f 90       	pop	r0
    363c:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    363e:	1c 86       	std	Y+12, r1	; 0x0c
    3640:	54 c0       	rjmp	.+168    	; 0x36ea <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    3642:	89 81       	ldd	r24, Y+1	; 0x01
    3644:	88 23       	and	r24, r24
    3646:	31 f4       	brne	.+12     	; 0x3654 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3648:	ce 01       	movw	r24, r28
    364a:	02 96       	adiw	r24, 0x02	; 2
    364c:	0e 94 c7 23 	call	0x478e	; 0x478e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3650:	81 e0       	ldi	r24, 0x01	; 1
    3652:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    3654:	0f 90       	pop	r0
    3656:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3658:	0e 94 23 21 	call	0x4246	; 0x4246 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    365c:	0f b6       	in	r0, 0x3f	; 63
    365e:	f8 94       	cli
    3660:	0f 92       	push	r0
    3662:	ed 81       	ldd	r30, Y+5	; 0x05
    3664:	fe 81       	ldd	r31, Y+6	; 0x06
    3666:	85 8d       	ldd	r24, Z+29	; 0x1d
    3668:	8f 3f       	cpi	r24, 0xFF	; 255
    366a:	19 f4       	brne	.+6      	; 0x3672 <xQueueGenericSend+0xb0>
    366c:	ed 81       	ldd	r30, Y+5	; 0x05
    366e:	fe 81       	ldd	r31, Y+6	; 0x06
    3670:	15 8e       	std	Z+29, r1	; 0x1d
    3672:	ed 81       	ldd	r30, Y+5	; 0x05
    3674:	fe 81       	ldd	r31, Y+6	; 0x06
    3676:	86 8d       	ldd	r24, Z+30	; 0x1e
    3678:	8f 3f       	cpi	r24, 0xFF	; 255
    367a:	19 f4       	brne	.+6      	; 0x3682 <xQueueGenericSend+0xc0>
    367c:	ed 81       	ldd	r30, Y+5	; 0x05
    367e:	fe 81       	ldd	r31, Y+6	; 0x06
    3680:	16 8e       	std	Z+30, r1	; 0x1e
    3682:	0f 90       	pop	r0
    3684:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3686:	ce 01       	movw	r24, r28
    3688:	02 96       	adiw	r24, 0x02	; 2
    368a:	9e 01       	movw	r18, r28
    368c:	27 5f       	subi	r18, 0xF7	; 247
    368e:	3f 4f       	sbci	r19, 0xFF	; 255
    3690:	b9 01       	movw	r22, r18
    3692:	0e 94 e0 23 	call	0x47c0	; 0x47c0 <xTaskCheckForTimeOut>
    3696:	88 23       	and	r24, r24
    3698:	09 f5       	brne	.+66     	; 0x36dc <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    369a:	8d 81       	ldd	r24, Y+5	; 0x05
    369c:	9e 81       	ldd	r25, Y+6	; 0x06
    369e:	0e 94 ae 1e 	call	0x3d5c	; 0x3d5c <prvIsQueueFull>
    36a2:	88 23       	and	r24, r24
    36a4:	a1 f0       	breq	.+40     	; 0x36ce <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    36a6:	8d 81       	ldd	r24, Y+5	; 0x05
    36a8:	9e 81       	ldd	r25, Y+6	; 0x06
    36aa:	08 96       	adiw	r24, 0x08	; 8
    36ac:	29 85       	ldd	r18, Y+9	; 0x09
    36ae:	3a 85       	ldd	r19, Y+10	; 0x0a
    36b0:	b9 01       	movw	r22, r18
    36b2:	0e 94 29 23 	call	0x4652	; 0x4652 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    36b6:	8d 81       	ldd	r24, Y+5	; 0x05
    36b8:	9e 81       	ldd	r25, Y+6	; 0x06
    36ba:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    36be:	0e 94 2f 21 	call	0x425e	; 0x425e <xTaskResumeAll>
    36c2:	88 23       	and	r24, r24
    36c4:	09 f0       	breq	.+2      	; 0x36c8 <xQueueGenericSend+0x106>
    36c6:	8f cf       	rjmp	.-226    	; 0x35e6 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    36c8:	0e 94 5e 18 	call	0x30bc	; 0x30bc <vPortYield>
    36cc:	8c cf       	rjmp	.-232    	; 0x35e6 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    36ce:	8d 81       	ldd	r24, Y+5	; 0x05
    36d0:	9e 81       	ldd	r25, Y+6	; 0x06
    36d2:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    36d6:	0e 94 2f 21 	call	0x425e	; 0x425e <xTaskResumeAll>
    36da:	85 cf       	rjmp	.-246    	; 0x35e6 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    36dc:	8d 81       	ldd	r24, Y+5	; 0x05
    36de:	9e 81       	ldd	r25, Y+6	; 0x06
    36e0:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    36e4:	0e 94 2f 21 	call	0x425e	; 0x425e <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    36e8:	1c 86       	std	Y+12, r1	; 0x0c
    36ea:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    36ec:	2c 96       	adiw	r28, 0x0c	; 12
    36ee:	0f b6       	in	r0, 0x3f	; 63
    36f0:	f8 94       	cli
    36f2:	de bf       	out	0x3e, r29	; 62
    36f4:	0f be       	out	0x3f, r0	; 63
    36f6:	cd bf       	out	0x3d, r28	; 61
    36f8:	cf 91       	pop	r28
    36fa:	df 91       	pop	r29
    36fc:	08 95       	ret

000036fe <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    36fe:	df 93       	push	r29
    3700:	cf 93       	push	r28
    3702:	cd b7       	in	r28, 0x3d	; 61
    3704:	de b7       	in	r29, 0x3e	; 62
    3706:	29 97       	sbiw	r28, 0x09	; 9
    3708:	0f b6       	in	r0, 0x3f	; 63
    370a:	f8 94       	cli
    370c:	de bf       	out	0x3e, r29	; 62
    370e:	0f be       	out	0x3f, r0	; 63
    3710:	cd bf       	out	0x3d, r28	; 61
    3712:	9c 83       	std	Y+4, r25	; 0x04
    3714:	8b 83       	std	Y+3, r24	; 0x03
    3716:	7e 83       	std	Y+6, r23	; 0x06
    3718:	6d 83       	std	Y+5, r22	; 0x05
    371a:	58 87       	std	Y+8, r21	; 0x08
    371c:	4f 83       	std	Y+7, r20	; 0x07
    371e:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3720:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3722:	eb 81       	ldd	r30, Y+3	; 0x03
    3724:	fc 81       	ldd	r31, Y+4	; 0x04
    3726:	92 8d       	ldd	r25, Z+26	; 0x1a
    3728:	eb 81       	ldd	r30, Y+3	; 0x03
    372a:	fc 81       	ldd	r31, Y+4	; 0x04
    372c:	83 8d       	ldd	r24, Z+27	; 0x1b
    372e:	98 17       	cp	r25, r24
    3730:	40 f5       	brcc	.+80     	; 0x3782 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3732:	8b 81       	ldd	r24, Y+3	; 0x03
    3734:	9c 81       	ldd	r25, Y+4	; 0x04
    3736:	2d 81       	ldd	r18, Y+5	; 0x05
    3738:	3e 81       	ldd	r19, Y+6	; 0x06
    373a:	b9 01       	movw	r22, r18
    373c:	49 85       	ldd	r20, Y+9	; 0x09
    373e:	0e 94 39 1d 	call	0x3a72	; 0x3a72 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    3742:	eb 81       	ldd	r30, Y+3	; 0x03
    3744:	fc 81       	ldd	r31, Y+4	; 0x04
    3746:	86 8d       	ldd	r24, Z+30	; 0x1e
    3748:	8f 3f       	cpi	r24, 0xFF	; 255
    374a:	89 f4       	brne	.+34     	; 0x376e <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    374c:	eb 81       	ldd	r30, Y+3	; 0x03
    374e:	fc 81       	ldd	r31, Y+4	; 0x04
    3750:	81 89       	ldd	r24, Z+17	; 0x11
    3752:	88 23       	and	r24, r24
    3754:	99 f0       	breq	.+38     	; 0x377c <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3756:	8b 81       	ldd	r24, Y+3	; 0x03
    3758:	9c 81       	ldd	r25, Y+4	; 0x04
    375a:	41 96       	adiw	r24, 0x11	; 17
    375c:	0e 94 5f 23 	call	0x46be	; 0x46be <xTaskRemoveFromEventList>
    3760:	88 23       	and	r24, r24
    3762:	61 f0       	breq	.+24     	; 0x377c <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    3764:	ef 81       	ldd	r30, Y+7	; 0x07
    3766:	f8 85       	ldd	r31, Y+8	; 0x08
    3768:	81 e0       	ldi	r24, 0x01	; 1
    376a:	80 83       	st	Z, r24
    376c:	07 c0       	rjmp	.+14     	; 0x377c <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    376e:	eb 81       	ldd	r30, Y+3	; 0x03
    3770:	fc 81       	ldd	r31, Y+4	; 0x04
    3772:	86 8d       	ldd	r24, Z+30	; 0x1e
    3774:	8f 5f       	subi	r24, 0xFF	; 255
    3776:	eb 81       	ldd	r30, Y+3	; 0x03
    3778:	fc 81       	ldd	r31, Y+4	; 0x04
    377a:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    377c:	81 e0       	ldi	r24, 0x01	; 1
    377e:	8a 83       	std	Y+2, r24	; 0x02
    3780:	01 c0       	rjmp	.+2      	; 0x3784 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3782:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3784:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3786:	29 96       	adiw	r28, 0x09	; 9
    3788:	0f b6       	in	r0, 0x3f	; 63
    378a:	f8 94       	cli
    378c:	de bf       	out	0x3e, r29	; 62
    378e:	0f be       	out	0x3f, r0	; 63
    3790:	cd bf       	out	0x3d, r28	; 61
    3792:	cf 91       	pop	r28
    3794:	df 91       	pop	r29
    3796:	08 95       	ret

00003798 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    3798:	df 93       	push	r29
    379a:	cf 93       	push	r28
    379c:	cd b7       	in	r28, 0x3d	; 61
    379e:	de b7       	in	r29, 0x3e	; 62
    37a0:	2e 97       	sbiw	r28, 0x0e	; 14
    37a2:	0f b6       	in	r0, 0x3f	; 63
    37a4:	f8 94       	cli
    37a6:	de bf       	out	0x3e, r29	; 62
    37a8:	0f be       	out	0x3f, r0	; 63
    37aa:	cd bf       	out	0x3d, r28	; 61
    37ac:	98 87       	std	Y+8, r25	; 0x08
    37ae:	8f 83       	std	Y+7, r24	; 0x07
    37b0:	7a 87       	std	Y+10, r23	; 0x0a
    37b2:	69 87       	std	Y+9, r22	; 0x09
    37b4:	5c 87       	std	Y+12, r21	; 0x0c
    37b6:	4b 87       	std	Y+11, r20	; 0x0b
    37b8:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    37ba:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    37bc:	0f b6       	in	r0, 0x3f	; 63
    37be:	f8 94       	cli
    37c0:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    37c2:	ef 81       	ldd	r30, Y+7	; 0x07
    37c4:	f8 85       	ldd	r31, Y+8	; 0x08
    37c6:	82 8d       	ldd	r24, Z+26	; 0x1a
    37c8:	88 23       	and	r24, r24
    37ca:	09 f4       	brne	.+2      	; 0x37ce <xQueueGenericReceive+0x36>
    37cc:	4b c0       	rjmp	.+150    	; 0x3864 <xQueueGenericReceive+0xcc>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    37ce:	ef 81       	ldd	r30, Y+7	; 0x07
    37d0:	f8 85       	ldd	r31, Y+8	; 0x08
    37d2:	86 81       	ldd	r24, Z+6	; 0x06
    37d4:	97 81       	ldd	r25, Z+7	; 0x07
    37d6:	9a 83       	std	Y+2, r25	; 0x02
    37d8:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    37da:	8f 81       	ldd	r24, Y+7	; 0x07
    37dc:	98 85       	ldd	r25, Y+8	; 0x08
    37de:	29 85       	ldd	r18, Y+9	; 0x09
    37e0:	3a 85       	ldd	r19, Y+10	; 0x0a
    37e2:	b9 01       	movw	r22, r18
    37e4:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    37e8:	8d 85       	ldd	r24, Y+13	; 0x0d
    37ea:	88 23       	and	r24, r24
    37ec:	11 f5       	brne	.+68     	; 0x3832 <xQueueGenericReceive+0x9a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    37ee:	ef 81       	ldd	r30, Y+7	; 0x07
    37f0:	f8 85       	ldd	r31, Y+8	; 0x08
    37f2:	82 8d       	ldd	r24, Z+26	; 0x1a
    37f4:	81 50       	subi	r24, 0x01	; 1
    37f6:	ef 81       	ldd	r30, Y+7	; 0x07
    37f8:	f8 85       	ldd	r31, Y+8	; 0x08
    37fa:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    37fc:	ef 81       	ldd	r30, Y+7	; 0x07
    37fe:	f8 85       	ldd	r31, Y+8	; 0x08
    3800:	80 81       	ld	r24, Z
    3802:	91 81       	ldd	r25, Z+1	; 0x01
    3804:	00 97       	sbiw	r24, 0x00	; 0
    3806:	31 f4       	brne	.+12     	; 0x3814 <xQueueGenericReceive+0x7c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    3808:	0e 94 d6 25 	call	0x4bac	; 0x4bac <xTaskGetCurrentTaskHandle>
    380c:	ef 81       	ldd	r30, Y+7	; 0x07
    380e:	f8 85       	ldd	r31, Y+8	; 0x08
    3810:	93 83       	std	Z+3, r25	; 0x03
    3812:	82 83       	std	Z+2, r24	; 0x02
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3814:	ef 81       	ldd	r30, Y+7	; 0x07
    3816:	f8 85       	ldd	r31, Y+8	; 0x08
    3818:	80 85       	ldd	r24, Z+8	; 0x08
    381a:	88 23       	and	r24, r24
    381c:	f1 f0       	breq	.+60     	; 0x385a <xQueueGenericReceive+0xc2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    381e:	8f 81       	ldd	r24, Y+7	; 0x07
    3820:	98 85       	ldd	r25, Y+8	; 0x08
    3822:	08 96       	adiw	r24, 0x08	; 8
    3824:	0e 94 5f 23 	call	0x46be	; 0x46be <xTaskRemoveFromEventList>
    3828:	81 30       	cpi	r24, 0x01	; 1
    382a:	b9 f4       	brne	.+46     	; 0x385a <xQueueGenericReceive+0xc2>
						{
							portYIELD_WITHIN_API();
    382c:	0e 94 5e 18 	call	0x30bc	; 0x30bc <vPortYield>
    3830:	14 c0       	rjmp	.+40     	; 0x385a <xQueueGenericReceive+0xc2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    3832:	ef 81       	ldd	r30, Y+7	; 0x07
    3834:	f8 85       	ldd	r31, Y+8	; 0x08
    3836:	89 81       	ldd	r24, Y+1	; 0x01
    3838:	9a 81       	ldd	r25, Y+2	; 0x02
    383a:	97 83       	std	Z+7, r25	; 0x07
    383c:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    383e:	ef 81       	ldd	r30, Y+7	; 0x07
    3840:	f8 85       	ldd	r31, Y+8	; 0x08
    3842:	81 89       	ldd	r24, Z+17	; 0x11
    3844:	88 23       	and	r24, r24
    3846:	49 f0       	breq	.+18     	; 0x385a <xQueueGenericReceive+0xc2>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3848:	8f 81       	ldd	r24, Y+7	; 0x07
    384a:	98 85       	ldd	r25, Y+8	; 0x08
    384c:	41 96       	adiw	r24, 0x11	; 17
    384e:	0e 94 5f 23 	call	0x46be	; 0x46be <xTaskRemoveFromEventList>
    3852:	88 23       	and	r24, r24
    3854:	11 f0       	breq	.+4      	; 0x385a <xQueueGenericReceive+0xc2>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    3856:	0e 94 5e 18 	call	0x30bc	; 0x30bc <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    385a:	0f 90       	pop	r0
    385c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    385e:	81 e0       	ldi	r24, 0x01	; 1
    3860:	8e 87       	std	Y+14, r24	; 0x0e
    3862:	6d c0       	rjmp	.+218    	; 0x393e <xQueueGenericReceive+0x1a6>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    3864:	8b 85       	ldd	r24, Y+11	; 0x0b
    3866:	9c 85       	ldd	r25, Y+12	; 0x0c
    3868:	00 97       	sbiw	r24, 0x00	; 0
    386a:	21 f4       	brne	.+8      	; 0x3874 <xQueueGenericReceive+0xdc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    386c:	0f 90       	pop	r0
    386e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3870:	1e 86       	std	Y+14, r1	; 0x0e
    3872:	65 c0       	rjmp	.+202    	; 0x393e <xQueueGenericReceive+0x1a6>
				}
				else if( xEntryTimeSet == pdFALSE )
    3874:	8b 81       	ldd	r24, Y+3	; 0x03
    3876:	88 23       	and	r24, r24
    3878:	31 f4       	brne	.+12     	; 0x3886 <xQueueGenericReceive+0xee>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    387a:	ce 01       	movw	r24, r28
    387c:	04 96       	adiw	r24, 0x04	; 4
    387e:	0e 94 c7 23 	call	0x478e	; 0x478e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3882:	81 e0       	ldi	r24, 0x01	; 1
    3884:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    3886:	0f 90       	pop	r0
    3888:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    388a:	0e 94 23 21 	call	0x4246	; 0x4246 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    388e:	0f b6       	in	r0, 0x3f	; 63
    3890:	f8 94       	cli
    3892:	0f 92       	push	r0
    3894:	ef 81       	ldd	r30, Y+7	; 0x07
    3896:	f8 85       	ldd	r31, Y+8	; 0x08
    3898:	85 8d       	ldd	r24, Z+29	; 0x1d
    389a:	8f 3f       	cpi	r24, 0xFF	; 255
    389c:	19 f4       	brne	.+6      	; 0x38a4 <xQueueGenericReceive+0x10c>
    389e:	ef 81       	ldd	r30, Y+7	; 0x07
    38a0:	f8 85       	ldd	r31, Y+8	; 0x08
    38a2:	15 8e       	std	Z+29, r1	; 0x1d
    38a4:	ef 81       	ldd	r30, Y+7	; 0x07
    38a6:	f8 85       	ldd	r31, Y+8	; 0x08
    38a8:	86 8d       	ldd	r24, Z+30	; 0x1e
    38aa:	8f 3f       	cpi	r24, 0xFF	; 255
    38ac:	19 f4       	brne	.+6      	; 0x38b4 <xQueueGenericReceive+0x11c>
    38ae:	ef 81       	ldd	r30, Y+7	; 0x07
    38b0:	f8 85       	ldd	r31, Y+8	; 0x08
    38b2:	16 8e       	std	Z+30, r1	; 0x1e
    38b4:	0f 90       	pop	r0
    38b6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    38b8:	ce 01       	movw	r24, r28
    38ba:	04 96       	adiw	r24, 0x04	; 4
    38bc:	9e 01       	movw	r18, r28
    38be:	25 5f       	subi	r18, 0xF5	; 245
    38c0:	3f 4f       	sbci	r19, 0xFF	; 255
    38c2:	b9 01       	movw	r22, r18
    38c4:	0e 94 e0 23 	call	0x47c0	; 0x47c0 <xTaskCheckForTimeOut>
    38c8:	88 23       	and	r24, r24
    38ca:	91 f5       	brne	.+100    	; 0x3930 <xQueueGenericReceive+0x198>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    38cc:	8f 81       	ldd	r24, Y+7	; 0x07
    38ce:	98 85       	ldd	r25, Y+8	; 0x08
    38d0:	0e 94 7b 1e 	call	0x3cf6	; 0x3cf6 <prvIsQueueEmpty>
    38d4:	88 23       	and	r24, r24
    38d6:	29 f1       	breq	.+74     	; 0x3922 <xQueueGenericReceive+0x18a>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    38d8:	ef 81       	ldd	r30, Y+7	; 0x07
    38da:	f8 85       	ldd	r31, Y+8	; 0x08
    38dc:	80 81       	ld	r24, Z
    38de:	91 81       	ldd	r25, Z+1	; 0x01
    38e0:	00 97       	sbiw	r24, 0x00	; 0
    38e2:	59 f4       	brne	.+22     	; 0x38fa <xQueueGenericReceive+0x162>
					{
						portENTER_CRITICAL();
    38e4:	0f b6       	in	r0, 0x3f	; 63
    38e6:	f8 94       	cli
    38e8:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    38ea:	ef 81       	ldd	r30, Y+7	; 0x07
    38ec:	f8 85       	ldd	r31, Y+8	; 0x08
    38ee:	82 81       	ldd	r24, Z+2	; 0x02
    38f0:	93 81       	ldd	r25, Z+3	; 0x03
    38f2:	0e 94 e8 25 	call	0x4bd0	; 0x4bd0 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    38f6:	0f 90       	pop	r0
    38f8:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    38fa:	8f 81       	ldd	r24, Y+7	; 0x07
    38fc:	98 85       	ldd	r25, Y+8	; 0x08
    38fe:	41 96       	adiw	r24, 0x11	; 17
    3900:	2b 85       	ldd	r18, Y+11	; 0x0b
    3902:	3c 85       	ldd	r19, Y+12	; 0x0c
    3904:	b9 01       	movw	r22, r18
    3906:	0e 94 29 23 	call	0x4652	; 0x4652 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    390a:	8f 81       	ldd	r24, Y+7	; 0x07
    390c:	98 85       	ldd	r25, Y+8	; 0x08
    390e:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3912:	0e 94 2f 21 	call	0x425e	; 0x425e <xTaskResumeAll>
    3916:	88 23       	and	r24, r24
    3918:	09 f0       	breq	.+2      	; 0x391c <xQueueGenericReceive+0x184>
    391a:	50 cf       	rjmp	.-352    	; 0x37bc <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    391c:	0e 94 5e 18 	call	0x30bc	; 0x30bc <vPortYield>
    3920:	4d cf       	rjmp	.-358    	; 0x37bc <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3922:	8f 81       	ldd	r24, Y+7	; 0x07
    3924:	98 85       	ldd	r25, Y+8	; 0x08
    3926:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    392a:	0e 94 2f 21 	call	0x425e	; 0x425e <xTaskResumeAll>
    392e:	46 cf       	rjmp	.-372    	; 0x37bc <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    3930:	8f 81       	ldd	r24, Y+7	; 0x07
    3932:	98 85       	ldd	r25, Y+8	; 0x08
    3934:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3938:	0e 94 2f 21 	call	0x425e	; 0x425e <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    393c:	1e 86       	std	Y+14, r1	; 0x0e
    393e:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    3940:	2e 96       	adiw	r28, 0x0e	; 14
    3942:	0f b6       	in	r0, 0x3f	; 63
    3944:	f8 94       	cli
    3946:	de bf       	out	0x3e, r29	; 62
    3948:	0f be       	out	0x3f, r0	; 63
    394a:	cd bf       	out	0x3d, r28	; 61
    394c:	cf 91       	pop	r28
    394e:	df 91       	pop	r29
    3950:	08 95       	ret

00003952 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    3952:	df 93       	push	r29
    3954:	cf 93       	push	r28
    3956:	cd b7       	in	r28, 0x3d	; 61
    3958:	de b7       	in	r29, 0x3e	; 62
    395a:	28 97       	sbiw	r28, 0x08	; 8
    395c:	0f b6       	in	r0, 0x3f	; 63
    395e:	f8 94       	cli
    3960:	de bf       	out	0x3e, r29	; 62
    3962:	0f be       	out	0x3f, r0	; 63
    3964:	cd bf       	out	0x3d, r28	; 61
    3966:	9c 83       	std	Y+4, r25	; 0x04
    3968:	8b 83       	std	Y+3, r24	; 0x03
    396a:	7e 83       	std	Y+6, r23	; 0x06
    396c:	6d 83       	std	Y+5, r22	; 0x05
    396e:	58 87       	std	Y+8, r21	; 0x08
    3970:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3972:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3974:	eb 81       	ldd	r30, Y+3	; 0x03
    3976:	fc 81       	ldd	r31, Y+4	; 0x04
    3978:	82 8d       	ldd	r24, Z+26	; 0x1a
    397a:	88 23       	and	r24, r24
    397c:	71 f1       	breq	.+92     	; 0x39da <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    397e:	8b 81       	ldd	r24, Y+3	; 0x03
    3980:	9c 81       	ldd	r25, Y+4	; 0x04
    3982:	2d 81       	ldd	r18, Y+5	; 0x05
    3984:	3e 81       	ldd	r19, Y+6	; 0x06
    3986:	b9 01       	movw	r22, r18
    3988:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    398c:	eb 81       	ldd	r30, Y+3	; 0x03
    398e:	fc 81       	ldd	r31, Y+4	; 0x04
    3990:	82 8d       	ldd	r24, Z+26	; 0x1a
    3992:	81 50       	subi	r24, 0x01	; 1
    3994:	eb 81       	ldd	r30, Y+3	; 0x03
    3996:	fc 81       	ldd	r31, Y+4	; 0x04
    3998:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    399a:	eb 81       	ldd	r30, Y+3	; 0x03
    399c:	fc 81       	ldd	r31, Y+4	; 0x04
    399e:	85 8d       	ldd	r24, Z+29	; 0x1d
    39a0:	8f 3f       	cpi	r24, 0xFF	; 255
    39a2:	89 f4       	brne	.+34     	; 0x39c6 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    39a4:	eb 81       	ldd	r30, Y+3	; 0x03
    39a6:	fc 81       	ldd	r31, Y+4	; 0x04
    39a8:	80 85       	ldd	r24, Z+8	; 0x08
    39aa:	88 23       	and	r24, r24
    39ac:	99 f0       	breq	.+38     	; 0x39d4 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    39ae:	8b 81       	ldd	r24, Y+3	; 0x03
    39b0:	9c 81       	ldd	r25, Y+4	; 0x04
    39b2:	08 96       	adiw	r24, 0x08	; 8
    39b4:	0e 94 5f 23 	call	0x46be	; 0x46be <xTaskRemoveFromEventList>
    39b8:	88 23       	and	r24, r24
    39ba:	61 f0       	breq	.+24     	; 0x39d4 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    39bc:	ef 81       	ldd	r30, Y+7	; 0x07
    39be:	f8 85       	ldd	r31, Y+8	; 0x08
    39c0:	81 e0       	ldi	r24, 0x01	; 1
    39c2:	80 83       	st	Z, r24
    39c4:	07 c0       	rjmp	.+14     	; 0x39d4 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    39c6:	eb 81       	ldd	r30, Y+3	; 0x03
    39c8:	fc 81       	ldd	r31, Y+4	; 0x04
    39ca:	85 8d       	ldd	r24, Z+29	; 0x1d
    39cc:	8f 5f       	subi	r24, 0xFF	; 255
    39ce:	eb 81       	ldd	r30, Y+3	; 0x03
    39d0:	fc 81       	ldd	r31, Y+4	; 0x04
    39d2:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    39d4:	81 e0       	ldi	r24, 0x01	; 1
    39d6:	8a 83       	std	Y+2, r24	; 0x02
    39d8:	01 c0       	rjmp	.+2      	; 0x39dc <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    39da:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    39dc:	8a 81       	ldd	r24, Y+2	; 0x02
}
    39de:	28 96       	adiw	r28, 0x08	; 8
    39e0:	0f b6       	in	r0, 0x3f	; 63
    39e2:	f8 94       	cli
    39e4:	de bf       	out	0x3e, r29	; 62
    39e6:	0f be       	out	0x3f, r0	; 63
    39e8:	cd bf       	out	0x3d, r28	; 61
    39ea:	cf 91       	pop	r28
    39ec:	df 91       	pop	r29
    39ee:	08 95       	ret

000039f0 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    39f0:	df 93       	push	r29
    39f2:	cf 93       	push	r28
    39f4:	00 d0       	rcall	.+0      	; 0x39f6 <uxQueueMessagesWaiting+0x6>
    39f6:	0f 92       	push	r0
    39f8:	cd b7       	in	r28, 0x3d	; 61
    39fa:	de b7       	in	r29, 0x3e	; 62
    39fc:	9b 83       	std	Y+3, r25	; 0x03
    39fe:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3a00:	0f b6       	in	r0, 0x3f	; 63
    3a02:	f8 94       	cli
    3a04:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    3a06:	ea 81       	ldd	r30, Y+2	; 0x02
    3a08:	fb 81       	ldd	r31, Y+3	; 0x03
    3a0a:	82 8d       	ldd	r24, Z+26	; 0x1a
    3a0c:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    3a0e:	0f 90       	pop	r0
    3a10:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3a12:	89 81       	ldd	r24, Y+1	; 0x01
}
    3a14:	0f 90       	pop	r0
    3a16:	0f 90       	pop	r0
    3a18:	0f 90       	pop	r0
    3a1a:	cf 91       	pop	r28
    3a1c:	df 91       	pop	r29
    3a1e:	08 95       	ret

00003a20 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    3a20:	df 93       	push	r29
    3a22:	cf 93       	push	r28
    3a24:	00 d0       	rcall	.+0      	; 0x3a26 <uxQueueMessagesWaitingFromISR+0x6>
    3a26:	0f 92       	push	r0
    3a28:	cd b7       	in	r28, 0x3d	; 61
    3a2a:	de b7       	in	r29, 0x3e	; 62
    3a2c:	9b 83       	std	Y+3, r25	; 0x03
    3a2e:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    3a30:	ea 81       	ldd	r30, Y+2	; 0x02
    3a32:	fb 81       	ldd	r31, Y+3	; 0x03
    3a34:	82 8d       	ldd	r24, Z+26	; 0x1a
    3a36:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    3a38:	89 81       	ldd	r24, Y+1	; 0x01
}
    3a3a:	0f 90       	pop	r0
    3a3c:	0f 90       	pop	r0
    3a3e:	0f 90       	pop	r0
    3a40:	cf 91       	pop	r28
    3a42:	df 91       	pop	r29
    3a44:	08 95       	ret

00003a46 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    3a46:	df 93       	push	r29
    3a48:	cf 93       	push	r28
    3a4a:	00 d0       	rcall	.+0      	; 0x3a4c <vQueueDelete+0x6>
    3a4c:	cd b7       	in	r28, 0x3d	; 61
    3a4e:	de b7       	in	r29, 0x3e	; 62
    3a50:	9a 83       	std	Y+2, r25	; 0x02
    3a52:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    3a54:	e9 81       	ldd	r30, Y+1	; 0x01
    3a56:	fa 81       	ldd	r31, Y+2	; 0x02
    3a58:	80 81       	ld	r24, Z
    3a5a:	91 81       	ldd	r25, Z+1	; 0x01
    3a5c:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <vPortFree>
	vPortFree( pxQueue );
    3a60:	89 81       	ldd	r24, Y+1	; 0x01
    3a62:	9a 81       	ldd	r25, Y+2	; 0x02
    3a64:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <vPortFree>
}
    3a68:	0f 90       	pop	r0
    3a6a:	0f 90       	pop	r0
    3a6c:	cf 91       	pop	r28
    3a6e:	df 91       	pop	r29
    3a70:	08 95       	ret

00003a72 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    3a72:	df 93       	push	r29
    3a74:	cf 93       	push	r28
    3a76:	00 d0       	rcall	.+0      	; 0x3a78 <prvCopyDataToQueue+0x6>
    3a78:	00 d0       	rcall	.+0      	; 0x3a7a <prvCopyDataToQueue+0x8>
    3a7a:	0f 92       	push	r0
    3a7c:	cd b7       	in	r28, 0x3d	; 61
    3a7e:	de b7       	in	r29, 0x3e	; 62
    3a80:	9a 83       	std	Y+2, r25	; 0x02
    3a82:	89 83       	std	Y+1, r24	; 0x01
    3a84:	7c 83       	std	Y+4, r23	; 0x04
    3a86:	6b 83       	std	Y+3, r22	; 0x03
    3a88:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    3a8a:	e9 81       	ldd	r30, Y+1	; 0x01
    3a8c:	fa 81       	ldd	r31, Y+2	; 0x02
    3a8e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3a90:	88 23       	and	r24, r24
    3a92:	91 f4       	brne	.+36     	; 0x3ab8 <prvCopyDataToQueue+0x46>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3a94:	e9 81       	ldd	r30, Y+1	; 0x01
    3a96:	fa 81       	ldd	r31, Y+2	; 0x02
    3a98:	80 81       	ld	r24, Z
    3a9a:	91 81       	ldd	r25, Z+1	; 0x01
    3a9c:	00 97       	sbiw	r24, 0x00	; 0
    3a9e:	09 f0       	breq	.+2      	; 0x3aa2 <prvCopyDataToQueue+0x30>
    3aa0:	7f c0       	rjmp	.+254    	; 0x3ba0 <prvCopyDataToQueue+0x12e>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    3aa2:	e9 81       	ldd	r30, Y+1	; 0x01
    3aa4:	fa 81       	ldd	r31, Y+2	; 0x02
    3aa6:	82 81       	ldd	r24, Z+2	; 0x02
    3aa8:	93 81       	ldd	r25, Z+3	; 0x03
    3aaa:	0e 94 68 26 	call	0x4cd0	; 0x4cd0 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    3aae:	e9 81       	ldd	r30, Y+1	; 0x01
    3ab0:	fa 81       	ldd	r31, Y+2	; 0x02
    3ab2:	13 82       	std	Z+3, r1	; 0x03
    3ab4:	12 82       	std	Z+2, r1	; 0x02
    3ab6:	74 c0       	rjmp	.+232    	; 0x3ba0 <prvCopyDataToQueue+0x12e>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    3ab8:	8d 81       	ldd	r24, Y+5	; 0x05
    3aba:	88 23       	and	r24, r24
    3abc:	99 f5       	brne	.+102    	; 0x3b24 <prvCopyDataToQueue+0xb2>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    3abe:	e9 81       	ldd	r30, Y+1	; 0x01
    3ac0:	fa 81       	ldd	r31, Y+2	; 0x02
    3ac2:	64 81       	ldd	r22, Z+4	; 0x04
    3ac4:	75 81       	ldd	r23, Z+5	; 0x05
    3ac6:	e9 81       	ldd	r30, Y+1	; 0x01
    3ac8:	fa 81       	ldd	r31, Y+2	; 0x02
    3aca:	84 8d       	ldd	r24, Z+28	; 0x1c
    3acc:	48 2f       	mov	r20, r24
    3ace:	50 e0       	ldi	r21, 0x00	; 0
    3ad0:	2b 81       	ldd	r18, Y+3	; 0x03
    3ad2:	3c 81       	ldd	r19, Y+4	; 0x04
    3ad4:	cb 01       	movw	r24, r22
    3ad6:	b9 01       	movw	r22, r18
    3ad8:	0e 94 2a 28 	call	0x5054	; 0x5054 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    3adc:	e9 81       	ldd	r30, Y+1	; 0x01
    3ade:	fa 81       	ldd	r31, Y+2	; 0x02
    3ae0:	24 81       	ldd	r18, Z+4	; 0x04
    3ae2:	35 81       	ldd	r19, Z+5	; 0x05
    3ae4:	e9 81       	ldd	r30, Y+1	; 0x01
    3ae6:	fa 81       	ldd	r31, Y+2	; 0x02
    3ae8:	84 8d       	ldd	r24, Z+28	; 0x1c
    3aea:	88 2f       	mov	r24, r24
    3aec:	90 e0       	ldi	r25, 0x00	; 0
    3aee:	82 0f       	add	r24, r18
    3af0:	93 1f       	adc	r25, r19
    3af2:	e9 81       	ldd	r30, Y+1	; 0x01
    3af4:	fa 81       	ldd	r31, Y+2	; 0x02
    3af6:	95 83       	std	Z+5, r25	; 0x05
    3af8:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    3afa:	e9 81       	ldd	r30, Y+1	; 0x01
    3afc:	fa 81       	ldd	r31, Y+2	; 0x02
    3afe:	24 81       	ldd	r18, Z+4	; 0x04
    3b00:	35 81       	ldd	r19, Z+5	; 0x05
    3b02:	e9 81       	ldd	r30, Y+1	; 0x01
    3b04:	fa 81       	ldd	r31, Y+2	; 0x02
    3b06:	82 81       	ldd	r24, Z+2	; 0x02
    3b08:	93 81       	ldd	r25, Z+3	; 0x03
    3b0a:	28 17       	cp	r18, r24
    3b0c:	39 07       	cpc	r19, r25
    3b0e:	08 f4       	brcc	.+2      	; 0x3b12 <prvCopyDataToQueue+0xa0>
    3b10:	47 c0       	rjmp	.+142    	; 0x3ba0 <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3b12:	e9 81       	ldd	r30, Y+1	; 0x01
    3b14:	fa 81       	ldd	r31, Y+2	; 0x02
    3b16:	80 81       	ld	r24, Z
    3b18:	91 81       	ldd	r25, Z+1	; 0x01
    3b1a:	e9 81       	ldd	r30, Y+1	; 0x01
    3b1c:	fa 81       	ldd	r31, Y+2	; 0x02
    3b1e:	95 83       	std	Z+5, r25	; 0x05
    3b20:	84 83       	std	Z+4, r24	; 0x04
    3b22:	3e c0       	rjmp	.+124    	; 0x3ba0 <prvCopyDataToQueue+0x12e>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    3b24:	e9 81       	ldd	r30, Y+1	; 0x01
    3b26:	fa 81       	ldd	r31, Y+2	; 0x02
    3b28:	66 81       	ldd	r22, Z+6	; 0x06
    3b2a:	77 81       	ldd	r23, Z+7	; 0x07
    3b2c:	e9 81       	ldd	r30, Y+1	; 0x01
    3b2e:	fa 81       	ldd	r31, Y+2	; 0x02
    3b30:	84 8d       	ldd	r24, Z+28	; 0x1c
    3b32:	48 2f       	mov	r20, r24
    3b34:	50 e0       	ldi	r21, 0x00	; 0
    3b36:	2b 81       	ldd	r18, Y+3	; 0x03
    3b38:	3c 81       	ldd	r19, Y+4	; 0x04
    3b3a:	cb 01       	movw	r24, r22
    3b3c:	b9 01       	movw	r22, r18
    3b3e:	0e 94 2a 28 	call	0x5054	; 0x5054 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    3b42:	e9 81       	ldd	r30, Y+1	; 0x01
    3b44:	fa 81       	ldd	r31, Y+2	; 0x02
    3b46:	26 81       	ldd	r18, Z+6	; 0x06
    3b48:	37 81       	ldd	r19, Z+7	; 0x07
    3b4a:	e9 81       	ldd	r30, Y+1	; 0x01
    3b4c:	fa 81       	ldd	r31, Y+2	; 0x02
    3b4e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3b50:	88 2f       	mov	r24, r24
    3b52:	90 e0       	ldi	r25, 0x00	; 0
    3b54:	90 95       	com	r25
    3b56:	81 95       	neg	r24
    3b58:	9f 4f       	sbci	r25, 0xFF	; 255
    3b5a:	82 0f       	add	r24, r18
    3b5c:	93 1f       	adc	r25, r19
    3b5e:	e9 81       	ldd	r30, Y+1	; 0x01
    3b60:	fa 81       	ldd	r31, Y+2	; 0x02
    3b62:	97 83       	std	Z+7, r25	; 0x07
    3b64:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    3b66:	e9 81       	ldd	r30, Y+1	; 0x01
    3b68:	fa 81       	ldd	r31, Y+2	; 0x02
    3b6a:	26 81       	ldd	r18, Z+6	; 0x06
    3b6c:	37 81       	ldd	r19, Z+7	; 0x07
    3b6e:	e9 81       	ldd	r30, Y+1	; 0x01
    3b70:	fa 81       	ldd	r31, Y+2	; 0x02
    3b72:	80 81       	ld	r24, Z
    3b74:	91 81       	ldd	r25, Z+1	; 0x01
    3b76:	28 17       	cp	r18, r24
    3b78:	39 07       	cpc	r19, r25
    3b7a:	90 f4       	brcc	.+36     	; 0x3ba0 <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    3b7c:	e9 81       	ldd	r30, Y+1	; 0x01
    3b7e:	fa 81       	ldd	r31, Y+2	; 0x02
    3b80:	22 81       	ldd	r18, Z+2	; 0x02
    3b82:	33 81       	ldd	r19, Z+3	; 0x03
    3b84:	e9 81       	ldd	r30, Y+1	; 0x01
    3b86:	fa 81       	ldd	r31, Y+2	; 0x02
    3b88:	84 8d       	ldd	r24, Z+28	; 0x1c
    3b8a:	88 2f       	mov	r24, r24
    3b8c:	90 e0       	ldi	r25, 0x00	; 0
    3b8e:	90 95       	com	r25
    3b90:	81 95       	neg	r24
    3b92:	9f 4f       	sbci	r25, 0xFF	; 255
    3b94:	82 0f       	add	r24, r18
    3b96:	93 1f       	adc	r25, r19
    3b98:	e9 81       	ldd	r30, Y+1	; 0x01
    3b9a:	fa 81       	ldd	r31, Y+2	; 0x02
    3b9c:	97 83       	std	Z+7, r25	; 0x07
    3b9e:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    3ba0:	e9 81       	ldd	r30, Y+1	; 0x01
    3ba2:	fa 81       	ldd	r31, Y+2	; 0x02
    3ba4:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ba6:	8f 5f       	subi	r24, 0xFF	; 255
    3ba8:	e9 81       	ldd	r30, Y+1	; 0x01
    3baa:	fa 81       	ldd	r31, Y+2	; 0x02
    3bac:	82 8f       	std	Z+26, r24	; 0x1a
}
    3bae:	0f 90       	pop	r0
    3bb0:	0f 90       	pop	r0
    3bb2:	0f 90       	pop	r0
    3bb4:	0f 90       	pop	r0
    3bb6:	0f 90       	pop	r0
    3bb8:	cf 91       	pop	r28
    3bba:	df 91       	pop	r29
    3bbc:	08 95       	ret

00003bbe <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    3bbe:	df 93       	push	r29
    3bc0:	cf 93       	push	r28
    3bc2:	00 d0       	rcall	.+0      	; 0x3bc4 <prvCopyDataFromQueue+0x6>
    3bc4:	00 d0       	rcall	.+0      	; 0x3bc6 <prvCopyDataFromQueue+0x8>
    3bc6:	cd b7       	in	r28, 0x3d	; 61
    3bc8:	de b7       	in	r29, 0x3e	; 62
    3bca:	9a 83       	std	Y+2, r25	; 0x02
    3bcc:	89 83       	std	Y+1, r24	; 0x01
    3bce:	7c 83       	std	Y+4, r23	; 0x04
    3bd0:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    3bd2:	e9 81       	ldd	r30, Y+1	; 0x01
    3bd4:	fa 81       	ldd	r31, Y+2	; 0x02
    3bd6:	80 81       	ld	r24, Z
    3bd8:	91 81       	ldd	r25, Z+1	; 0x01
    3bda:	00 97       	sbiw	r24, 0x00	; 0
    3bdc:	89 f1       	breq	.+98     	; 0x3c40 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    3bde:	e9 81       	ldd	r30, Y+1	; 0x01
    3be0:	fa 81       	ldd	r31, Y+2	; 0x02
    3be2:	26 81       	ldd	r18, Z+6	; 0x06
    3be4:	37 81       	ldd	r19, Z+7	; 0x07
    3be6:	e9 81       	ldd	r30, Y+1	; 0x01
    3be8:	fa 81       	ldd	r31, Y+2	; 0x02
    3bea:	84 8d       	ldd	r24, Z+28	; 0x1c
    3bec:	88 2f       	mov	r24, r24
    3bee:	90 e0       	ldi	r25, 0x00	; 0
    3bf0:	82 0f       	add	r24, r18
    3bf2:	93 1f       	adc	r25, r19
    3bf4:	e9 81       	ldd	r30, Y+1	; 0x01
    3bf6:	fa 81       	ldd	r31, Y+2	; 0x02
    3bf8:	97 83       	std	Z+7, r25	; 0x07
    3bfa:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    3bfc:	e9 81       	ldd	r30, Y+1	; 0x01
    3bfe:	fa 81       	ldd	r31, Y+2	; 0x02
    3c00:	26 81       	ldd	r18, Z+6	; 0x06
    3c02:	37 81       	ldd	r19, Z+7	; 0x07
    3c04:	e9 81       	ldd	r30, Y+1	; 0x01
    3c06:	fa 81       	ldd	r31, Y+2	; 0x02
    3c08:	82 81       	ldd	r24, Z+2	; 0x02
    3c0a:	93 81       	ldd	r25, Z+3	; 0x03
    3c0c:	28 17       	cp	r18, r24
    3c0e:	39 07       	cpc	r19, r25
    3c10:	40 f0       	brcs	.+16     	; 0x3c22 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    3c12:	e9 81       	ldd	r30, Y+1	; 0x01
    3c14:	fa 81       	ldd	r31, Y+2	; 0x02
    3c16:	80 81       	ld	r24, Z
    3c18:	91 81       	ldd	r25, Z+1	; 0x01
    3c1a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c1c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c1e:	97 83       	std	Z+7, r25	; 0x07
    3c20:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    3c22:	e9 81       	ldd	r30, Y+1	; 0x01
    3c24:	fa 81       	ldd	r31, Y+2	; 0x02
    3c26:	46 81       	ldd	r20, Z+6	; 0x06
    3c28:	57 81       	ldd	r21, Z+7	; 0x07
    3c2a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c2c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c2e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3c30:	28 2f       	mov	r18, r24
    3c32:	30 e0       	ldi	r19, 0x00	; 0
    3c34:	8b 81       	ldd	r24, Y+3	; 0x03
    3c36:	9c 81       	ldd	r25, Y+4	; 0x04
    3c38:	ba 01       	movw	r22, r20
    3c3a:	a9 01       	movw	r20, r18
    3c3c:	0e 94 2a 28 	call	0x5054	; 0x5054 <memcpy>
	}
}
    3c40:	0f 90       	pop	r0
    3c42:	0f 90       	pop	r0
    3c44:	0f 90       	pop	r0
    3c46:	0f 90       	pop	r0
    3c48:	cf 91       	pop	r28
    3c4a:	df 91       	pop	r29
    3c4c:	08 95       	ret

00003c4e <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    3c4e:	df 93       	push	r29
    3c50:	cf 93       	push	r28
    3c52:	00 d0       	rcall	.+0      	; 0x3c54 <prvUnlockQueue+0x6>
    3c54:	cd b7       	in	r28, 0x3d	; 61
    3c56:	de b7       	in	r29, 0x3e	; 62
    3c58:	9a 83       	std	Y+2, r25	; 0x02
    3c5a:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3c5c:	0f b6       	in	r0, 0x3f	; 63
    3c5e:	f8 94       	cli
    3c60:	0f 92       	push	r0
    3c62:	15 c0       	rjmp	.+42     	; 0x3c8e <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3c64:	e9 81       	ldd	r30, Y+1	; 0x01
    3c66:	fa 81       	ldd	r31, Y+2	; 0x02
    3c68:	81 89       	ldd	r24, Z+17	; 0x11
    3c6a:	88 23       	and	r24, r24
    3c6c:	a9 f0       	breq	.+42     	; 0x3c98 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3c6e:	89 81       	ldd	r24, Y+1	; 0x01
    3c70:	9a 81       	ldd	r25, Y+2	; 0x02
    3c72:	41 96       	adiw	r24, 0x11	; 17
    3c74:	0e 94 5f 23 	call	0x46be	; 0x46be <xTaskRemoveFromEventList>
    3c78:	88 23       	and	r24, r24
    3c7a:	11 f0       	breq	.+4      	; 0x3c80 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    3c7c:	0e 94 3d 24 	call	0x487a	; 0x487a <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    3c80:	e9 81       	ldd	r30, Y+1	; 0x01
    3c82:	fa 81       	ldd	r31, Y+2	; 0x02
    3c84:	86 8d       	ldd	r24, Z+30	; 0x1e
    3c86:	81 50       	subi	r24, 0x01	; 1
    3c88:	e9 81       	ldd	r30, Y+1	; 0x01
    3c8a:	fa 81       	ldd	r31, Y+2	; 0x02
    3c8c:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3c8e:	e9 81       	ldd	r30, Y+1	; 0x01
    3c90:	fa 81       	ldd	r31, Y+2	; 0x02
    3c92:	86 8d       	ldd	r24, Z+30	; 0x1e
    3c94:	18 16       	cp	r1, r24
    3c96:	34 f3       	brlt	.-52     	; 0x3c64 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    3c98:	e9 81       	ldd	r30, Y+1	; 0x01
    3c9a:	fa 81       	ldd	r31, Y+2	; 0x02
    3c9c:	8f ef       	ldi	r24, 0xFF	; 255
    3c9e:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    3ca0:	0f 90       	pop	r0
    3ca2:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3ca4:	0f b6       	in	r0, 0x3f	; 63
    3ca6:	f8 94       	cli
    3ca8:	0f 92       	push	r0
    3caa:	15 c0       	rjmp	.+42     	; 0x3cd6 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3cac:	e9 81       	ldd	r30, Y+1	; 0x01
    3cae:	fa 81       	ldd	r31, Y+2	; 0x02
    3cb0:	80 85       	ldd	r24, Z+8	; 0x08
    3cb2:	88 23       	and	r24, r24
    3cb4:	a9 f0       	breq	.+42     	; 0x3ce0 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3cb6:	89 81       	ldd	r24, Y+1	; 0x01
    3cb8:	9a 81       	ldd	r25, Y+2	; 0x02
    3cba:	08 96       	adiw	r24, 0x08	; 8
    3cbc:	0e 94 5f 23 	call	0x46be	; 0x46be <xTaskRemoveFromEventList>
    3cc0:	88 23       	and	r24, r24
    3cc2:	11 f0       	breq	.+4      	; 0x3cc8 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    3cc4:	0e 94 3d 24 	call	0x487a	; 0x487a <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    3cc8:	e9 81       	ldd	r30, Y+1	; 0x01
    3cca:	fa 81       	ldd	r31, Y+2	; 0x02
    3ccc:	85 8d       	ldd	r24, Z+29	; 0x1d
    3cce:	81 50       	subi	r24, 0x01	; 1
    3cd0:	e9 81       	ldd	r30, Y+1	; 0x01
    3cd2:	fa 81       	ldd	r31, Y+2	; 0x02
    3cd4:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3cd6:	e9 81       	ldd	r30, Y+1	; 0x01
    3cd8:	fa 81       	ldd	r31, Y+2	; 0x02
    3cda:	85 8d       	ldd	r24, Z+29	; 0x1d
    3cdc:	18 16       	cp	r1, r24
    3cde:	34 f3       	brlt	.-52     	; 0x3cac <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    3ce0:	e9 81       	ldd	r30, Y+1	; 0x01
    3ce2:	fa 81       	ldd	r31, Y+2	; 0x02
    3ce4:	8f ef       	ldi	r24, 0xFF	; 255
    3ce6:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    3ce8:	0f 90       	pop	r0
    3cea:	0f be       	out	0x3f, r0	; 63
}
    3cec:	0f 90       	pop	r0
    3cee:	0f 90       	pop	r0
    3cf0:	cf 91       	pop	r28
    3cf2:	df 91       	pop	r29
    3cf4:	08 95       	ret

00003cf6 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    3cf6:	df 93       	push	r29
    3cf8:	cf 93       	push	r28
    3cfa:	00 d0       	rcall	.+0      	; 0x3cfc <prvIsQueueEmpty+0x6>
    3cfc:	0f 92       	push	r0
    3cfe:	cd b7       	in	r28, 0x3d	; 61
    3d00:	de b7       	in	r29, 0x3e	; 62
    3d02:	9b 83       	std	Y+3, r25	; 0x03
    3d04:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    3d06:	0f b6       	in	r0, 0x3f	; 63
    3d08:	f8 94       	cli
    3d0a:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    3d0c:	ea 81       	ldd	r30, Y+2	; 0x02
    3d0e:	fb 81       	ldd	r31, Y+3	; 0x03
    3d10:	82 8d       	ldd	r24, Z+26	; 0x1a
    3d12:	19 82       	std	Y+1, r1	; 0x01
    3d14:	88 23       	and	r24, r24
    3d16:	11 f4       	brne	.+4      	; 0x3d1c <prvIsQueueEmpty+0x26>
    3d18:	81 e0       	ldi	r24, 0x01	; 1
    3d1a:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    3d1c:	0f 90       	pop	r0
    3d1e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3d20:	89 81       	ldd	r24, Y+1	; 0x01
}
    3d22:	0f 90       	pop	r0
    3d24:	0f 90       	pop	r0
    3d26:	0f 90       	pop	r0
    3d28:	cf 91       	pop	r28
    3d2a:	df 91       	pop	r29
    3d2c:	08 95       	ret

00003d2e <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    3d2e:	df 93       	push	r29
    3d30:	cf 93       	push	r28
    3d32:	00 d0       	rcall	.+0      	; 0x3d34 <xQueueIsQueueEmptyFromISR+0x6>
    3d34:	0f 92       	push	r0
    3d36:	cd b7       	in	r28, 0x3d	; 61
    3d38:	de b7       	in	r29, 0x3e	; 62
    3d3a:	9b 83       	std	Y+3, r25	; 0x03
    3d3c:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    3d3e:	ea 81       	ldd	r30, Y+2	; 0x02
    3d40:	fb 81       	ldd	r31, Y+3	; 0x03
    3d42:	82 8d       	ldd	r24, Z+26	; 0x1a
    3d44:	19 82       	std	Y+1, r1	; 0x01
    3d46:	88 23       	and	r24, r24
    3d48:	11 f4       	brne	.+4      	; 0x3d4e <xQueueIsQueueEmptyFromISR+0x20>
    3d4a:	81 e0       	ldi	r24, 0x01	; 1
    3d4c:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    3d4e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3d50:	0f 90       	pop	r0
    3d52:	0f 90       	pop	r0
    3d54:	0f 90       	pop	r0
    3d56:	cf 91       	pop	r28
    3d58:	df 91       	pop	r29
    3d5a:	08 95       	ret

00003d5c <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    3d5c:	df 93       	push	r29
    3d5e:	cf 93       	push	r28
    3d60:	00 d0       	rcall	.+0      	; 0x3d62 <prvIsQueueFull+0x6>
    3d62:	0f 92       	push	r0
    3d64:	cd b7       	in	r28, 0x3d	; 61
    3d66:	de b7       	in	r29, 0x3e	; 62
    3d68:	9b 83       	std	Y+3, r25	; 0x03
    3d6a:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    3d6c:	0f b6       	in	r0, 0x3f	; 63
    3d6e:	f8 94       	cli
    3d70:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    3d72:	ea 81       	ldd	r30, Y+2	; 0x02
    3d74:	fb 81       	ldd	r31, Y+3	; 0x03
    3d76:	92 8d       	ldd	r25, Z+26	; 0x1a
    3d78:	ea 81       	ldd	r30, Y+2	; 0x02
    3d7a:	fb 81       	ldd	r31, Y+3	; 0x03
    3d7c:	83 8d       	ldd	r24, Z+27	; 0x1b
    3d7e:	19 82       	std	Y+1, r1	; 0x01
    3d80:	98 17       	cp	r25, r24
    3d82:	11 f4       	brne	.+4      	; 0x3d88 <prvIsQueueFull+0x2c>
    3d84:	81 e0       	ldi	r24, 0x01	; 1
    3d86:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    3d88:	0f 90       	pop	r0
    3d8a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3d8c:	89 81       	ldd	r24, Y+1	; 0x01
}
    3d8e:	0f 90       	pop	r0
    3d90:	0f 90       	pop	r0
    3d92:	0f 90       	pop	r0
    3d94:	cf 91       	pop	r28
    3d96:	df 91       	pop	r29
    3d98:	08 95       	ret

00003d9a <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    3d9a:	df 93       	push	r29
    3d9c:	cf 93       	push	r28
    3d9e:	00 d0       	rcall	.+0      	; 0x3da0 <xQueueIsQueueFullFromISR+0x6>
    3da0:	0f 92       	push	r0
    3da2:	cd b7       	in	r28, 0x3d	; 61
    3da4:	de b7       	in	r29, 0x3e	; 62
    3da6:	9b 83       	std	Y+3, r25	; 0x03
    3da8:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    3daa:	ea 81       	ldd	r30, Y+2	; 0x02
    3dac:	fb 81       	ldd	r31, Y+3	; 0x03
    3dae:	92 8d       	ldd	r25, Z+26	; 0x1a
    3db0:	ea 81       	ldd	r30, Y+2	; 0x02
    3db2:	fb 81       	ldd	r31, Y+3	; 0x03
    3db4:	83 8d       	ldd	r24, Z+27	; 0x1b
    3db6:	19 82       	std	Y+1, r1	; 0x01
    3db8:	98 17       	cp	r25, r24
    3dba:	11 f4       	brne	.+4      	; 0x3dc0 <xQueueIsQueueFullFromISR+0x26>
    3dbc:	81 e0       	ldi	r24, 0x01	; 1
    3dbe:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    3dc0:	89 81       	ldd	r24, Y+1	; 0x01
}
    3dc2:	0f 90       	pop	r0
    3dc4:	0f 90       	pop	r0
    3dc6:	0f 90       	pop	r0
    3dc8:	cf 91       	pop	r28
    3dca:	df 91       	pop	r29
    3dcc:	08 95       	ret

00003dce <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    3dce:	af 92       	push	r10
    3dd0:	bf 92       	push	r11
    3dd2:	cf 92       	push	r12
    3dd4:	df 92       	push	r13
    3dd6:	ef 92       	push	r14
    3dd8:	ff 92       	push	r15
    3dda:	0f 93       	push	r16
    3ddc:	1f 93       	push	r17
    3dde:	df 93       	push	r29
    3de0:	cf 93       	push	r28
    3de2:	cd b7       	in	r28, 0x3d	; 61
    3de4:	de b7       	in	r29, 0x3e	; 62
    3de6:	64 97       	sbiw	r28, 0x14	; 20
    3de8:	0f b6       	in	r0, 0x3f	; 63
    3dea:	f8 94       	cli
    3dec:	de bf       	out	0x3e, r29	; 62
    3dee:	0f be       	out	0x3f, r0	; 63
    3df0:	cd bf       	out	0x3d, r28	; 61
    3df2:	9f 83       	std	Y+7, r25	; 0x07
    3df4:	8e 83       	std	Y+6, r24	; 0x06
    3df6:	79 87       	std	Y+9, r23	; 0x09
    3df8:	68 87       	std	Y+8, r22	; 0x08
    3dfa:	5b 87       	std	Y+11, r21	; 0x0b
    3dfc:	4a 87       	std	Y+10, r20	; 0x0a
    3dfe:	3d 87       	std	Y+13, r19	; 0x0d
    3e00:	2c 87       	std	Y+12, r18	; 0x0c
    3e02:	0e 87       	std	Y+14, r16	; 0x0e
    3e04:	f8 8a       	std	Y+16, r15	; 0x10
    3e06:	ef 86       	std	Y+15, r14	; 0x0f
    3e08:	da 8a       	std	Y+18, r13	; 0x12
    3e0a:	c9 8a       	std	Y+17, r12	; 0x11
    3e0c:	bc 8a       	std	Y+20, r11	; 0x14
    3e0e:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    3e10:	8a 85       	ldd	r24, Y+10	; 0x0a
    3e12:	9b 85       	ldd	r25, Y+11	; 0x0b
    3e14:	29 89       	ldd	r18, Y+17	; 0x11
    3e16:	3a 89       	ldd	r19, Y+18	; 0x12
    3e18:	b9 01       	movw	r22, r18
    3e1a:	0e 94 70 25 	call	0x4ae0	; 0x4ae0 <prvAllocateTCBAndStack>
    3e1e:	9c 83       	std	Y+4, r25	; 0x04
    3e20:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    3e22:	8b 81       	ldd	r24, Y+3	; 0x03
    3e24:	9c 81       	ldd	r25, Y+4	; 0x04
    3e26:	00 97       	sbiw	r24, 0x00	; 0
    3e28:	09 f4       	brne	.+2      	; 0x3e2c <xTaskGenericCreate+0x5e>
    3e2a:	99 c0       	rjmp	.+306    	; 0x3f5e <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    3e2c:	eb 81       	ldd	r30, Y+3	; 0x03
    3e2e:	fc 81       	ldd	r31, Y+4	; 0x04
    3e30:	27 89       	ldd	r18, Z+23	; 0x17
    3e32:	30 8d       	ldd	r19, Z+24	; 0x18
    3e34:	8a 85       	ldd	r24, Y+10	; 0x0a
    3e36:	9b 85       	ldd	r25, Y+11	; 0x0b
    3e38:	01 97       	sbiw	r24, 0x01	; 1
    3e3a:	82 0f       	add	r24, r18
    3e3c:	93 1f       	adc	r25, r19
    3e3e:	9a 83       	std	Y+2, r25	; 0x02
    3e40:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    3e42:	8b 81       	ldd	r24, Y+3	; 0x03
    3e44:	9c 81       	ldd	r25, Y+4	; 0x04
    3e46:	28 85       	ldd	r18, Y+8	; 0x08
    3e48:	39 85       	ldd	r19, Y+9	; 0x09
    3e4a:	eb 89       	ldd	r30, Y+19	; 0x13
    3e4c:	fc 89       	ldd	r31, Y+20	; 0x14
    3e4e:	aa 85       	ldd	r26, Y+10	; 0x0a
    3e50:	bb 85       	ldd	r27, Y+11	; 0x0b
    3e52:	b9 01       	movw	r22, r18
    3e54:	4e 85       	ldd	r20, Y+14	; 0x0e
    3e56:	9f 01       	movw	r18, r30
    3e58:	8d 01       	movw	r16, r26
    3e5a:	0e 94 51 24 	call	0x48a2	; 0x48a2 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3e5e:	89 81       	ldd	r24, Y+1	; 0x01
    3e60:	9a 81       	ldd	r25, Y+2	; 0x02
    3e62:	2e 81       	ldd	r18, Y+6	; 0x06
    3e64:	3f 81       	ldd	r19, Y+7	; 0x07
    3e66:	4c 85       	ldd	r20, Y+12	; 0x0c
    3e68:	5d 85       	ldd	r21, Y+13	; 0x0d
    3e6a:	b9 01       	movw	r22, r18
    3e6c:	0e 94 9f 16 	call	0x2d3e	; 0x2d3e <pxPortInitialiseStack>
    3e70:	eb 81       	ldd	r30, Y+3	; 0x03
    3e72:	fc 81       	ldd	r31, Y+4	; 0x04
    3e74:	91 83       	std	Z+1, r25	; 0x01
    3e76:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    3e78:	8f 85       	ldd	r24, Y+15	; 0x0f
    3e7a:	98 89       	ldd	r25, Y+16	; 0x10
    3e7c:	00 97       	sbiw	r24, 0x00	; 0
    3e7e:	31 f0       	breq	.+12     	; 0x3e8c <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    3e80:	ef 85       	ldd	r30, Y+15	; 0x0f
    3e82:	f8 89       	ldd	r31, Y+16	; 0x10
    3e84:	8b 81       	ldd	r24, Y+3	; 0x03
    3e86:	9c 81       	ldd	r25, Y+4	; 0x04
    3e88:	91 83       	std	Z+1, r25	; 0x01
    3e8a:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    3e8c:	0f b6       	in	r0, 0x3f	; 63
    3e8e:	f8 94       	cli
    3e90:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    3e92:	80 91 ef 00 	lds	r24, 0x00EF
    3e96:	8f 5f       	subi	r24, 0xFF	; 255
    3e98:	80 93 ef 00 	sts	0x00EF, r24
			if( pxCurrentTCB == NULL )
    3e9c:	80 91 ec 00 	lds	r24, 0x00EC
    3ea0:	90 91 ed 00 	lds	r25, 0x00ED
    3ea4:	00 97       	sbiw	r24, 0x00	; 0
    3ea6:	69 f4       	brne	.+26     	; 0x3ec2 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    3ea8:	8b 81       	ldd	r24, Y+3	; 0x03
    3eaa:	9c 81       	ldd	r25, Y+4	; 0x04
    3eac:	90 93 ed 00 	sts	0x00ED, r25
    3eb0:	80 93 ec 00 	sts	0x00EC, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    3eb4:	80 91 ef 00 	lds	r24, 0x00EF
    3eb8:	81 30       	cpi	r24, 0x01	; 1
    3eba:	a9 f4       	brne	.+42     	; 0x3ee6 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    3ebc:	0e 94 ac 24 	call	0x4958	; 0x4958 <prvInitialiseTaskLists>
    3ec0:	12 c0       	rjmp	.+36     	; 0x3ee6 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    3ec2:	80 91 f4 00 	lds	r24, 0x00F4
    3ec6:	88 23       	and	r24, r24
    3ec8:	71 f4       	brne	.+28     	; 0x3ee6 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    3eca:	e0 91 ec 00 	lds	r30, 0x00EC
    3ece:	f0 91 ed 00 	lds	r31, 0x00ED
    3ed2:	96 89       	ldd	r25, Z+22	; 0x16
    3ed4:	8e 85       	ldd	r24, Y+14	; 0x0e
    3ed6:	89 17       	cp	r24, r25
    3ed8:	30 f0       	brcs	.+12     	; 0x3ee6 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    3eda:	8b 81       	ldd	r24, Y+3	; 0x03
    3edc:	9c 81       	ldd	r25, Y+4	; 0x04
    3ede:	90 93 ed 00 	sts	0x00ED, r25
    3ee2:	80 93 ec 00 	sts	0x00EC, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    3ee6:	eb 81       	ldd	r30, Y+3	; 0x03
    3ee8:	fc 81       	ldd	r31, Y+4	; 0x04
    3eea:	96 89       	ldd	r25, Z+22	; 0x16
    3eec:	80 91 f2 00 	lds	r24, 0x00F2
    3ef0:	89 17       	cp	r24, r25
    3ef2:	28 f4       	brcc	.+10     	; 0x3efe <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    3ef4:	eb 81       	ldd	r30, Y+3	; 0x03
    3ef6:	fc 81       	ldd	r31, Y+4	; 0x04
    3ef8:	86 89       	ldd	r24, Z+22	; 0x16
    3efa:	80 93 f2 00 	sts	0x00F2, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    3efe:	80 91 f9 00 	lds	r24, 0x00F9
    3f02:	8f 5f       	subi	r24, 0xFF	; 255
    3f04:	80 93 f9 00 	sts	0x00F9, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    3f08:	eb 81       	ldd	r30, Y+3	; 0x03
    3f0a:	fc 81       	ldd	r31, Y+4	; 0x04
    3f0c:	96 89       	ldd	r25, Z+22	; 0x16
    3f0e:	80 91 f3 00 	lds	r24, 0x00F3
    3f12:	89 17       	cp	r24, r25
    3f14:	28 f4       	brcc	.+10     	; 0x3f20 <xTaskGenericCreate+0x152>
    3f16:	eb 81       	ldd	r30, Y+3	; 0x03
    3f18:	fc 81       	ldd	r31, Y+4	; 0x04
    3f1a:	86 89       	ldd	r24, Z+22	; 0x16
    3f1c:	80 93 f3 00 	sts	0x00F3, r24
    3f20:	eb 81       	ldd	r30, Y+3	; 0x03
    3f22:	fc 81       	ldd	r31, Y+4	; 0x04
    3f24:	86 89       	ldd	r24, Z+22	; 0x16
    3f26:	28 2f       	mov	r18, r24
    3f28:	30 e0       	ldi	r19, 0x00	; 0
    3f2a:	c9 01       	movw	r24, r18
    3f2c:	88 0f       	add	r24, r24
    3f2e:	99 1f       	adc	r25, r25
    3f30:	88 0f       	add	r24, r24
    3f32:	99 1f       	adc	r25, r25
    3f34:	88 0f       	add	r24, r24
    3f36:	99 1f       	adc	r25, r25
    3f38:	82 0f       	add	r24, r18
    3f3a:	93 1f       	adc	r25, r19
    3f3c:	ac 01       	movw	r20, r24
    3f3e:	46 50       	subi	r20, 0x06	; 6
    3f40:	5f 4f       	sbci	r21, 0xFF	; 255
    3f42:	8b 81       	ldd	r24, Y+3	; 0x03
    3f44:	9c 81       	ldd	r25, Y+4	; 0x04
    3f46:	9c 01       	movw	r18, r24
    3f48:	2e 5f       	subi	r18, 0xFE	; 254
    3f4a:	3f 4f       	sbci	r19, 0xFF	; 255
    3f4c:	ca 01       	movw	r24, r20
    3f4e:	b9 01       	movw	r22, r18
    3f50:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <vListInsertEnd>

			xReturn = pdPASS;
    3f54:	81 e0       	ldi	r24, 0x01	; 1
    3f56:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    3f58:	0f 90       	pop	r0
    3f5a:	0f be       	out	0x3f, r0	; 63
    3f5c:	02 c0       	rjmp	.+4      	; 0x3f62 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3f5e:	8f ef       	ldi	r24, 0xFF	; 255
    3f60:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    3f62:	8d 81       	ldd	r24, Y+5	; 0x05
    3f64:	81 30       	cpi	r24, 0x01	; 1
    3f66:	71 f4       	brne	.+28     	; 0x3f84 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    3f68:	80 91 f4 00 	lds	r24, 0x00F4
    3f6c:	88 23       	and	r24, r24
    3f6e:	51 f0       	breq	.+20     	; 0x3f84 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    3f70:	e0 91 ec 00 	lds	r30, 0x00EC
    3f74:	f0 91 ed 00 	lds	r31, 0x00ED
    3f78:	96 89       	ldd	r25, Z+22	; 0x16
    3f7a:	8e 85       	ldd	r24, Y+14	; 0x0e
    3f7c:	98 17       	cp	r25, r24
    3f7e:	10 f4       	brcc	.+4      	; 0x3f84 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    3f80:	0e 94 5e 18 	call	0x30bc	; 0x30bc <vPortYield>
			}
		}
	}

	return xReturn;
    3f84:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3f86:	64 96       	adiw	r28, 0x14	; 20
    3f88:	0f b6       	in	r0, 0x3f	; 63
    3f8a:	f8 94       	cli
    3f8c:	de bf       	out	0x3e, r29	; 62
    3f8e:	0f be       	out	0x3f, r0	; 63
    3f90:	cd bf       	out	0x3d, r28	; 61
    3f92:	cf 91       	pop	r28
    3f94:	df 91       	pop	r29
    3f96:	1f 91       	pop	r17
    3f98:	0f 91       	pop	r16
    3f9a:	ff 90       	pop	r15
    3f9c:	ef 90       	pop	r14
    3f9e:	df 90       	pop	r13
    3fa0:	cf 90       	pop	r12
    3fa2:	bf 90       	pop	r11
    3fa4:	af 90       	pop	r10
    3fa6:	08 95       	ret

00003fa8 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    3fa8:	df 93       	push	r29
    3faa:	cf 93       	push	r28
    3fac:	00 d0       	rcall	.+0      	; 0x3fae <vTaskDelete+0x6>
    3fae:	00 d0       	rcall	.+0      	; 0x3fb0 <vTaskDelete+0x8>
    3fb0:	00 d0       	rcall	.+0      	; 0x3fb2 <vTaskDelete+0xa>
    3fb2:	cd b7       	in	r28, 0x3d	; 61
    3fb4:	de b7       	in	r29, 0x3e	; 62
    3fb6:	9c 83       	std	Y+4, r25	; 0x04
    3fb8:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    3fba:	0f b6       	in	r0, 0x3f	; 63
    3fbc:	f8 94       	cli
    3fbe:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    3fc0:	20 91 ec 00 	lds	r18, 0x00EC
    3fc4:	30 91 ed 00 	lds	r19, 0x00ED
    3fc8:	8b 81       	ldd	r24, Y+3	; 0x03
    3fca:	9c 81       	ldd	r25, Y+4	; 0x04
    3fcc:	82 17       	cp	r24, r18
    3fce:	93 07       	cpc	r25, r19
    3fd0:	11 f4       	brne	.+4      	; 0x3fd6 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    3fd2:	1c 82       	std	Y+4, r1	; 0x04
    3fd4:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    3fd6:	8b 81       	ldd	r24, Y+3	; 0x03
    3fd8:	9c 81       	ldd	r25, Y+4	; 0x04
    3fda:	00 97       	sbiw	r24, 0x00	; 0
    3fdc:	39 f4       	brne	.+14     	; 0x3fec <vTaskDelete+0x44>
    3fde:	80 91 ec 00 	lds	r24, 0x00EC
    3fe2:	90 91 ed 00 	lds	r25, 0x00ED
    3fe6:	9e 83       	std	Y+6, r25	; 0x06
    3fe8:	8d 83       	std	Y+5, r24	; 0x05
    3fea:	04 c0       	rjmp	.+8      	; 0x3ff4 <vTaskDelete+0x4c>
    3fec:	8b 81       	ldd	r24, Y+3	; 0x03
    3fee:	9c 81       	ldd	r25, Y+4	; 0x04
    3ff0:	9e 83       	std	Y+6, r25	; 0x06
    3ff2:	8d 83       	std	Y+5, r24	; 0x05
    3ff4:	8d 81       	ldd	r24, Y+5	; 0x05
    3ff6:	9e 81       	ldd	r25, Y+6	; 0x06
    3ff8:	9a 83       	std	Y+2, r25	; 0x02
    3ffa:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    3ffc:	89 81       	ldd	r24, Y+1	; 0x01
    3ffe:	9a 81       	ldd	r25, Y+2	; 0x02
    4000:	02 96       	adiw	r24, 0x02	; 2
    4002:	0e 94 56 16 	call	0x2cac	; 0x2cac <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    4006:	e9 81       	ldd	r30, Y+1	; 0x01
    4008:	fa 81       	ldd	r31, Y+2	; 0x02
    400a:	84 89       	ldd	r24, Z+20	; 0x14
    400c:	95 89       	ldd	r25, Z+21	; 0x15
    400e:	00 97       	sbiw	r24, 0x00	; 0
    4010:	29 f0       	breq	.+10     	; 0x401c <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    4012:	89 81       	ldd	r24, Y+1	; 0x01
    4014:	9a 81       	ldd	r25, Y+2	; 0x02
    4016:	0c 96       	adiw	r24, 0x0c	; 12
    4018:	0e 94 56 16 	call	0x2cac	; 0x2cac <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    401c:	89 81       	ldd	r24, Y+1	; 0x01
    401e:	9a 81       	ldd	r25, Y+2	; 0x02
    4020:	9c 01       	movw	r18, r24
    4022:	2e 5f       	subi	r18, 0xFE	; 254
    4024:	3f 4f       	sbci	r19, 0xFF	; 255
    4026:	86 e4       	ldi	r24, 0x46	; 70
    4028:	91 e0       	ldi	r25, 0x01	; 1
    402a:	b9 01       	movw	r22, r18
    402c:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    4030:	80 91 ee 00 	lds	r24, 0x00EE
    4034:	8f 5f       	subi	r24, 0xFF	; 255
    4036:	80 93 ee 00 	sts	0x00EE, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    403a:	80 91 f9 00 	lds	r24, 0x00F9
    403e:	8f 5f       	subi	r24, 0xFF	; 255
    4040:	80 93 f9 00 	sts	0x00F9, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    4044:	0f 90       	pop	r0
    4046:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    4048:	80 91 f4 00 	lds	r24, 0x00F4
    404c:	88 23       	and	r24, r24
    404e:	31 f0       	breq	.+12     	; 0x405c <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    4050:	8b 81       	ldd	r24, Y+3	; 0x03
    4052:	9c 81       	ldd	r25, Y+4	; 0x04
    4054:	00 97       	sbiw	r24, 0x00	; 0
    4056:	11 f4       	brne	.+4      	; 0x405c <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    4058:	0e 94 5e 18 	call	0x30bc	; 0x30bc <vPortYield>
			}
		}
	}
    405c:	26 96       	adiw	r28, 0x06	; 6
    405e:	0f b6       	in	r0, 0x3f	; 63
    4060:	f8 94       	cli
    4062:	de bf       	out	0x3e, r29	; 62
    4064:	0f be       	out	0x3f, r0	; 63
    4066:	cd bf       	out	0x3d, r28	; 61
    4068:	cf 91       	pop	r28
    406a:	df 91       	pop	r29
    406c:	08 95       	ret

0000406e <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    406e:	df 93       	push	r29
    4070:	cf 93       	push	r28
    4072:	cd b7       	in	r28, 0x3d	; 61
    4074:	de b7       	in	r29, 0x3e	; 62
    4076:	28 97       	sbiw	r28, 0x08	; 8
    4078:	0f b6       	in	r0, 0x3f	; 63
    407a:	f8 94       	cli
    407c:	de bf       	out	0x3e, r29	; 62
    407e:	0f be       	out	0x3f, r0	; 63
    4080:	cd bf       	out	0x3d, r28	; 61
    4082:	9e 83       	std	Y+6, r25	; 0x06
    4084:	8d 83       	std	Y+5, r24	; 0x05
    4086:	78 87       	std	Y+8, r23	; 0x08
    4088:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    408a:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    408c:	0e 94 23 21 	call	0x4246	; 0x4246 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    4090:	ed 81       	ldd	r30, Y+5	; 0x05
    4092:	fe 81       	ldd	r31, Y+6	; 0x06
    4094:	20 81       	ld	r18, Z
    4096:	31 81       	ldd	r19, Z+1	; 0x01
    4098:	8f 81       	ldd	r24, Y+7	; 0x07
    409a:	98 85       	ldd	r25, Y+8	; 0x08
    409c:	82 0f       	add	r24, r18
    409e:	93 1f       	adc	r25, r19
    40a0:	9c 83       	std	Y+4, r25	; 0x04
    40a2:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    40a4:	ed 81       	ldd	r30, Y+5	; 0x05
    40a6:	fe 81       	ldd	r31, Y+6	; 0x06
    40a8:	20 81       	ld	r18, Z
    40aa:	31 81       	ldd	r19, Z+1	; 0x01
    40ac:	80 91 f0 00 	lds	r24, 0x00F0
    40b0:	90 91 f1 00 	lds	r25, 0x00F1
    40b4:	82 17       	cp	r24, r18
    40b6:	93 07       	cpc	r25, r19
    40b8:	a8 f4       	brcc	.+42     	; 0x40e4 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    40ba:	ed 81       	ldd	r30, Y+5	; 0x05
    40bc:	fe 81       	ldd	r31, Y+6	; 0x06
    40be:	20 81       	ld	r18, Z
    40c0:	31 81       	ldd	r19, Z+1	; 0x01
    40c2:	8b 81       	ldd	r24, Y+3	; 0x03
    40c4:	9c 81       	ldd	r25, Y+4	; 0x04
    40c6:	82 17       	cp	r24, r18
    40c8:	93 07       	cpc	r25, r19
    40ca:	00 f5       	brcc	.+64     	; 0x410c <vTaskDelayUntil+0x9e>
    40cc:	20 91 f0 00 	lds	r18, 0x00F0
    40d0:	30 91 f1 00 	lds	r19, 0x00F1
    40d4:	8b 81       	ldd	r24, Y+3	; 0x03
    40d6:	9c 81       	ldd	r25, Y+4	; 0x04
    40d8:	28 17       	cp	r18, r24
    40da:	39 07       	cpc	r19, r25
    40dc:	b8 f4       	brcc	.+46     	; 0x410c <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    40de:	81 e0       	ldi	r24, 0x01	; 1
    40e0:	89 83       	std	Y+1, r24	; 0x01
    40e2:	14 c0       	rjmp	.+40     	; 0x410c <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    40e4:	ed 81       	ldd	r30, Y+5	; 0x05
    40e6:	fe 81       	ldd	r31, Y+6	; 0x06
    40e8:	20 81       	ld	r18, Z
    40ea:	31 81       	ldd	r19, Z+1	; 0x01
    40ec:	8b 81       	ldd	r24, Y+3	; 0x03
    40ee:	9c 81       	ldd	r25, Y+4	; 0x04
    40f0:	82 17       	cp	r24, r18
    40f2:	93 07       	cpc	r25, r19
    40f4:	48 f0       	brcs	.+18     	; 0x4108 <vTaskDelayUntil+0x9a>
    40f6:	20 91 f0 00 	lds	r18, 0x00F0
    40fa:	30 91 f1 00 	lds	r19, 0x00F1
    40fe:	8b 81       	ldd	r24, Y+3	; 0x03
    4100:	9c 81       	ldd	r25, Y+4	; 0x04
    4102:	28 17       	cp	r18, r24
    4104:	39 07       	cpc	r19, r25
    4106:	10 f4       	brcc	.+4      	; 0x410c <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4108:	81 e0       	ldi	r24, 0x01	; 1
    410a:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    410c:	ed 81       	ldd	r30, Y+5	; 0x05
    410e:	fe 81       	ldd	r31, Y+6	; 0x06
    4110:	8b 81       	ldd	r24, Y+3	; 0x03
    4112:	9c 81       	ldd	r25, Y+4	; 0x04
    4114:	91 83       	std	Z+1, r25	; 0x01
    4116:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    4118:	89 81       	ldd	r24, Y+1	; 0x01
    411a:	88 23       	and	r24, r24
    411c:	59 f0       	breq	.+22     	; 0x4134 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    411e:	80 91 ec 00 	lds	r24, 0x00EC
    4122:	90 91 ed 00 	lds	r25, 0x00ED
    4126:	02 96       	adiw	r24, 0x02	; 2
    4128:	0e 94 56 16 	call	0x2cac	; 0x2cac <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    412c:	8b 81       	ldd	r24, Y+3	; 0x03
    412e:	9c 81       	ldd	r25, Y+4	; 0x04
    4130:	0e 94 27 25 	call	0x4a4e	; 0x4a4e <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    4134:	0e 94 2f 21 	call	0x425e	; 0x425e <xTaskResumeAll>
    4138:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    413a:	8a 81       	ldd	r24, Y+2	; 0x02
    413c:	88 23       	and	r24, r24
    413e:	11 f4       	brne	.+4      	; 0x4144 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    4140:	0e 94 5e 18 	call	0x30bc	; 0x30bc <vPortYield>
		}
	}
    4144:	28 96       	adiw	r28, 0x08	; 8
    4146:	0f b6       	in	r0, 0x3f	; 63
    4148:	f8 94       	cli
    414a:	de bf       	out	0x3e, r29	; 62
    414c:	0f be       	out	0x3f, r0	; 63
    414e:	cd bf       	out	0x3d, r28	; 61
    4150:	cf 91       	pop	r28
    4152:	df 91       	pop	r29
    4154:	08 95       	ret

00004156 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    4156:	df 93       	push	r29
    4158:	cf 93       	push	r28
    415a:	00 d0       	rcall	.+0      	; 0x415c <vTaskDelay+0x6>
    415c:	00 d0       	rcall	.+0      	; 0x415e <vTaskDelay+0x8>
    415e:	0f 92       	push	r0
    4160:	cd b7       	in	r28, 0x3d	; 61
    4162:	de b7       	in	r29, 0x3e	; 62
    4164:	9d 83       	std	Y+5, r25	; 0x05
    4166:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    4168:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    416a:	8c 81       	ldd	r24, Y+4	; 0x04
    416c:	9d 81       	ldd	r25, Y+5	; 0x05
    416e:	00 97       	sbiw	r24, 0x00	; 0
    4170:	d1 f0       	breq	.+52     	; 0x41a6 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    4172:	0e 94 23 21 	call	0x4246	; 0x4246 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    4176:	20 91 f0 00 	lds	r18, 0x00F0
    417a:	30 91 f1 00 	lds	r19, 0x00F1
    417e:	8c 81       	ldd	r24, Y+4	; 0x04
    4180:	9d 81       	ldd	r25, Y+5	; 0x05
    4182:	82 0f       	add	r24, r18
    4184:	93 1f       	adc	r25, r19
    4186:	9b 83       	std	Y+3, r25	; 0x03
    4188:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    418a:	80 91 ec 00 	lds	r24, 0x00EC
    418e:	90 91 ed 00 	lds	r25, 0x00ED
    4192:	02 96       	adiw	r24, 0x02	; 2
    4194:	0e 94 56 16 	call	0x2cac	; 0x2cac <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    4198:	8a 81       	ldd	r24, Y+2	; 0x02
    419a:	9b 81       	ldd	r25, Y+3	; 0x03
    419c:	0e 94 27 25 	call	0x4a4e	; 0x4a4e <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    41a0:	0e 94 2f 21 	call	0x425e	; 0x425e <xTaskResumeAll>
    41a4:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    41a6:	89 81       	ldd	r24, Y+1	; 0x01
    41a8:	88 23       	and	r24, r24
    41aa:	11 f4       	brne	.+4      	; 0x41b0 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    41ac:	0e 94 5e 18 	call	0x30bc	; 0x30bc <vPortYield>
		}
	}
    41b0:	0f 90       	pop	r0
    41b2:	0f 90       	pop	r0
    41b4:	0f 90       	pop	r0
    41b6:	0f 90       	pop	r0
    41b8:	0f 90       	pop	r0
    41ba:	cf 91       	pop	r28
    41bc:	df 91       	pop	r29
    41be:	08 95       	ret

000041c0 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    41c0:	af 92       	push	r10
    41c2:	bf 92       	push	r11
    41c4:	cf 92       	push	r12
    41c6:	df 92       	push	r13
    41c8:	ef 92       	push	r14
    41ca:	ff 92       	push	r15
    41cc:	0f 93       	push	r16
    41ce:	df 93       	push	r29
    41d0:	cf 93       	push	r28
    41d2:	0f 92       	push	r0
    41d4:	cd b7       	in	r28, 0x3d	; 61
    41d6:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    41d8:	2c e9       	ldi	r18, 0x9C	; 156
    41da:	30 e0       	ldi	r19, 0x00	; 0
    41dc:	87 e4       	ldi	r24, 0x47	; 71
    41de:	94 e2       	ldi	r25, 0x24	; 36
    41e0:	b9 01       	movw	r22, r18
    41e2:	45 e5       	ldi	r20, 0x55	; 85
    41e4:	50 e0       	ldi	r21, 0x00	; 0
    41e6:	20 e0       	ldi	r18, 0x00	; 0
    41e8:	30 e0       	ldi	r19, 0x00	; 0
    41ea:	00 e0       	ldi	r16, 0x00	; 0
    41ec:	ee 24       	eor	r14, r14
    41ee:	ff 24       	eor	r15, r15
    41f0:	cc 24       	eor	r12, r12
    41f2:	dd 24       	eor	r13, r13
    41f4:	aa 24       	eor	r10, r10
    41f6:	bb 24       	eor	r11, r11
    41f8:	0e 94 e7 1e 	call	0x3dce	; 0x3dce <xTaskGenericCreate>
    41fc:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    41fe:	89 81       	ldd	r24, Y+1	; 0x01
    4200:	81 30       	cpi	r24, 0x01	; 1
    4202:	51 f4       	brne	.+20     	; 0x4218 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    4204:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    4206:	81 e0       	ldi	r24, 0x01	; 1
    4208:	80 93 f4 00 	sts	0x00F4, r24
		xTickCount = ( portTickType ) 0U;
    420c:	10 92 f1 00 	sts	0x00F1, r1
    4210:	10 92 f0 00 	sts	0x00F0, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    4214:	0e 94 22 18 	call	0x3044	; 0x3044 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    4218:	0f 90       	pop	r0
    421a:	cf 91       	pop	r28
    421c:	df 91       	pop	r29
    421e:	0f 91       	pop	r16
    4220:	ff 90       	pop	r15
    4222:	ef 90       	pop	r14
    4224:	df 90       	pop	r13
    4226:	cf 90       	pop	r12
    4228:	bf 90       	pop	r11
    422a:	af 90       	pop	r10
    422c:	08 95       	ret

0000422e <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    422e:	df 93       	push	r29
    4230:	cf 93       	push	r28
    4232:	cd b7       	in	r28, 0x3d	; 61
    4234:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    4236:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    4238:	10 92 f4 00 	sts	0x00F4, r1
	vPortEndScheduler();
    423c:	0e 94 57 18 	call	0x30ae	; 0x30ae <vPortEndScheduler>
}
    4240:	cf 91       	pop	r28
    4242:	df 91       	pop	r29
    4244:	08 95       	ret

00004246 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    4246:	df 93       	push	r29
    4248:	cf 93       	push	r28
    424a:	cd b7       	in	r28, 0x3d	; 61
    424c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    424e:	80 91 f5 00 	lds	r24, 0x00F5
    4252:	8f 5f       	subi	r24, 0xFF	; 255
    4254:	80 93 f5 00 	sts	0x00F5, r24
}
    4258:	cf 91       	pop	r28
    425a:	df 91       	pop	r29
    425c:	08 95       	ret

0000425e <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    425e:	df 93       	push	r29
    4260:	cf 93       	push	r28
    4262:	00 d0       	rcall	.+0      	; 0x4264 <xTaskResumeAll+0x6>
    4264:	00 d0       	rcall	.+0      	; 0x4266 <xTaskResumeAll+0x8>
    4266:	cd b7       	in	r28, 0x3d	; 61
    4268:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    426a:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    426c:	0f b6       	in	r0, 0x3f	; 63
    426e:	f8 94       	cli
    4270:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    4272:	80 91 f5 00 	lds	r24, 0x00F5
    4276:	81 50       	subi	r24, 0x01	; 1
    4278:	80 93 f5 00 	sts	0x00F5, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    427c:	80 91 f5 00 	lds	r24, 0x00F5
    4280:	88 23       	and	r24, r24
    4282:	09 f0       	breq	.+2      	; 0x4286 <xTaskResumeAll+0x28>
    4284:	6c c0       	rjmp	.+216    	; 0x435e <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    4286:	80 91 ef 00 	lds	r24, 0x00EF
    428a:	88 23       	and	r24, r24
    428c:	09 f4       	brne	.+2      	; 0x4290 <xTaskResumeAll+0x32>
    428e:	67 c0       	rjmp	.+206    	; 0x435e <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    4290:	19 82       	std	Y+1, r1	; 0x01
    4292:	41 c0       	rjmp	.+130    	; 0x4316 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    4294:	e0 91 42 01 	lds	r30, 0x0142
    4298:	f0 91 43 01 	lds	r31, 0x0143
    429c:	86 81       	ldd	r24, Z+6	; 0x06
    429e:	97 81       	ldd	r25, Z+7	; 0x07
    42a0:	9c 83       	std	Y+4, r25	; 0x04
    42a2:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    42a4:	8b 81       	ldd	r24, Y+3	; 0x03
    42a6:	9c 81       	ldd	r25, Y+4	; 0x04
    42a8:	0c 96       	adiw	r24, 0x0c	; 12
    42aa:	0e 94 56 16 	call	0x2cac	; 0x2cac <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    42ae:	8b 81       	ldd	r24, Y+3	; 0x03
    42b0:	9c 81       	ldd	r25, Y+4	; 0x04
    42b2:	02 96       	adiw	r24, 0x02	; 2
    42b4:	0e 94 56 16 	call	0x2cac	; 0x2cac <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    42b8:	eb 81       	ldd	r30, Y+3	; 0x03
    42ba:	fc 81       	ldd	r31, Y+4	; 0x04
    42bc:	96 89       	ldd	r25, Z+22	; 0x16
    42be:	80 91 f3 00 	lds	r24, 0x00F3
    42c2:	89 17       	cp	r24, r25
    42c4:	28 f4       	brcc	.+10     	; 0x42d0 <xTaskResumeAll+0x72>
    42c6:	eb 81       	ldd	r30, Y+3	; 0x03
    42c8:	fc 81       	ldd	r31, Y+4	; 0x04
    42ca:	86 89       	ldd	r24, Z+22	; 0x16
    42cc:	80 93 f3 00 	sts	0x00F3, r24
    42d0:	eb 81       	ldd	r30, Y+3	; 0x03
    42d2:	fc 81       	ldd	r31, Y+4	; 0x04
    42d4:	86 89       	ldd	r24, Z+22	; 0x16
    42d6:	28 2f       	mov	r18, r24
    42d8:	30 e0       	ldi	r19, 0x00	; 0
    42da:	c9 01       	movw	r24, r18
    42dc:	88 0f       	add	r24, r24
    42de:	99 1f       	adc	r25, r25
    42e0:	88 0f       	add	r24, r24
    42e2:	99 1f       	adc	r25, r25
    42e4:	88 0f       	add	r24, r24
    42e6:	99 1f       	adc	r25, r25
    42e8:	82 0f       	add	r24, r18
    42ea:	93 1f       	adc	r25, r19
    42ec:	86 50       	subi	r24, 0x06	; 6
    42ee:	9f 4f       	sbci	r25, 0xFF	; 255
    42f0:	2b 81       	ldd	r18, Y+3	; 0x03
    42f2:	3c 81       	ldd	r19, Y+4	; 0x04
    42f4:	2e 5f       	subi	r18, 0xFE	; 254
    42f6:	3f 4f       	sbci	r19, 0xFF	; 255
    42f8:	b9 01       	movw	r22, r18
    42fa:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    42fe:	eb 81       	ldd	r30, Y+3	; 0x03
    4300:	fc 81       	ldd	r31, Y+4	; 0x04
    4302:	96 89       	ldd	r25, Z+22	; 0x16
    4304:	e0 91 ec 00 	lds	r30, 0x00EC
    4308:	f0 91 ed 00 	lds	r31, 0x00ED
    430c:	86 89       	ldd	r24, Z+22	; 0x16
    430e:	98 17       	cp	r25, r24
    4310:	10 f0       	brcs	.+4      	; 0x4316 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    4312:	81 e0       	ldi	r24, 0x01	; 1
    4314:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    4316:	80 91 3d 01 	lds	r24, 0x013D
    431a:	88 23       	and	r24, r24
    431c:	09 f0       	breq	.+2      	; 0x4320 <xTaskResumeAll+0xc2>
    431e:	ba cf       	rjmp	.-140    	; 0x4294 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    4320:	80 91 f6 00 	lds	r24, 0x00F6
    4324:	88 23       	and	r24, r24
    4326:	71 f0       	breq	.+28     	; 0x4344 <xTaskResumeAll+0xe6>
    4328:	07 c0       	rjmp	.+14     	; 0x4338 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    432a:	0e 94 ee 21 	call	0x43dc	; 0x43dc <vTaskIncrementTick>
						--uxMissedTicks;
    432e:	80 91 f6 00 	lds	r24, 0x00F6
    4332:	81 50       	subi	r24, 0x01	; 1
    4334:	80 93 f6 00 	sts	0x00F6, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    4338:	80 91 f6 00 	lds	r24, 0x00F6
    433c:	88 23       	and	r24, r24
    433e:	a9 f7       	brne	.-22     	; 0x432a <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    4340:	81 e0       	ldi	r24, 0x01	; 1
    4342:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    4344:	89 81       	ldd	r24, Y+1	; 0x01
    4346:	81 30       	cpi	r24, 0x01	; 1
    4348:	21 f0       	breq	.+8      	; 0x4352 <xTaskResumeAll+0xf4>
    434a:	80 91 f7 00 	lds	r24, 0x00F7
    434e:	81 30       	cpi	r24, 0x01	; 1
    4350:	31 f4       	brne	.+12     	; 0x435e <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    4352:	81 e0       	ldi	r24, 0x01	; 1
    4354:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    4356:	10 92 f7 00 	sts	0x00F7, r1
					portYIELD_WITHIN_API();
    435a:	0e 94 5e 18 	call	0x30bc	; 0x30bc <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    435e:	0f 90       	pop	r0
    4360:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    4362:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4364:	0f 90       	pop	r0
    4366:	0f 90       	pop	r0
    4368:	0f 90       	pop	r0
    436a:	0f 90       	pop	r0
    436c:	cf 91       	pop	r28
    436e:	df 91       	pop	r29
    4370:	08 95       	ret

00004372 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    4372:	df 93       	push	r29
    4374:	cf 93       	push	r28
    4376:	00 d0       	rcall	.+0      	; 0x4378 <xTaskGetTickCount+0x6>
    4378:	cd b7       	in	r28, 0x3d	; 61
    437a:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    437c:	0f b6       	in	r0, 0x3f	; 63
    437e:	f8 94       	cli
    4380:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    4382:	80 91 f0 00 	lds	r24, 0x00F0
    4386:	90 91 f1 00 	lds	r25, 0x00F1
    438a:	9a 83       	std	Y+2, r25	; 0x02
    438c:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    438e:	0f 90       	pop	r0
    4390:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    4392:	89 81       	ldd	r24, Y+1	; 0x01
    4394:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4396:	0f 90       	pop	r0
    4398:	0f 90       	pop	r0
    439a:	cf 91       	pop	r28
    439c:	df 91       	pop	r29
    439e:	08 95       	ret

000043a0 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    43a0:	df 93       	push	r29
    43a2:	cf 93       	push	r28
    43a4:	00 d0       	rcall	.+0      	; 0x43a6 <xTaskGetTickCountFromISR+0x6>
    43a6:	0f 92       	push	r0
    43a8:	cd b7       	in	r28, 0x3d	; 61
    43aa:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    43ac:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    43ae:	80 91 f0 00 	lds	r24, 0x00F0
    43b2:	90 91 f1 00 	lds	r25, 0x00F1
    43b6:	9b 83       	std	Y+3, r25	; 0x03
    43b8:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    43ba:	8a 81       	ldd	r24, Y+2	; 0x02
    43bc:	9b 81       	ldd	r25, Y+3	; 0x03
}
    43be:	0f 90       	pop	r0
    43c0:	0f 90       	pop	r0
    43c2:	0f 90       	pop	r0
    43c4:	cf 91       	pop	r28
    43c6:	df 91       	pop	r29
    43c8:	08 95       	ret

000043ca <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    43ca:	df 93       	push	r29
    43cc:	cf 93       	push	r28
    43ce:	cd b7       	in	r28, 0x3d	; 61
    43d0:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    43d2:	80 91 ef 00 	lds	r24, 0x00EF
}
    43d6:	cf 91       	pop	r28
    43d8:	df 91       	pop	r29
    43da:	08 95       	ret

000043dc <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    43dc:	df 93       	push	r29
    43de:	cf 93       	push	r28
    43e0:	00 d0       	rcall	.+0      	; 0x43e2 <vTaskIncrementTick+0x6>
    43e2:	00 d0       	rcall	.+0      	; 0x43e4 <vTaskIncrementTick+0x8>
    43e4:	00 d0       	rcall	.+0      	; 0x43e6 <vTaskIncrementTick+0xa>
    43e6:	cd b7       	in	r28, 0x3d	; 61
    43e8:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    43ea:	80 91 f5 00 	lds	r24, 0x00F5
    43ee:	88 23       	and	r24, r24
    43f0:	09 f0       	breq	.+2      	; 0x43f4 <vTaskIncrementTick+0x18>
    43f2:	bb c0       	rjmp	.+374    	; 0x456a <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    43f4:	80 91 f0 00 	lds	r24, 0x00F0
    43f8:	90 91 f1 00 	lds	r25, 0x00F1
    43fc:	01 96       	adiw	r24, 0x01	; 1
    43fe:	90 93 f1 00 	sts	0x00F1, r25
    4402:	80 93 f0 00 	sts	0x00F0, r24
		if( xTickCount == ( portTickType ) 0U )
    4406:	80 91 f0 00 	lds	r24, 0x00F0
    440a:	90 91 f1 00 	lds	r25, 0x00F1
    440e:	00 97       	sbiw	r24, 0x00	; 0
    4410:	d1 f5       	brne	.+116    	; 0x4486 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    4412:	80 91 39 01 	lds	r24, 0x0139
    4416:	90 91 3a 01 	lds	r25, 0x013A
    441a:	9c 83       	std	Y+4, r25	; 0x04
    441c:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    441e:	80 91 3b 01 	lds	r24, 0x013B
    4422:	90 91 3c 01 	lds	r25, 0x013C
    4426:	90 93 3a 01 	sts	0x013A, r25
    442a:	80 93 39 01 	sts	0x0139, r24
			pxOverflowDelayedTaskList = pxTemp;
    442e:	8b 81       	ldd	r24, Y+3	; 0x03
    4430:	9c 81       	ldd	r25, Y+4	; 0x04
    4432:	90 93 3c 01 	sts	0x013C, r25
    4436:	80 93 3b 01 	sts	0x013B, r24
			xNumOfOverflows++;
    443a:	80 91 f8 00 	lds	r24, 0x00F8
    443e:	8f 5f       	subi	r24, 0xFF	; 255
    4440:	80 93 f8 00 	sts	0x00F8, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4444:	e0 91 39 01 	lds	r30, 0x0139
    4448:	f0 91 3a 01 	lds	r31, 0x013A
    444c:	80 81       	ld	r24, Z
    444e:	88 23       	and	r24, r24
    4450:	39 f4       	brne	.+14     	; 0x4460 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    4452:	8f ef       	ldi	r24, 0xFF	; 255
    4454:	9f ef       	ldi	r25, 0xFF	; 255
    4456:	90 93 b0 00 	sts	0x00B0, r25
    445a:	80 93 af 00 	sts	0x00AF, r24
    445e:	13 c0       	rjmp	.+38     	; 0x4486 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    4460:	e0 91 39 01 	lds	r30, 0x0139
    4464:	f0 91 3a 01 	lds	r31, 0x013A
    4468:	05 80       	ldd	r0, Z+5	; 0x05
    446a:	f6 81       	ldd	r31, Z+6	; 0x06
    446c:	e0 2d       	mov	r30, r0
    446e:	86 81       	ldd	r24, Z+6	; 0x06
    4470:	97 81       	ldd	r25, Z+7	; 0x07
    4472:	9e 83       	std	Y+6, r25	; 0x06
    4474:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    4476:	ed 81       	ldd	r30, Y+5	; 0x05
    4478:	fe 81       	ldd	r31, Y+6	; 0x06
    447a:	82 81       	ldd	r24, Z+2	; 0x02
    447c:	93 81       	ldd	r25, Z+3	; 0x03
    447e:	90 93 b0 00 	sts	0x00B0, r25
    4482:	80 93 af 00 	sts	0x00AF, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    4486:	20 91 f0 00 	lds	r18, 0x00F0
    448a:	30 91 f1 00 	lds	r19, 0x00F1
    448e:	80 91 af 00 	lds	r24, 0x00AF
    4492:	90 91 b0 00 	lds	r25, 0x00B0
    4496:	28 17       	cp	r18, r24
    4498:	39 07       	cpc	r19, r25
    449a:	08 f4       	brcc	.+2      	; 0x449e <vTaskIncrementTick+0xc2>
    449c:	6b c0       	rjmp	.+214    	; 0x4574 <vTaskIncrementTick+0x198>
    449e:	e0 91 39 01 	lds	r30, 0x0139
    44a2:	f0 91 3a 01 	lds	r31, 0x013A
    44a6:	80 81       	ld	r24, Z
    44a8:	88 23       	and	r24, r24
    44aa:	39 f4       	brne	.+14     	; 0x44ba <vTaskIncrementTick+0xde>
    44ac:	8f ef       	ldi	r24, 0xFF	; 255
    44ae:	9f ef       	ldi	r25, 0xFF	; 255
    44b0:	90 93 b0 00 	sts	0x00B0, r25
    44b4:	80 93 af 00 	sts	0x00AF, r24
    44b8:	5d c0       	rjmp	.+186    	; 0x4574 <vTaskIncrementTick+0x198>
    44ba:	e0 91 39 01 	lds	r30, 0x0139
    44be:	f0 91 3a 01 	lds	r31, 0x013A
    44c2:	05 80       	ldd	r0, Z+5	; 0x05
    44c4:	f6 81       	ldd	r31, Z+6	; 0x06
    44c6:	e0 2d       	mov	r30, r0
    44c8:	86 81       	ldd	r24, Z+6	; 0x06
    44ca:	97 81       	ldd	r25, Z+7	; 0x07
    44cc:	9e 83       	std	Y+6, r25	; 0x06
    44ce:	8d 83       	std	Y+5, r24	; 0x05
    44d0:	ed 81       	ldd	r30, Y+5	; 0x05
    44d2:	fe 81       	ldd	r31, Y+6	; 0x06
    44d4:	82 81       	ldd	r24, Z+2	; 0x02
    44d6:	93 81       	ldd	r25, Z+3	; 0x03
    44d8:	9a 83       	std	Y+2, r25	; 0x02
    44da:	89 83       	std	Y+1, r24	; 0x01
    44dc:	20 91 f0 00 	lds	r18, 0x00F0
    44e0:	30 91 f1 00 	lds	r19, 0x00F1
    44e4:	89 81       	ldd	r24, Y+1	; 0x01
    44e6:	9a 81       	ldd	r25, Y+2	; 0x02
    44e8:	28 17       	cp	r18, r24
    44ea:	39 07       	cpc	r19, r25
    44ec:	38 f4       	brcc	.+14     	; 0x44fc <vTaskIncrementTick+0x120>
    44ee:	89 81       	ldd	r24, Y+1	; 0x01
    44f0:	9a 81       	ldd	r25, Y+2	; 0x02
    44f2:	90 93 b0 00 	sts	0x00B0, r25
    44f6:	80 93 af 00 	sts	0x00AF, r24
    44fa:	3c c0       	rjmp	.+120    	; 0x4574 <vTaskIncrementTick+0x198>
    44fc:	8d 81       	ldd	r24, Y+5	; 0x05
    44fe:	9e 81       	ldd	r25, Y+6	; 0x06
    4500:	02 96       	adiw	r24, 0x02	; 2
    4502:	0e 94 56 16 	call	0x2cac	; 0x2cac <vListRemove>
    4506:	ed 81       	ldd	r30, Y+5	; 0x05
    4508:	fe 81       	ldd	r31, Y+6	; 0x06
    450a:	84 89       	ldd	r24, Z+20	; 0x14
    450c:	95 89       	ldd	r25, Z+21	; 0x15
    450e:	00 97       	sbiw	r24, 0x00	; 0
    4510:	29 f0       	breq	.+10     	; 0x451c <vTaskIncrementTick+0x140>
    4512:	8d 81       	ldd	r24, Y+5	; 0x05
    4514:	9e 81       	ldd	r25, Y+6	; 0x06
    4516:	0c 96       	adiw	r24, 0x0c	; 12
    4518:	0e 94 56 16 	call	0x2cac	; 0x2cac <vListRemove>
    451c:	ed 81       	ldd	r30, Y+5	; 0x05
    451e:	fe 81       	ldd	r31, Y+6	; 0x06
    4520:	96 89       	ldd	r25, Z+22	; 0x16
    4522:	80 91 f3 00 	lds	r24, 0x00F3
    4526:	89 17       	cp	r24, r25
    4528:	28 f4       	brcc	.+10     	; 0x4534 <vTaskIncrementTick+0x158>
    452a:	ed 81       	ldd	r30, Y+5	; 0x05
    452c:	fe 81       	ldd	r31, Y+6	; 0x06
    452e:	86 89       	ldd	r24, Z+22	; 0x16
    4530:	80 93 f3 00 	sts	0x00F3, r24
    4534:	ed 81       	ldd	r30, Y+5	; 0x05
    4536:	fe 81       	ldd	r31, Y+6	; 0x06
    4538:	86 89       	ldd	r24, Z+22	; 0x16
    453a:	28 2f       	mov	r18, r24
    453c:	30 e0       	ldi	r19, 0x00	; 0
    453e:	c9 01       	movw	r24, r18
    4540:	88 0f       	add	r24, r24
    4542:	99 1f       	adc	r25, r25
    4544:	88 0f       	add	r24, r24
    4546:	99 1f       	adc	r25, r25
    4548:	88 0f       	add	r24, r24
    454a:	99 1f       	adc	r25, r25
    454c:	82 0f       	add	r24, r18
    454e:	93 1f       	adc	r25, r19
    4550:	ac 01       	movw	r20, r24
    4552:	46 50       	subi	r20, 0x06	; 6
    4554:	5f 4f       	sbci	r21, 0xFF	; 255
    4556:	8d 81       	ldd	r24, Y+5	; 0x05
    4558:	9e 81       	ldd	r25, Y+6	; 0x06
    455a:	9c 01       	movw	r18, r24
    455c:	2e 5f       	subi	r18, 0xFE	; 254
    455e:	3f 4f       	sbci	r19, 0xFF	; 255
    4560:	ca 01       	movw	r24, r20
    4562:	b9 01       	movw	r22, r18
    4564:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <vListInsertEnd>
    4568:	9a cf       	rjmp	.-204    	; 0x449e <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    456a:	80 91 f6 00 	lds	r24, 0x00F6
    456e:	8f 5f       	subi	r24, 0xFF	; 255
    4570:	80 93 f6 00 	sts	0x00F6, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    4574:	26 96       	adiw	r28, 0x06	; 6
    4576:	0f b6       	in	r0, 0x3f	; 63
    4578:	f8 94       	cli
    457a:	de bf       	out	0x3e, r29	; 62
    457c:	0f be       	out	0x3f, r0	; 63
    457e:	cd bf       	out	0x3d, r28	; 61
    4580:	cf 91       	pop	r28
    4582:	df 91       	pop	r29
    4584:	08 95       	ret

00004586 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    4586:	df 93       	push	r29
    4588:	cf 93       	push	r28
    458a:	00 d0       	rcall	.+0      	; 0x458c <vTaskSwitchContext+0x6>
    458c:	cd b7       	in	r28, 0x3d	; 61
    458e:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    4590:	80 91 f5 00 	lds	r24, 0x00F5
    4594:	88 23       	and	r24, r24
    4596:	49 f0       	breq	.+18     	; 0x45aa <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    4598:	81 e0       	ldi	r24, 0x01	; 1
    459a:	80 93 f7 00 	sts	0x00F7, r24
    459e:	54 c0       	rjmp	.+168    	; 0x4648 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    45a0:	80 91 f3 00 	lds	r24, 0x00F3
    45a4:	81 50       	subi	r24, 0x01	; 1
    45a6:	80 93 f3 00 	sts	0x00F3, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    45aa:	80 91 f3 00 	lds	r24, 0x00F3
    45ae:	28 2f       	mov	r18, r24
    45b0:	30 e0       	ldi	r19, 0x00	; 0
    45b2:	c9 01       	movw	r24, r18
    45b4:	88 0f       	add	r24, r24
    45b6:	99 1f       	adc	r25, r25
    45b8:	88 0f       	add	r24, r24
    45ba:	99 1f       	adc	r25, r25
    45bc:	88 0f       	add	r24, r24
    45be:	99 1f       	adc	r25, r25
    45c0:	82 0f       	add	r24, r18
    45c2:	93 1f       	adc	r25, r19
    45c4:	fc 01       	movw	r30, r24
    45c6:	e6 50       	subi	r30, 0x06	; 6
    45c8:	ff 4f       	sbci	r31, 0xFF	; 255
    45ca:	80 81       	ld	r24, Z
    45cc:	88 23       	and	r24, r24
    45ce:	41 f3       	breq	.-48     	; 0x45a0 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    45d0:	80 91 f3 00 	lds	r24, 0x00F3
    45d4:	28 2f       	mov	r18, r24
    45d6:	30 e0       	ldi	r19, 0x00	; 0
    45d8:	c9 01       	movw	r24, r18
    45da:	88 0f       	add	r24, r24
    45dc:	99 1f       	adc	r25, r25
    45de:	88 0f       	add	r24, r24
    45e0:	99 1f       	adc	r25, r25
    45e2:	88 0f       	add	r24, r24
    45e4:	99 1f       	adc	r25, r25
    45e6:	82 0f       	add	r24, r18
    45e8:	93 1f       	adc	r25, r19
    45ea:	86 50       	subi	r24, 0x06	; 6
    45ec:	9f 4f       	sbci	r25, 0xFF	; 255
    45ee:	9a 83       	std	Y+2, r25	; 0x02
    45f0:	89 83       	std	Y+1, r24	; 0x01
    45f2:	e9 81       	ldd	r30, Y+1	; 0x01
    45f4:	fa 81       	ldd	r31, Y+2	; 0x02
    45f6:	01 80       	ldd	r0, Z+1	; 0x01
    45f8:	f2 81       	ldd	r31, Z+2	; 0x02
    45fa:	e0 2d       	mov	r30, r0
    45fc:	82 81       	ldd	r24, Z+2	; 0x02
    45fe:	93 81       	ldd	r25, Z+3	; 0x03
    4600:	e9 81       	ldd	r30, Y+1	; 0x01
    4602:	fa 81       	ldd	r31, Y+2	; 0x02
    4604:	92 83       	std	Z+2, r25	; 0x02
    4606:	81 83       	std	Z+1, r24	; 0x01
    4608:	e9 81       	ldd	r30, Y+1	; 0x01
    460a:	fa 81       	ldd	r31, Y+2	; 0x02
    460c:	21 81       	ldd	r18, Z+1	; 0x01
    460e:	32 81       	ldd	r19, Z+2	; 0x02
    4610:	89 81       	ldd	r24, Y+1	; 0x01
    4612:	9a 81       	ldd	r25, Y+2	; 0x02
    4614:	03 96       	adiw	r24, 0x03	; 3
    4616:	28 17       	cp	r18, r24
    4618:	39 07       	cpc	r19, r25
    461a:	59 f4       	brne	.+22     	; 0x4632 <vTaskSwitchContext+0xac>
    461c:	e9 81       	ldd	r30, Y+1	; 0x01
    461e:	fa 81       	ldd	r31, Y+2	; 0x02
    4620:	01 80       	ldd	r0, Z+1	; 0x01
    4622:	f2 81       	ldd	r31, Z+2	; 0x02
    4624:	e0 2d       	mov	r30, r0
    4626:	82 81       	ldd	r24, Z+2	; 0x02
    4628:	93 81       	ldd	r25, Z+3	; 0x03
    462a:	e9 81       	ldd	r30, Y+1	; 0x01
    462c:	fa 81       	ldd	r31, Y+2	; 0x02
    462e:	92 83       	std	Z+2, r25	; 0x02
    4630:	81 83       	std	Z+1, r24	; 0x01
    4632:	e9 81       	ldd	r30, Y+1	; 0x01
    4634:	fa 81       	ldd	r31, Y+2	; 0x02
    4636:	01 80       	ldd	r0, Z+1	; 0x01
    4638:	f2 81       	ldd	r31, Z+2	; 0x02
    463a:	e0 2d       	mov	r30, r0
    463c:	86 81       	ldd	r24, Z+6	; 0x06
    463e:	97 81       	ldd	r25, Z+7	; 0x07
    4640:	90 93 ed 00 	sts	0x00ED, r25
    4644:	80 93 ec 00 	sts	0x00EC, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    4648:	0f 90       	pop	r0
    464a:	0f 90       	pop	r0
    464c:	cf 91       	pop	r28
    464e:	df 91       	pop	r29
    4650:	08 95       	ret

00004652 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    4652:	df 93       	push	r29
    4654:	cf 93       	push	r28
    4656:	00 d0       	rcall	.+0      	; 0x4658 <vTaskPlaceOnEventList+0x6>
    4658:	00 d0       	rcall	.+0      	; 0x465a <vTaskPlaceOnEventList+0x8>
    465a:	00 d0       	rcall	.+0      	; 0x465c <vTaskPlaceOnEventList+0xa>
    465c:	cd b7       	in	r28, 0x3d	; 61
    465e:	de b7       	in	r29, 0x3e	; 62
    4660:	9c 83       	std	Y+4, r25	; 0x04
    4662:	8b 83       	std	Y+3, r24	; 0x03
    4664:	7e 83       	std	Y+6, r23	; 0x06
    4666:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    4668:	4b 81       	ldd	r20, Y+3	; 0x03
    466a:	5c 81       	ldd	r21, Y+4	; 0x04
    466c:	80 91 ec 00 	lds	r24, 0x00EC
    4670:	90 91 ed 00 	lds	r25, 0x00ED
    4674:	9c 01       	movw	r18, r24
    4676:	24 5f       	subi	r18, 0xF4	; 244
    4678:	3f 4f       	sbci	r19, 0xFF	; 255
    467a:	ca 01       	movw	r24, r20
    467c:	b9 01       	movw	r22, r18
    467e:	0e 94 ea 15 	call	0x2bd4	; 0x2bd4 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4682:	80 91 ec 00 	lds	r24, 0x00EC
    4686:	90 91 ed 00 	lds	r25, 0x00ED
    468a:	02 96       	adiw	r24, 0x02	; 2
    468c:	0e 94 56 16 	call	0x2cac	; 0x2cac <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    4690:	20 91 f0 00 	lds	r18, 0x00F0
    4694:	30 91 f1 00 	lds	r19, 0x00F1
    4698:	8d 81       	ldd	r24, Y+5	; 0x05
    469a:	9e 81       	ldd	r25, Y+6	; 0x06
    469c:	82 0f       	add	r24, r18
    469e:	93 1f       	adc	r25, r19
    46a0:	9a 83       	std	Y+2, r25	; 0x02
    46a2:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    46a4:	89 81       	ldd	r24, Y+1	; 0x01
    46a6:	9a 81       	ldd	r25, Y+2	; 0x02
    46a8:	0e 94 27 25 	call	0x4a4e	; 0x4a4e <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    46ac:	26 96       	adiw	r28, 0x06	; 6
    46ae:	0f b6       	in	r0, 0x3f	; 63
    46b0:	f8 94       	cli
    46b2:	de bf       	out	0x3e, r29	; 62
    46b4:	0f be       	out	0x3f, r0	; 63
    46b6:	cd bf       	out	0x3d, r28	; 61
    46b8:	cf 91       	pop	r28
    46ba:	df 91       	pop	r29
    46bc:	08 95       	ret

000046be <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    46be:	df 93       	push	r29
    46c0:	cf 93       	push	r28
    46c2:	00 d0       	rcall	.+0      	; 0x46c4 <xTaskRemoveFromEventList+0x6>
    46c4:	00 d0       	rcall	.+0      	; 0x46c6 <xTaskRemoveFromEventList+0x8>
    46c6:	0f 92       	push	r0
    46c8:	cd b7       	in	r28, 0x3d	; 61
    46ca:	de b7       	in	r29, 0x3e	; 62
    46cc:	9d 83       	std	Y+5, r25	; 0x05
    46ce:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    46d0:	ec 81       	ldd	r30, Y+4	; 0x04
    46d2:	fd 81       	ldd	r31, Y+5	; 0x05
    46d4:	05 80       	ldd	r0, Z+5	; 0x05
    46d6:	f6 81       	ldd	r31, Z+6	; 0x06
    46d8:	e0 2d       	mov	r30, r0
    46da:	86 81       	ldd	r24, Z+6	; 0x06
    46dc:	97 81       	ldd	r25, Z+7	; 0x07
    46de:	9b 83       	std	Y+3, r25	; 0x03
    46e0:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    46e2:	8a 81       	ldd	r24, Y+2	; 0x02
    46e4:	9b 81       	ldd	r25, Y+3	; 0x03
    46e6:	0c 96       	adiw	r24, 0x0c	; 12
    46e8:	0e 94 56 16 	call	0x2cac	; 0x2cac <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    46ec:	80 91 f5 00 	lds	r24, 0x00F5
    46f0:	88 23       	and	r24, r24
    46f2:	61 f5       	brne	.+88     	; 0x474c <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    46f4:	8a 81       	ldd	r24, Y+2	; 0x02
    46f6:	9b 81       	ldd	r25, Y+3	; 0x03
    46f8:	02 96       	adiw	r24, 0x02	; 2
    46fa:	0e 94 56 16 	call	0x2cac	; 0x2cac <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    46fe:	ea 81       	ldd	r30, Y+2	; 0x02
    4700:	fb 81       	ldd	r31, Y+3	; 0x03
    4702:	96 89       	ldd	r25, Z+22	; 0x16
    4704:	80 91 f3 00 	lds	r24, 0x00F3
    4708:	89 17       	cp	r24, r25
    470a:	28 f4       	brcc	.+10     	; 0x4716 <xTaskRemoveFromEventList+0x58>
    470c:	ea 81       	ldd	r30, Y+2	; 0x02
    470e:	fb 81       	ldd	r31, Y+3	; 0x03
    4710:	86 89       	ldd	r24, Z+22	; 0x16
    4712:	80 93 f3 00 	sts	0x00F3, r24
    4716:	ea 81       	ldd	r30, Y+2	; 0x02
    4718:	fb 81       	ldd	r31, Y+3	; 0x03
    471a:	86 89       	ldd	r24, Z+22	; 0x16
    471c:	28 2f       	mov	r18, r24
    471e:	30 e0       	ldi	r19, 0x00	; 0
    4720:	c9 01       	movw	r24, r18
    4722:	88 0f       	add	r24, r24
    4724:	99 1f       	adc	r25, r25
    4726:	88 0f       	add	r24, r24
    4728:	99 1f       	adc	r25, r25
    472a:	88 0f       	add	r24, r24
    472c:	99 1f       	adc	r25, r25
    472e:	82 0f       	add	r24, r18
    4730:	93 1f       	adc	r25, r19
    4732:	ac 01       	movw	r20, r24
    4734:	46 50       	subi	r20, 0x06	; 6
    4736:	5f 4f       	sbci	r21, 0xFF	; 255
    4738:	8a 81       	ldd	r24, Y+2	; 0x02
    473a:	9b 81       	ldd	r25, Y+3	; 0x03
    473c:	9c 01       	movw	r18, r24
    473e:	2e 5f       	subi	r18, 0xFE	; 254
    4740:	3f 4f       	sbci	r19, 0xFF	; 255
    4742:	ca 01       	movw	r24, r20
    4744:	b9 01       	movw	r22, r18
    4746:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <vListInsertEnd>
    474a:	0a c0       	rjmp	.+20     	; 0x4760 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    474c:	8a 81       	ldd	r24, Y+2	; 0x02
    474e:	9b 81       	ldd	r25, Y+3	; 0x03
    4750:	9c 01       	movw	r18, r24
    4752:	24 5f       	subi	r18, 0xF4	; 244
    4754:	3f 4f       	sbci	r19, 0xFF	; 255
    4756:	8d e3       	ldi	r24, 0x3D	; 61
    4758:	91 e0       	ldi	r25, 0x01	; 1
    475a:	b9 01       	movw	r22, r18
    475c:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4760:	ea 81       	ldd	r30, Y+2	; 0x02
    4762:	fb 81       	ldd	r31, Y+3	; 0x03
    4764:	96 89       	ldd	r25, Z+22	; 0x16
    4766:	e0 91 ec 00 	lds	r30, 0x00EC
    476a:	f0 91 ed 00 	lds	r31, 0x00ED
    476e:	86 89       	ldd	r24, Z+22	; 0x16
    4770:	98 17       	cp	r25, r24
    4772:	18 f0       	brcs	.+6      	; 0x477a <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    4774:	81 e0       	ldi	r24, 0x01	; 1
    4776:	89 83       	std	Y+1, r24	; 0x01
    4778:	01 c0       	rjmp	.+2      	; 0x477c <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    477a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    477c:	89 81       	ldd	r24, Y+1	; 0x01
}
    477e:	0f 90       	pop	r0
    4780:	0f 90       	pop	r0
    4782:	0f 90       	pop	r0
    4784:	0f 90       	pop	r0
    4786:	0f 90       	pop	r0
    4788:	cf 91       	pop	r28
    478a:	df 91       	pop	r29
    478c:	08 95       	ret

0000478e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    478e:	df 93       	push	r29
    4790:	cf 93       	push	r28
    4792:	00 d0       	rcall	.+0      	; 0x4794 <vTaskSetTimeOutState+0x6>
    4794:	cd b7       	in	r28, 0x3d	; 61
    4796:	de b7       	in	r29, 0x3e	; 62
    4798:	9a 83       	std	Y+2, r25	; 0x02
    479a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    479c:	80 91 f8 00 	lds	r24, 0x00F8
    47a0:	e9 81       	ldd	r30, Y+1	; 0x01
    47a2:	fa 81       	ldd	r31, Y+2	; 0x02
    47a4:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    47a6:	80 91 f0 00 	lds	r24, 0x00F0
    47aa:	90 91 f1 00 	lds	r25, 0x00F1
    47ae:	e9 81       	ldd	r30, Y+1	; 0x01
    47b0:	fa 81       	ldd	r31, Y+2	; 0x02
    47b2:	92 83       	std	Z+2, r25	; 0x02
    47b4:	81 83       	std	Z+1, r24	; 0x01
}
    47b6:	0f 90       	pop	r0
    47b8:	0f 90       	pop	r0
    47ba:	cf 91       	pop	r28
    47bc:	df 91       	pop	r29
    47be:	08 95       	ret

000047c0 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    47c0:	df 93       	push	r29
    47c2:	cf 93       	push	r28
    47c4:	00 d0       	rcall	.+0      	; 0x47c6 <xTaskCheckForTimeOut+0x6>
    47c6:	00 d0       	rcall	.+0      	; 0x47c8 <xTaskCheckForTimeOut+0x8>
    47c8:	0f 92       	push	r0
    47ca:	cd b7       	in	r28, 0x3d	; 61
    47cc:	de b7       	in	r29, 0x3e	; 62
    47ce:	9b 83       	std	Y+3, r25	; 0x03
    47d0:	8a 83       	std	Y+2, r24	; 0x02
    47d2:	7d 83       	std	Y+5, r23	; 0x05
    47d4:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    47d6:	0f b6       	in	r0, 0x3f	; 63
    47d8:	f8 94       	cli
    47da:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    47dc:	ea 81       	ldd	r30, Y+2	; 0x02
    47de:	fb 81       	ldd	r31, Y+3	; 0x03
    47e0:	90 81       	ld	r25, Z
    47e2:	80 91 f8 00 	lds	r24, 0x00F8
    47e6:	98 17       	cp	r25, r24
    47e8:	71 f0       	breq	.+28     	; 0x4806 <xTaskCheckForTimeOut+0x46>
    47ea:	ea 81       	ldd	r30, Y+2	; 0x02
    47ec:	fb 81       	ldd	r31, Y+3	; 0x03
    47ee:	21 81       	ldd	r18, Z+1	; 0x01
    47f0:	32 81       	ldd	r19, Z+2	; 0x02
    47f2:	80 91 f0 00 	lds	r24, 0x00F0
    47f6:	90 91 f1 00 	lds	r25, 0x00F1
    47fa:	82 17       	cp	r24, r18
    47fc:	93 07       	cpc	r25, r19
    47fe:	18 f0       	brcs	.+6      	; 0x4806 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    4800:	81 e0       	ldi	r24, 0x01	; 1
    4802:	89 83       	std	Y+1, r24	; 0x01
    4804:	2f c0       	rjmp	.+94     	; 0x4864 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    4806:	20 91 f0 00 	lds	r18, 0x00F0
    480a:	30 91 f1 00 	lds	r19, 0x00F1
    480e:	ea 81       	ldd	r30, Y+2	; 0x02
    4810:	fb 81       	ldd	r31, Y+3	; 0x03
    4812:	81 81       	ldd	r24, Z+1	; 0x01
    4814:	92 81       	ldd	r25, Z+2	; 0x02
    4816:	28 1b       	sub	r18, r24
    4818:	39 0b       	sbc	r19, r25
    481a:	ec 81       	ldd	r30, Y+4	; 0x04
    481c:	fd 81       	ldd	r31, Y+5	; 0x05
    481e:	80 81       	ld	r24, Z
    4820:	91 81       	ldd	r25, Z+1	; 0x01
    4822:	28 17       	cp	r18, r24
    4824:	39 07       	cpc	r19, r25
    4826:	e0 f4       	brcc	.+56     	; 0x4860 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    4828:	ec 81       	ldd	r30, Y+4	; 0x04
    482a:	fd 81       	ldd	r31, Y+5	; 0x05
    482c:	40 81       	ld	r20, Z
    482e:	51 81       	ldd	r21, Z+1	; 0x01
    4830:	ea 81       	ldd	r30, Y+2	; 0x02
    4832:	fb 81       	ldd	r31, Y+3	; 0x03
    4834:	21 81       	ldd	r18, Z+1	; 0x01
    4836:	32 81       	ldd	r19, Z+2	; 0x02
    4838:	80 91 f0 00 	lds	r24, 0x00F0
    483c:	90 91 f1 00 	lds	r25, 0x00F1
    4840:	b9 01       	movw	r22, r18
    4842:	68 1b       	sub	r22, r24
    4844:	79 0b       	sbc	r23, r25
    4846:	cb 01       	movw	r24, r22
    4848:	84 0f       	add	r24, r20
    484a:	95 1f       	adc	r25, r21
    484c:	ec 81       	ldd	r30, Y+4	; 0x04
    484e:	fd 81       	ldd	r31, Y+5	; 0x05
    4850:	91 83       	std	Z+1, r25	; 0x01
    4852:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    4854:	8a 81       	ldd	r24, Y+2	; 0x02
    4856:	9b 81       	ldd	r25, Y+3	; 0x03
    4858:	0e 94 c7 23 	call	0x478e	; 0x478e <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    485c:	19 82       	std	Y+1, r1	; 0x01
    485e:	02 c0       	rjmp	.+4      	; 0x4864 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    4860:	81 e0       	ldi	r24, 0x01	; 1
    4862:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    4864:	0f 90       	pop	r0
    4866:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4868:	89 81       	ldd	r24, Y+1	; 0x01
}
    486a:	0f 90       	pop	r0
    486c:	0f 90       	pop	r0
    486e:	0f 90       	pop	r0
    4870:	0f 90       	pop	r0
    4872:	0f 90       	pop	r0
    4874:	cf 91       	pop	r28
    4876:	df 91       	pop	r29
    4878:	08 95       	ret

0000487a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    487a:	df 93       	push	r29
    487c:	cf 93       	push	r28
    487e:	cd b7       	in	r28, 0x3d	; 61
    4880:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    4882:	81 e0       	ldi	r24, 0x01	; 1
    4884:	80 93 f7 00 	sts	0x00F7, r24
}
    4888:	cf 91       	pop	r28
    488a:	df 91       	pop	r29
    488c:	08 95       	ret

0000488e <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    488e:	df 93       	push	r29
    4890:	cf 93       	push	r28
    4892:	00 d0       	rcall	.+0      	; 0x4894 <prvIdleTask+0x6>
    4894:	cd b7       	in	r28, 0x3d	; 61
    4896:	de b7       	in	r29, 0x3e	; 62
    4898:	9a 83       	std	Y+2, r25	; 0x02
    489a:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    489c:	0e 94 e9 24 	call	0x49d2	; 0x49d2 <prvCheckTasksWaitingTermination>
    48a0:	fd cf       	rjmp	.-6      	; 0x489c <prvIdleTask+0xe>

000048a2 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    48a2:	0f 93       	push	r16
    48a4:	1f 93       	push	r17
    48a6:	df 93       	push	r29
    48a8:	cf 93       	push	r28
    48aa:	cd b7       	in	r28, 0x3d	; 61
    48ac:	de b7       	in	r29, 0x3e	; 62
    48ae:	29 97       	sbiw	r28, 0x09	; 9
    48b0:	0f b6       	in	r0, 0x3f	; 63
    48b2:	f8 94       	cli
    48b4:	de bf       	out	0x3e, r29	; 62
    48b6:	0f be       	out	0x3f, r0	; 63
    48b8:	cd bf       	out	0x3d, r28	; 61
    48ba:	9a 83       	std	Y+2, r25	; 0x02
    48bc:	89 83       	std	Y+1, r24	; 0x01
    48be:	7c 83       	std	Y+4, r23	; 0x04
    48c0:	6b 83       	std	Y+3, r22	; 0x03
    48c2:	4d 83       	std	Y+5, r20	; 0x05
    48c4:	3f 83       	std	Y+7, r19	; 0x07
    48c6:	2e 83       	std	Y+6, r18	; 0x06
    48c8:	19 87       	std	Y+9, r17	; 0x09
    48ca:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    48cc:	89 81       	ldd	r24, Y+1	; 0x01
    48ce:	9a 81       	ldd	r25, Y+2	; 0x02
    48d0:	49 96       	adiw	r24, 0x19	; 25
    48d2:	2b 81       	ldd	r18, Y+3	; 0x03
    48d4:	3c 81       	ldd	r19, Y+4	; 0x04
    48d6:	b9 01       	movw	r22, r18
    48d8:	48 e0       	ldi	r20, 0x08	; 8
    48da:	50 e0       	ldi	r21, 0x00	; 0
    48dc:	0e 94 3a 28 	call	0x5074	; 0x5074 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    48e0:	e9 81       	ldd	r30, Y+1	; 0x01
    48e2:	fa 81       	ldd	r31, Y+2	; 0x02
    48e4:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    48e6:	8d 81       	ldd	r24, Y+5	; 0x05
    48e8:	85 30       	cpi	r24, 0x05	; 5
    48ea:	10 f0       	brcs	.+4      	; 0x48f0 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    48ec:	84 e0       	ldi	r24, 0x04	; 4
    48ee:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    48f0:	e9 81       	ldd	r30, Y+1	; 0x01
    48f2:	fa 81       	ldd	r31, Y+2	; 0x02
    48f4:	8d 81       	ldd	r24, Y+5	; 0x05
    48f6:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    48f8:	e9 81       	ldd	r30, Y+1	; 0x01
    48fa:	fa 81       	ldd	r31, Y+2	; 0x02
    48fc:	8d 81       	ldd	r24, Y+5	; 0x05
    48fe:	81 a3       	std	Z+33, r24	; 0x21
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    4900:	89 81       	ldd	r24, Y+1	; 0x01
    4902:	9a 81       	ldd	r25, Y+2	; 0x02
    4904:	02 96       	adiw	r24, 0x02	; 2
    4906:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    490a:	89 81       	ldd	r24, Y+1	; 0x01
    490c:	9a 81       	ldd	r25, Y+2	; 0x02
    490e:	0c 96       	adiw	r24, 0x0c	; 12
    4910:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    4914:	e9 81       	ldd	r30, Y+1	; 0x01
    4916:	fa 81       	ldd	r31, Y+2	; 0x02
    4918:	89 81       	ldd	r24, Y+1	; 0x01
    491a:	9a 81       	ldd	r25, Y+2	; 0x02
    491c:	91 87       	std	Z+9, r25	; 0x09
    491e:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    4920:	8d 81       	ldd	r24, Y+5	; 0x05
    4922:	28 2f       	mov	r18, r24
    4924:	30 e0       	ldi	r19, 0x00	; 0
    4926:	85 e0       	ldi	r24, 0x05	; 5
    4928:	90 e0       	ldi	r25, 0x00	; 0
    492a:	82 1b       	sub	r24, r18
    492c:	93 0b       	sbc	r25, r19
    492e:	e9 81       	ldd	r30, Y+1	; 0x01
    4930:	fa 81       	ldd	r31, Y+2	; 0x02
    4932:	95 87       	std	Z+13, r25	; 0x0d
    4934:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    4936:	e9 81       	ldd	r30, Y+1	; 0x01
    4938:	fa 81       	ldd	r31, Y+2	; 0x02
    493a:	89 81       	ldd	r24, Y+1	; 0x01
    493c:	9a 81       	ldd	r25, Y+2	; 0x02
    493e:	93 8b       	std	Z+19, r25	; 0x13
    4940:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    4942:	29 96       	adiw	r28, 0x09	; 9
    4944:	0f b6       	in	r0, 0x3f	; 63
    4946:	f8 94       	cli
    4948:	de bf       	out	0x3e, r29	; 62
    494a:	0f be       	out	0x3f, r0	; 63
    494c:	cd bf       	out	0x3d, r28	; 61
    494e:	cf 91       	pop	r28
    4950:	df 91       	pop	r29
    4952:	1f 91       	pop	r17
    4954:	0f 91       	pop	r16
    4956:	08 95       	ret

00004958 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    4958:	df 93       	push	r29
    495a:	cf 93       	push	r28
    495c:	0f 92       	push	r0
    495e:	cd b7       	in	r28, 0x3d	; 61
    4960:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    4962:	19 82       	std	Y+1, r1	; 0x01
    4964:	13 c0       	rjmp	.+38     	; 0x498c <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    4966:	89 81       	ldd	r24, Y+1	; 0x01
    4968:	28 2f       	mov	r18, r24
    496a:	30 e0       	ldi	r19, 0x00	; 0
    496c:	c9 01       	movw	r24, r18
    496e:	88 0f       	add	r24, r24
    4970:	99 1f       	adc	r25, r25
    4972:	88 0f       	add	r24, r24
    4974:	99 1f       	adc	r25, r25
    4976:	88 0f       	add	r24, r24
    4978:	99 1f       	adc	r25, r25
    497a:	82 0f       	add	r24, r18
    497c:	93 1f       	adc	r25, r19
    497e:	86 50       	subi	r24, 0x06	; 6
    4980:	9f 4f       	sbci	r25, 0xFF	; 255
    4982:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    4986:	89 81       	ldd	r24, Y+1	; 0x01
    4988:	8f 5f       	subi	r24, 0xFF	; 255
    498a:	89 83       	std	Y+1, r24	; 0x01
    498c:	89 81       	ldd	r24, Y+1	; 0x01
    498e:	85 30       	cpi	r24, 0x05	; 5
    4990:	50 f3       	brcs	.-44     	; 0x4966 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    4992:	87 e2       	ldi	r24, 0x27	; 39
    4994:	91 e0       	ldi	r25, 0x01	; 1
    4996:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    499a:	80 e3       	ldi	r24, 0x30	; 48
    499c:	91 e0       	ldi	r25, 0x01	; 1
    499e:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    49a2:	8d e3       	ldi	r24, 0x3D	; 61
    49a4:	91 e0       	ldi	r25, 0x01	; 1
    49a6:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    49aa:	86 e4       	ldi	r24, 0x46	; 70
    49ac:	91 e0       	ldi	r25, 0x01	; 1
    49ae:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    49b2:	87 e2       	ldi	r24, 0x27	; 39
    49b4:	91 e0       	ldi	r25, 0x01	; 1
    49b6:	90 93 3a 01 	sts	0x013A, r25
    49ba:	80 93 39 01 	sts	0x0139, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    49be:	80 e3       	ldi	r24, 0x30	; 48
    49c0:	91 e0       	ldi	r25, 0x01	; 1
    49c2:	90 93 3c 01 	sts	0x013C, r25
    49c6:	80 93 3b 01 	sts	0x013B, r24
}
    49ca:	0f 90       	pop	r0
    49cc:	cf 91       	pop	r28
    49ce:	df 91       	pop	r29
    49d0:	08 95       	ret

000049d2 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    49d2:	df 93       	push	r29
    49d4:	cf 93       	push	r28
    49d6:	00 d0       	rcall	.+0      	; 0x49d8 <prvCheckTasksWaitingTermination+0x6>
    49d8:	0f 92       	push	r0
    49da:	cd b7       	in	r28, 0x3d	; 61
    49dc:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    49de:	80 91 ee 00 	lds	r24, 0x00EE
    49e2:	88 23       	and	r24, r24
    49e4:	71 f1       	breq	.+92     	; 0x4a42 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    49e6:	0e 94 23 21 	call	0x4246	; 0x4246 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    49ea:	80 91 46 01 	lds	r24, 0x0146
    49ee:	1b 82       	std	Y+3, r1	; 0x03
    49f0:	88 23       	and	r24, r24
    49f2:	11 f4       	brne	.+4      	; 0x49f8 <prvCheckTasksWaitingTermination+0x26>
    49f4:	81 e0       	ldi	r24, 0x01	; 1
    49f6:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    49f8:	0e 94 2f 21 	call	0x425e	; 0x425e <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    49fc:	8b 81       	ldd	r24, Y+3	; 0x03
    49fe:	88 23       	and	r24, r24
    4a00:	01 f5       	brne	.+64     	; 0x4a42 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    4a02:	0f b6       	in	r0, 0x3f	; 63
    4a04:	f8 94       	cli
    4a06:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    4a08:	e0 91 4b 01 	lds	r30, 0x014B
    4a0c:	f0 91 4c 01 	lds	r31, 0x014C
    4a10:	86 81       	ldd	r24, Z+6	; 0x06
    4a12:	97 81       	ldd	r25, Z+7	; 0x07
    4a14:	9a 83       	std	Y+2, r25	; 0x02
    4a16:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    4a18:	89 81       	ldd	r24, Y+1	; 0x01
    4a1a:	9a 81       	ldd	r25, Y+2	; 0x02
    4a1c:	02 96       	adiw	r24, 0x02	; 2
    4a1e:	0e 94 56 16 	call	0x2cac	; 0x2cac <vListRemove>
					--uxCurrentNumberOfTasks;
    4a22:	80 91 ef 00 	lds	r24, 0x00EF
    4a26:	81 50       	subi	r24, 0x01	; 1
    4a28:	80 93 ef 00 	sts	0x00EF, r24
					--uxTasksDeleted;
    4a2c:	80 91 ee 00 	lds	r24, 0x00EE
    4a30:	81 50       	subi	r24, 0x01	; 1
    4a32:	80 93 ee 00 	sts	0x00EE, r24
				}
				taskEXIT_CRITICAL();
    4a36:	0f 90       	pop	r0
    4a38:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    4a3a:	89 81       	ldd	r24, Y+1	; 0x01
    4a3c:	9a 81       	ldd	r25, Y+2	; 0x02
    4a3e:	0e 94 c0 25 	call	0x4b80	; 0x4b80 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    4a42:	0f 90       	pop	r0
    4a44:	0f 90       	pop	r0
    4a46:	0f 90       	pop	r0
    4a48:	cf 91       	pop	r28
    4a4a:	df 91       	pop	r29
    4a4c:	08 95       	ret

00004a4e <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    4a4e:	df 93       	push	r29
    4a50:	cf 93       	push	r28
    4a52:	00 d0       	rcall	.+0      	; 0x4a54 <prvAddCurrentTaskToDelayedList+0x6>
    4a54:	cd b7       	in	r28, 0x3d	; 61
    4a56:	de b7       	in	r29, 0x3e	; 62
    4a58:	9a 83       	std	Y+2, r25	; 0x02
    4a5a:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    4a5c:	e0 91 ec 00 	lds	r30, 0x00EC
    4a60:	f0 91 ed 00 	lds	r31, 0x00ED
    4a64:	89 81       	ldd	r24, Y+1	; 0x01
    4a66:	9a 81       	ldd	r25, Y+2	; 0x02
    4a68:	93 83       	std	Z+3, r25	; 0x03
    4a6a:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    4a6c:	20 91 f0 00 	lds	r18, 0x00F0
    4a70:	30 91 f1 00 	lds	r19, 0x00F1
    4a74:	89 81       	ldd	r24, Y+1	; 0x01
    4a76:	9a 81       	ldd	r25, Y+2	; 0x02
    4a78:	82 17       	cp	r24, r18
    4a7a:	93 07       	cpc	r25, r19
    4a7c:	70 f4       	brcc	.+28     	; 0x4a9a <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4a7e:	80 91 3b 01 	lds	r24, 0x013B
    4a82:	90 91 3c 01 	lds	r25, 0x013C
    4a86:	20 91 ec 00 	lds	r18, 0x00EC
    4a8a:	30 91 ed 00 	lds	r19, 0x00ED
    4a8e:	2e 5f       	subi	r18, 0xFE	; 254
    4a90:	3f 4f       	sbci	r19, 0xFF	; 255
    4a92:	b9 01       	movw	r22, r18
    4a94:	0e 94 ea 15 	call	0x2bd4	; 0x2bd4 <vListInsert>
    4a98:	1e c0       	rjmp	.+60     	; 0x4ad6 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4a9a:	40 91 39 01 	lds	r20, 0x0139
    4a9e:	50 91 3a 01 	lds	r21, 0x013A
    4aa2:	80 91 ec 00 	lds	r24, 0x00EC
    4aa6:	90 91 ed 00 	lds	r25, 0x00ED
    4aaa:	9c 01       	movw	r18, r24
    4aac:	2e 5f       	subi	r18, 0xFE	; 254
    4aae:	3f 4f       	sbci	r19, 0xFF	; 255
    4ab0:	ca 01       	movw	r24, r20
    4ab2:	b9 01       	movw	r22, r18
    4ab4:	0e 94 ea 15 	call	0x2bd4	; 0x2bd4 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    4ab8:	20 91 af 00 	lds	r18, 0x00AF
    4abc:	30 91 b0 00 	lds	r19, 0x00B0
    4ac0:	89 81       	ldd	r24, Y+1	; 0x01
    4ac2:	9a 81       	ldd	r25, Y+2	; 0x02
    4ac4:	82 17       	cp	r24, r18
    4ac6:	93 07       	cpc	r25, r19
    4ac8:	30 f4       	brcc	.+12     	; 0x4ad6 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    4aca:	89 81       	ldd	r24, Y+1	; 0x01
    4acc:	9a 81       	ldd	r25, Y+2	; 0x02
    4ace:	90 93 b0 00 	sts	0x00B0, r25
    4ad2:	80 93 af 00 	sts	0x00AF, r24
		}
	}
}
    4ad6:	0f 90       	pop	r0
    4ad8:	0f 90       	pop	r0
    4ada:	cf 91       	pop	r28
    4adc:	df 91       	pop	r29
    4ade:	08 95       	ret

00004ae0 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    4ae0:	df 93       	push	r29
    4ae2:	cf 93       	push	r28
    4ae4:	cd b7       	in	r28, 0x3d	; 61
    4ae6:	de b7       	in	r29, 0x3e	; 62
    4ae8:	28 97       	sbiw	r28, 0x08	; 8
    4aea:	0f b6       	in	r0, 0x3f	; 63
    4aec:	f8 94       	cli
    4aee:	de bf       	out	0x3e, r29	; 62
    4af0:	0f be       	out	0x3f, r0	; 63
    4af2:	cd bf       	out	0x3d, r28	; 61
    4af4:	9c 83       	std	Y+4, r25	; 0x04
    4af6:	8b 83       	std	Y+3, r24	; 0x03
    4af8:	7e 83       	std	Y+6, r23	; 0x06
    4afa:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    4afc:	82 e2       	ldi	r24, 0x22	; 34
    4afe:	90 e0       	ldi	r25, 0x00	; 0
    4b00:	0e 94 31 15 	call	0x2a62	; 0x2a62 <pvPortMalloc>
    4b04:	9a 83       	std	Y+2, r25	; 0x02
    4b06:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    4b08:	89 81       	ldd	r24, Y+1	; 0x01
    4b0a:	9a 81       	ldd	r25, Y+2	; 0x02
    4b0c:	00 97       	sbiw	r24, 0x00	; 0
    4b0e:	69 f1       	breq	.+90     	; 0x4b6a <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    4b10:	8d 81       	ldd	r24, Y+5	; 0x05
    4b12:	9e 81       	ldd	r25, Y+6	; 0x06
    4b14:	00 97       	sbiw	r24, 0x00	; 0
    4b16:	39 f4       	brne	.+14     	; 0x4b26 <prvAllocateTCBAndStack+0x46>
    4b18:	8b 81       	ldd	r24, Y+3	; 0x03
    4b1a:	9c 81       	ldd	r25, Y+4	; 0x04
    4b1c:	0e 94 31 15 	call	0x2a62	; 0x2a62 <pvPortMalloc>
    4b20:	98 87       	std	Y+8, r25	; 0x08
    4b22:	8f 83       	std	Y+7, r24	; 0x07
    4b24:	04 c0       	rjmp	.+8      	; 0x4b2e <prvAllocateTCBAndStack+0x4e>
    4b26:	8d 81       	ldd	r24, Y+5	; 0x05
    4b28:	9e 81       	ldd	r25, Y+6	; 0x06
    4b2a:	98 87       	std	Y+8, r25	; 0x08
    4b2c:	8f 83       	std	Y+7, r24	; 0x07
    4b2e:	e9 81       	ldd	r30, Y+1	; 0x01
    4b30:	fa 81       	ldd	r31, Y+2	; 0x02
    4b32:	8f 81       	ldd	r24, Y+7	; 0x07
    4b34:	98 85       	ldd	r25, Y+8	; 0x08
    4b36:	90 8f       	std	Z+24, r25	; 0x18
    4b38:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    4b3a:	e9 81       	ldd	r30, Y+1	; 0x01
    4b3c:	fa 81       	ldd	r31, Y+2	; 0x02
    4b3e:	87 89       	ldd	r24, Z+23	; 0x17
    4b40:	90 8d       	ldd	r25, Z+24	; 0x18
    4b42:	00 97       	sbiw	r24, 0x00	; 0
    4b44:	39 f4       	brne	.+14     	; 0x4b54 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    4b46:	89 81       	ldd	r24, Y+1	; 0x01
    4b48:	9a 81       	ldd	r25, Y+2	; 0x02
    4b4a:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <vPortFree>
			pxNewTCB = NULL;
    4b4e:	1a 82       	std	Y+2, r1	; 0x02
    4b50:	19 82       	std	Y+1, r1	; 0x01
    4b52:	0b c0       	rjmp	.+22     	; 0x4b6a <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    4b54:	e9 81       	ldd	r30, Y+1	; 0x01
    4b56:	fa 81       	ldd	r31, Y+2	; 0x02
    4b58:	87 89       	ldd	r24, Z+23	; 0x17
    4b5a:	90 8d       	ldd	r25, Z+24	; 0x18
    4b5c:	2b 81       	ldd	r18, Y+3	; 0x03
    4b5e:	3c 81       	ldd	r19, Y+4	; 0x04
    4b60:	65 ea       	ldi	r22, 0xA5	; 165
    4b62:	70 e0       	ldi	r23, 0x00	; 0
    4b64:	a9 01       	movw	r20, r18
    4b66:	0e 94 33 28 	call	0x5066	; 0x5066 <memset>
		}
	}

	return pxNewTCB;
    4b6a:	89 81       	ldd	r24, Y+1	; 0x01
    4b6c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4b6e:	28 96       	adiw	r28, 0x08	; 8
    4b70:	0f b6       	in	r0, 0x3f	; 63
    4b72:	f8 94       	cli
    4b74:	de bf       	out	0x3e, r29	; 62
    4b76:	0f be       	out	0x3f, r0	; 63
    4b78:	cd bf       	out	0x3d, r28	; 61
    4b7a:	cf 91       	pop	r28
    4b7c:	df 91       	pop	r29
    4b7e:	08 95       	ret

00004b80 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    4b80:	df 93       	push	r29
    4b82:	cf 93       	push	r28
    4b84:	00 d0       	rcall	.+0      	; 0x4b86 <prvDeleteTCB+0x6>
    4b86:	cd b7       	in	r28, 0x3d	; 61
    4b88:	de b7       	in	r29, 0x3e	; 62
    4b8a:	9a 83       	std	Y+2, r25	; 0x02
    4b8c:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    4b8e:	e9 81       	ldd	r30, Y+1	; 0x01
    4b90:	fa 81       	ldd	r31, Y+2	; 0x02
    4b92:	87 89       	ldd	r24, Z+23	; 0x17
    4b94:	90 8d       	ldd	r25, Z+24	; 0x18
    4b96:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <vPortFree>
		vPortFree( pxTCB );
    4b9a:	89 81       	ldd	r24, Y+1	; 0x01
    4b9c:	9a 81       	ldd	r25, Y+2	; 0x02
    4b9e:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <vPortFree>
	}
    4ba2:	0f 90       	pop	r0
    4ba4:	0f 90       	pop	r0
    4ba6:	cf 91       	pop	r28
    4ba8:	df 91       	pop	r29
    4baa:	08 95       	ret

00004bac <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
    4bac:	df 93       	push	r29
    4bae:	cf 93       	push	r28
    4bb0:	00 d0       	rcall	.+0      	; 0x4bb2 <xTaskGetCurrentTaskHandle+0x6>
    4bb2:	cd b7       	in	r28, 0x3d	; 61
    4bb4:	de b7       	in	r29, 0x3e	; 62
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    4bb6:	80 91 ec 00 	lds	r24, 0x00EC
    4bba:	90 91 ed 00 	lds	r25, 0x00ED
    4bbe:	9a 83       	std	Y+2, r25	; 0x02
    4bc0:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    4bc2:	89 81       	ldd	r24, Y+1	; 0x01
    4bc4:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4bc6:	0f 90       	pop	r0
    4bc8:	0f 90       	pop	r0
    4bca:	cf 91       	pop	r28
    4bcc:	df 91       	pop	r29
    4bce:	08 95       	ret

00004bd0 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    4bd0:	df 93       	push	r29
    4bd2:	cf 93       	push	r28
    4bd4:	00 d0       	rcall	.+0      	; 0x4bd6 <vTaskPriorityInherit+0x6>
    4bd6:	00 d0       	rcall	.+0      	; 0x4bd8 <vTaskPriorityInherit+0x8>
    4bd8:	cd b7       	in	r28, 0x3d	; 61
    4bda:	de b7       	in	r29, 0x3e	; 62
    4bdc:	9c 83       	std	Y+4, r25	; 0x04
    4bde:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    4be0:	8b 81       	ldd	r24, Y+3	; 0x03
    4be2:	9c 81       	ldd	r25, Y+4	; 0x04
    4be4:	9a 83       	std	Y+2, r25	; 0x02
    4be6:	89 83       	std	Y+1, r24	; 0x01

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    4be8:	e9 81       	ldd	r30, Y+1	; 0x01
    4bea:	fa 81       	ldd	r31, Y+2	; 0x02
    4bec:	96 89       	ldd	r25, Z+22	; 0x16
    4bee:	e0 91 ec 00 	lds	r30, 0x00EC
    4bf2:	f0 91 ed 00 	lds	r31, 0x00ED
    4bf6:	86 89       	ldd	r24, Z+22	; 0x16
    4bf8:	98 17       	cp	r25, r24
    4bfa:	08 f0       	brcs	.+2      	; 0x4bfe <vTaskPriorityInherit+0x2e>
    4bfc:	62 c0       	rjmp	.+196    	; 0x4cc2 <vTaskPriorityInherit+0xf2>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    4bfe:	e0 91 ec 00 	lds	r30, 0x00EC
    4c02:	f0 91 ed 00 	lds	r31, 0x00ED
    4c06:	86 89       	ldd	r24, Z+22	; 0x16
    4c08:	28 2f       	mov	r18, r24
    4c0a:	30 e0       	ldi	r19, 0x00	; 0
    4c0c:	85 e0       	ldi	r24, 0x05	; 5
    4c0e:	90 e0       	ldi	r25, 0x00	; 0
    4c10:	82 1b       	sub	r24, r18
    4c12:	93 0b       	sbc	r25, r19
    4c14:	e9 81       	ldd	r30, Y+1	; 0x01
    4c16:	fa 81       	ldd	r31, Y+2	; 0x02
    4c18:	95 87       	std	Z+13, r25	; 0x0d
    4c1a:	84 87       	std	Z+12, r24	; 0x0c

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    4c1c:	e9 81       	ldd	r30, Y+1	; 0x01
    4c1e:	fa 81       	ldd	r31, Y+2	; 0x02
    4c20:	42 85       	ldd	r20, Z+10	; 0x0a
    4c22:	53 85       	ldd	r21, Z+11	; 0x0b
    4c24:	e9 81       	ldd	r30, Y+1	; 0x01
    4c26:	fa 81       	ldd	r31, Y+2	; 0x02
    4c28:	86 89       	ldd	r24, Z+22	; 0x16
    4c2a:	28 2f       	mov	r18, r24
    4c2c:	30 e0       	ldi	r19, 0x00	; 0
    4c2e:	c9 01       	movw	r24, r18
    4c30:	88 0f       	add	r24, r24
    4c32:	99 1f       	adc	r25, r25
    4c34:	88 0f       	add	r24, r24
    4c36:	99 1f       	adc	r25, r25
    4c38:	88 0f       	add	r24, r24
    4c3a:	99 1f       	adc	r25, r25
    4c3c:	82 0f       	add	r24, r18
    4c3e:	93 1f       	adc	r25, r19
    4c40:	86 50       	subi	r24, 0x06	; 6
    4c42:	9f 4f       	sbci	r25, 0xFF	; 255
    4c44:	48 17       	cp	r20, r24
    4c46:	59 07       	cpc	r21, r25
    4c48:	a1 f5       	brne	.+104    	; 0x4cb2 <vTaskPriorityInherit+0xe2>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    4c4a:	89 81       	ldd	r24, Y+1	; 0x01
    4c4c:	9a 81       	ldd	r25, Y+2	; 0x02
    4c4e:	02 96       	adiw	r24, 0x02	; 2
    4c50:	0e 94 56 16 	call	0x2cac	; 0x2cac <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    4c54:	e0 91 ec 00 	lds	r30, 0x00EC
    4c58:	f0 91 ed 00 	lds	r31, 0x00ED
    4c5c:	86 89       	ldd	r24, Z+22	; 0x16
    4c5e:	e9 81       	ldd	r30, Y+1	; 0x01
    4c60:	fa 81       	ldd	r31, Y+2	; 0x02
    4c62:	86 8b       	std	Z+22, r24	; 0x16
				prvAddTaskToReadyQueue( pxTCB );
    4c64:	e9 81       	ldd	r30, Y+1	; 0x01
    4c66:	fa 81       	ldd	r31, Y+2	; 0x02
    4c68:	96 89       	ldd	r25, Z+22	; 0x16
    4c6a:	80 91 f3 00 	lds	r24, 0x00F3
    4c6e:	89 17       	cp	r24, r25
    4c70:	28 f4       	brcc	.+10     	; 0x4c7c <vTaskPriorityInherit+0xac>
    4c72:	e9 81       	ldd	r30, Y+1	; 0x01
    4c74:	fa 81       	ldd	r31, Y+2	; 0x02
    4c76:	86 89       	ldd	r24, Z+22	; 0x16
    4c78:	80 93 f3 00 	sts	0x00F3, r24
    4c7c:	e9 81       	ldd	r30, Y+1	; 0x01
    4c7e:	fa 81       	ldd	r31, Y+2	; 0x02
    4c80:	86 89       	ldd	r24, Z+22	; 0x16
    4c82:	28 2f       	mov	r18, r24
    4c84:	30 e0       	ldi	r19, 0x00	; 0
    4c86:	c9 01       	movw	r24, r18
    4c88:	88 0f       	add	r24, r24
    4c8a:	99 1f       	adc	r25, r25
    4c8c:	88 0f       	add	r24, r24
    4c8e:	99 1f       	adc	r25, r25
    4c90:	88 0f       	add	r24, r24
    4c92:	99 1f       	adc	r25, r25
    4c94:	82 0f       	add	r24, r18
    4c96:	93 1f       	adc	r25, r19
    4c98:	ac 01       	movw	r20, r24
    4c9a:	46 50       	subi	r20, 0x06	; 6
    4c9c:	5f 4f       	sbci	r21, 0xFF	; 255
    4c9e:	89 81       	ldd	r24, Y+1	; 0x01
    4ca0:	9a 81       	ldd	r25, Y+2	; 0x02
    4ca2:	9c 01       	movw	r18, r24
    4ca4:	2e 5f       	subi	r18, 0xFE	; 254
    4ca6:	3f 4f       	sbci	r19, 0xFF	; 255
    4ca8:	ca 01       	movw	r24, r20
    4caa:	b9 01       	movw	r22, r18
    4cac:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <vListInsertEnd>
    4cb0:	08 c0       	rjmp	.+16     	; 0x4cc2 <vTaskPriorityInherit+0xf2>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    4cb2:	e0 91 ec 00 	lds	r30, 0x00EC
    4cb6:	f0 91 ed 00 	lds	r31, 0x00ED
    4cba:	86 89       	ldd	r24, Z+22	; 0x16
    4cbc:	e9 81       	ldd	r30, Y+1	; 0x01
    4cbe:	fa 81       	ldd	r31, Y+2	; 0x02
    4cc0:	86 8b       	std	Z+22, r24	; 0x16
			}
		}
	}
    4cc2:	0f 90       	pop	r0
    4cc4:	0f 90       	pop	r0
    4cc6:	0f 90       	pop	r0
    4cc8:	0f 90       	pop	r0
    4cca:	cf 91       	pop	r28
    4ccc:	df 91       	pop	r29
    4cce:	08 95       	ret

00004cd0 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    4cd0:	df 93       	push	r29
    4cd2:	cf 93       	push	r28
    4cd4:	00 d0       	rcall	.+0      	; 0x4cd6 <vTaskPriorityDisinherit+0x6>
    4cd6:	00 d0       	rcall	.+0      	; 0x4cd8 <vTaskPriorityDisinherit+0x8>
    4cd8:	cd b7       	in	r28, 0x3d	; 61
    4cda:	de b7       	in	r29, 0x3e	; 62
    4cdc:	9c 83       	std	Y+4, r25	; 0x04
    4cde:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
    4ce0:	8b 81       	ldd	r24, Y+3	; 0x03
    4ce2:	9c 81       	ldd	r25, Y+4	; 0x04
    4ce4:	9a 83       	std	Y+2, r25	; 0x02
    4ce6:	89 83       	std	Y+1, r24	; 0x01

		if( pxMutexHolder != NULL )
    4ce8:	8b 81       	ldd	r24, Y+3	; 0x03
    4cea:	9c 81       	ldd	r25, Y+4	; 0x04
    4cec:	00 97       	sbiw	r24, 0x00	; 0
    4cee:	09 f4       	brne	.+2      	; 0x4cf2 <vTaskPriorityDisinherit+0x22>
    4cf0:	47 c0       	rjmp	.+142    	; 0x4d80 <vTaskPriorityDisinherit+0xb0>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    4cf2:	e9 81       	ldd	r30, Y+1	; 0x01
    4cf4:	fa 81       	ldd	r31, Y+2	; 0x02
    4cf6:	96 89       	ldd	r25, Z+22	; 0x16
    4cf8:	e9 81       	ldd	r30, Y+1	; 0x01
    4cfa:	fa 81       	ldd	r31, Y+2	; 0x02
    4cfc:	81 a1       	ldd	r24, Z+33	; 0x21
    4cfe:	98 17       	cp	r25, r24
    4d00:	09 f4       	brne	.+2      	; 0x4d04 <vTaskPriorityDisinherit+0x34>
    4d02:	3e c0       	rjmp	.+124    	; 0x4d80 <vTaskPriorityDisinherit+0xb0>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    4d04:	89 81       	ldd	r24, Y+1	; 0x01
    4d06:	9a 81       	ldd	r25, Y+2	; 0x02
    4d08:	02 96       	adiw	r24, 0x02	; 2
    4d0a:	0e 94 56 16 	call	0x2cac	; 0x2cac <vListRemove>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    4d0e:	e9 81       	ldd	r30, Y+1	; 0x01
    4d10:	fa 81       	ldd	r31, Y+2	; 0x02
    4d12:	81 a1       	ldd	r24, Z+33	; 0x21
    4d14:	e9 81       	ldd	r30, Y+1	; 0x01
    4d16:	fa 81       	ldd	r31, Y+2	; 0x02
    4d18:	86 8b       	std	Z+22, r24	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    4d1a:	e9 81       	ldd	r30, Y+1	; 0x01
    4d1c:	fa 81       	ldd	r31, Y+2	; 0x02
    4d1e:	86 89       	ldd	r24, Z+22	; 0x16
    4d20:	28 2f       	mov	r18, r24
    4d22:	30 e0       	ldi	r19, 0x00	; 0
    4d24:	85 e0       	ldi	r24, 0x05	; 5
    4d26:	90 e0       	ldi	r25, 0x00	; 0
    4d28:	82 1b       	sub	r24, r18
    4d2a:	93 0b       	sbc	r25, r19
    4d2c:	e9 81       	ldd	r30, Y+1	; 0x01
    4d2e:	fa 81       	ldd	r31, Y+2	; 0x02
    4d30:	95 87       	std	Z+13, r25	; 0x0d
    4d32:	84 87       	std	Z+12, r24	; 0x0c
				prvAddTaskToReadyQueue( pxTCB );
    4d34:	e9 81       	ldd	r30, Y+1	; 0x01
    4d36:	fa 81       	ldd	r31, Y+2	; 0x02
    4d38:	96 89       	ldd	r25, Z+22	; 0x16
    4d3a:	80 91 f3 00 	lds	r24, 0x00F3
    4d3e:	89 17       	cp	r24, r25
    4d40:	28 f4       	brcc	.+10     	; 0x4d4c <vTaskPriorityDisinherit+0x7c>
    4d42:	e9 81       	ldd	r30, Y+1	; 0x01
    4d44:	fa 81       	ldd	r31, Y+2	; 0x02
    4d46:	86 89       	ldd	r24, Z+22	; 0x16
    4d48:	80 93 f3 00 	sts	0x00F3, r24
    4d4c:	e9 81       	ldd	r30, Y+1	; 0x01
    4d4e:	fa 81       	ldd	r31, Y+2	; 0x02
    4d50:	86 89       	ldd	r24, Z+22	; 0x16
    4d52:	28 2f       	mov	r18, r24
    4d54:	30 e0       	ldi	r19, 0x00	; 0
    4d56:	c9 01       	movw	r24, r18
    4d58:	88 0f       	add	r24, r24
    4d5a:	99 1f       	adc	r25, r25
    4d5c:	88 0f       	add	r24, r24
    4d5e:	99 1f       	adc	r25, r25
    4d60:	88 0f       	add	r24, r24
    4d62:	99 1f       	adc	r25, r25
    4d64:	82 0f       	add	r24, r18
    4d66:	93 1f       	adc	r25, r19
    4d68:	ac 01       	movw	r20, r24
    4d6a:	46 50       	subi	r20, 0x06	; 6
    4d6c:	5f 4f       	sbci	r21, 0xFF	; 255
    4d6e:	89 81       	ldd	r24, Y+1	; 0x01
    4d70:	9a 81       	ldd	r25, Y+2	; 0x02
    4d72:	9c 01       	movw	r18, r24
    4d74:	2e 5f       	subi	r18, 0xFE	; 254
    4d76:	3f 4f       	sbci	r19, 0xFF	; 255
    4d78:	ca 01       	movw	r24, r20
    4d7a:	b9 01       	movw	r22, r18
    4d7c:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <vListInsertEnd>
			}
		}
	}
    4d80:	0f 90       	pop	r0
    4d82:	0f 90       	pop	r0
    4d84:	0f 90       	pop	r0
    4d86:	0f 90       	pop	r0
    4d88:	cf 91       	pop	r28
    4d8a:	df 91       	pop	r29
    4d8c:	08 95       	ret

00004d8e <__divmodhi4>:
    4d8e:	97 fb       	bst	r25, 7
    4d90:	09 2e       	mov	r0, r25
    4d92:	07 26       	eor	r0, r23
    4d94:	0a d0       	rcall	.+20     	; 0x4daa <__divmodhi4_neg1>
    4d96:	77 fd       	sbrc	r23, 7
    4d98:	04 d0       	rcall	.+8      	; 0x4da2 <__divmodhi4_neg2>
    4d9a:	0c d0       	rcall	.+24     	; 0x4db4 <__udivmodhi4>
    4d9c:	06 d0       	rcall	.+12     	; 0x4daa <__divmodhi4_neg1>
    4d9e:	00 20       	and	r0, r0
    4da0:	1a f4       	brpl	.+6      	; 0x4da8 <__divmodhi4_exit>

00004da2 <__divmodhi4_neg2>:
    4da2:	70 95       	com	r23
    4da4:	61 95       	neg	r22
    4da6:	7f 4f       	sbci	r23, 0xFF	; 255

00004da8 <__divmodhi4_exit>:
    4da8:	08 95       	ret

00004daa <__divmodhi4_neg1>:
    4daa:	f6 f7       	brtc	.-4      	; 0x4da8 <__divmodhi4_exit>
    4dac:	90 95       	com	r25
    4dae:	81 95       	neg	r24
    4db0:	9f 4f       	sbci	r25, 0xFF	; 255
    4db2:	08 95       	ret

00004db4 <__udivmodhi4>:
    4db4:	aa 1b       	sub	r26, r26
    4db6:	bb 1b       	sub	r27, r27
    4db8:	51 e1       	ldi	r21, 0x11	; 17
    4dba:	07 c0       	rjmp	.+14     	; 0x4dca <__udivmodhi4_ep>

00004dbc <__udivmodhi4_loop>:
    4dbc:	aa 1f       	adc	r26, r26
    4dbe:	bb 1f       	adc	r27, r27
    4dc0:	a6 17       	cp	r26, r22
    4dc2:	b7 07       	cpc	r27, r23
    4dc4:	10 f0       	brcs	.+4      	; 0x4dca <__udivmodhi4_ep>
    4dc6:	a6 1b       	sub	r26, r22
    4dc8:	b7 0b       	sbc	r27, r23

00004dca <__udivmodhi4_ep>:
    4dca:	88 1f       	adc	r24, r24
    4dcc:	99 1f       	adc	r25, r25
    4dce:	5a 95       	dec	r21
    4dd0:	a9 f7       	brne	.-22     	; 0x4dbc <__udivmodhi4_loop>
    4dd2:	80 95       	com	r24
    4dd4:	90 95       	com	r25
    4dd6:	bc 01       	movw	r22, r24
    4dd8:	cd 01       	movw	r24, r26
    4dda:	08 95       	ret

00004ddc <__prologue_saves__>:
    4ddc:	2f 92       	push	r2
    4dde:	3f 92       	push	r3
    4de0:	4f 92       	push	r4
    4de2:	5f 92       	push	r5
    4de4:	6f 92       	push	r6
    4de6:	7f 92       	push	r7
    4de8:	8f 92       	push	r8
    4dea:	9f 92       	push	r9
    4dec:	af 92       	push	r10
    4dee:	bf 92       	push	r11
    4df0:	cf 92       	push	r12
    4df2:	df 92       	push	r13
    4df4:	ef 92       	push	r14
    4df6:	ff 92       	push	r15
    4df8:	0f 93       	push	r16
    4dfa:	1f 93       	push	r17
    4dfc:	cf 93       	push	r28
    4dfe:	df 93       	push	r29
    4e00:	cd b7       	in	r28, 0x3d	; 61
    4e02:	de b7       	in	r29, 0x3e	; 62
    4e04:	ca 1b       	sub	r28, r26
    4e06:	db 0b       	sbc	r29, r27
    4e08:	0f b6       	in	r0, 0x3f	; 63
    4e0a:	f8 94       	cli
    4e0c:	de bf       	out	0x3e, r29	; 62
    4e0e:	0f be       	out	0x3f, r0	; 63
    4e10:	cd bf       	out	0x3d, r28	; 61
    4e12:	09 94       	ijmp

00004e14 <__epilogue_restores__>:
    4e14:	2a 88       	ldd	r2, Y+18	; 0x12
    4e16:	39 88       	ldd	r3, Y+17	; 0x11
    4e18:	48 88       	ldd	r4, Y+16	; 0x10
    4e1a:	5f 84       	ldd	r5, Y+15	; 0x0f
    4e1c:	6e 84       	ldd	r6, Y+14	; 0x0e
    4e1e:	7d 84       	ldd	r7, Y+13	; 0x0d
    4e20:	8c 84       	ldd	r8, Y+12	; 0x0c
    4e22:	9b 84       	ldd	r9, Y+11	; 0x0b
    4e24:	aa 84       	ldd	r10, Y+10	; 0x0a
    4e26:	b9 84       	ldd	r11, Y+9	; 0x09
    4e28:	c8 84       	ldd	r12, Y+8	; 0x08
    4e2a:	df 80       	ldd	r13, Y+7	; 0x07
    4e2c:	ee 80       	ldd	r14, Y+6	; 0x06
    4e2e:	fd 80       	ldd	r15, Y+5	; 0x05
    4e30:	0c 81       	ldd	r16, Y+4	; 0x04
    4e32:	1b 81       	ldd	r17, Y+3	; 0x03
    4e34:	aa 81       	ldd	r26, Y+2	; 0x02
    4e36:	b9 81       	ldd	r27, Y+1	; 0x01
    4e38:	ce 0f       	add	r28, r30
    4e3a:	d1 1d       	adc	r29, r1
    4e3c:	0f b6       	in	r0, 0x3f	; 63
    4e3e:	f8 94       	cli
    4e40:	de bf       	out	0x3e, r29	; 62
    4e42:	0f be       	out	0x3f, r0	; 63
    4e44:	cd bf       	out	0x3d, r28	; 61
    4e46:	ed 01       	movw	r28, r26
    4e48:	08 95       	ret

00004e4a <malloc>:
    4e4a:	cf 93       	push	r28
    4e4c:	df 93       	push	r29
    4e4e:	bc 01       	movw	r22, r24
    4e50:	82 30       	cpi	r24, 0x02	; 2
    4e52:	91 05       	cpc	r25, r1
    4e54:	10 f4       	brcc	.+4      	; 0x4e5a <malloc+0x10>
    4e56:	62 e0       	ldi	r22, 0x02	; 2
    4e58:	70 e0       	ldi	r23, 0x00	; 0
    4e5a:	a0 91 56 01 	lds	r26, 0x0156
    4e5e:	b0 91 57 01 	lds	r27, 0x0157
    4e62:	ed 01       	movw	r28, r26
    4e64:	e0 e0       	ldi	r30, 0x00	; 0
    4e66:	f0 e0       	ldi	r31, 0x00	; 0
    4e68:	40 e0       	ldi	r20, 0x00	; 0
    4e6a:	50 e0       	ldi	r21, 0x00	; 0
    4e6c:	21 c0       	rjmp	.+66     	; 0x4eb0 <malloc+0x66>
    4e6e:	88 81       	ld	r24, Y
    4e70:	99 81       	ldd	r25, Y+1	; 0x01
    4e72:	86 17       	cp	r24, r22
    4e74:	97 07       	cpc	r25, r23
    4e76:	69 f4       	brne	.+26     	; 0x4e92 <malloc+0x48>
    4e78:	8a 81       	ldd	r24, Y+2	; 0x02
    4e7a:	9b 81       	ldd	r25, Y+3	; 0x03
    4e7c:	30 97       	sbiw	r30, 0x00	; 0
    4e7e:	19 f0       	breq	.+6      	; 0x4e86 <malloc+0x3c>
    4e80:	93 83       	std	Z+3, r25	; 0x03
    4e82:	82 83       	std	Z+2, r24	; 0x02
    4e84:	04 c0       	rjmp	.+8      	; 0x4e8e <malloc+0x44>
    4e86:	90 93 57 01 	sts	0x0157, r25
    4e8a:	80 93 56 01 	sts	0x0156, r24
    4e8e:	fe 01       	movw	r30, r28
    4e90:	34 c0       	rjmp	.+104    	; 0x4efa <malloc+0xb0>
    4e92:	68 17       	cp	r22, r24
    4e94:	79 07       	cpc	r23, r25
    4e96:	38 f4       	brcc	.+14     	; 0x4ea6 <malloc+0x5c>
    4e98:	41 15       	cp	r20, r1
    4e9a:	51 05       	cpc	r21, r1
    4e9c:	19 f0       	breq	.+6      	; 0x4ea4 <malloc+0x5a>
    4e9e:	84 17       	cp	r24, r20
    4ea0:	95 07       	cpc	r25, r21
    4ea2:	08 f4       	brcc	.+2      	; 0x4ea6 <malloc+0x5c>
    4ea4:	ac 01       	movw	r20, r24
    4ea6:	fe 01       	movw	r30, r28
    4ea8:	8a 81       	ldd	r24, Y+2	; 0x02
    4eaa:	9b 81       	ldd	r25, Y+3	; 0x03
    4eac:	9c 01       	movw	r18, r24
    4eae:	e9 01       	movw	r28, r18
    4eb0:	20 97       	sbiw	r28, 0x00	; 0
    4eb2:	e9 f6       	brne	.-70     	; 0x4e6e <malloc+0x24>
    4eb4:	41 15       	cp	r20, r1
    4eb6:	51 05       	cpc	r21, r1
    4eb8:	a9 f1       	breq	.+106    	; 0x4f24 <malloc+0xda>
    4eba:	ca 01       	movw	r24, r20
    4ebc:	86 1b       	sub	r24, r22
    4ebe:	97 0b       	sbc	r25, r23
    4ec0:	04 97       	sbiw	r24, 0x04	; 4
    4ec2:	08 f4       	brcc	.+2      	; 0x4ec6 <malloc+0x7c>
    4ec4:	ba 01       	movw	r22, r20
    4ec6:	e0 e0       	ldi	r30, 0x00	; 0
    4ec8:	f0 e0       	ldi	r31, 0x00	; 0
    4eca:	2a c0       	rjmp	.+84     	; 0x4f20 <malloc+0xd6>
    4ecc:	8d 91       	ld	r24, X+
    4ece:	9c 91       	ld	r25, X
    4ed0:	11 97       	sbiw	r26, 0x01	; 1
    4ed2:	84 17       	cp	r24, r20
    4ed4:	95 07       	cpc	r25, r21
    4ed6:	f9 f4       	brne	.+62     	; 0x4f16 <malloc+0xcc>
    4ed8:	64 17       	cp	r22, r20
    4eda:	75 07       	cpc	r23, r21
    4edc:	81 f4       	brne	.+32     	; 0x4efe <malloc+0xb4>
    4ede:	12 96       	adiw	r26, 0x02	; 2
    4ee0:	8d 91       	ld	r24, X+
    4ee2:	9c 91       	ld	r25, X
    4ee4:	13 97       	sbiw	r26, 0x03	; 3
    4ee6:	30 97       	sbiw	r30, 0x00	; 0
    4ee8:	19 f0       	breq	.+6      	; 0x4ef0 <malloc+0xa6>
    4eea:	93 83       	std	Z+3, r25	; 0x03
    4eec:	82 83       	std	Z+2, r24	; 0x02
    4eee:	04 c0       	rjmp	.+8      	; 0x4ef8 <malloc+0xae>
    4ef0:	90 93 57 01 	sts	0x0157, r25
    4ef4:	80 93 56 01 	sts	0x0156, r24
    4ef8:	fd 01       	movw	r30, r26
    4efa:	32 96       	adiw	r30, 0x02	; 2
    4efc:	4f c0       	rjmp	.+158    	; 0x4f9c <malloc+0x152>
    4efe:	ca 01       	movw	r24, r20
    4f00:	86 1b       	sub	r24, r22
    4f02:	97 0b       	sbc	r25, r23
    4f04:	fd 01       	movw	r30, r26
    4f06:	e8 0f       	add	r30, r24
    4f08:	f9 1f       	adc	r31, r25
    4f0a:	61 93       	st	Z+, r22
    4f0c:	71 93       	st	Z+, r23
    4f0e:	02 97       	sbiw	r24, 0x02	; 2
    4f10:	8d 93       	st	X+, r24
    4f12:	9c 93       	st	X, r25
    4f14:	43 c0       	rjmp	.+134    	; 0x4f9c <malloc+0x152>
    4f16:	fd 01       	movw	r30, r26
    4f18:	82 81       	ldd	r24, Z+2	; 0x02
    4f1a:	93 81       	ldd	r25, Z+3	; 0x03
    4f1c:	9c 01       	movw	r18, r24
    4f1e:	d9 01       	movw	r26, r18
    4f20:	10 97       	sbiw	r26, 0x00	; 0
    4f22:	a1 f6       	brne	.-88     	; 0x4ecc <malloc+0x82>
    4f24:	80 91 54 01 	lds	r24, 0x0154
    4f28:	90 91 55 01 	lds	r25, 0x0155
    4f2c:	89 2b       	or	r24, r25
    4f2e:	41 f4       	brne	.+16     	; 0x4f40 <malloc+0xf6>
    4f30:	80 91 ab 00 	lds	r24, 0x00AB
    4f34:	90 91 ac 00 	lds	r25, 0x00AC
    4f38:	90 93 55 01 	sts	0x0155, r25
    4f3c:	80 93 54 01 	sts	0x0154, r24
    4f40:	40 91 ad 00 	lds	r20, 0x00AD
    4f44:	50 91 ae 00 	lds	r21, 0x00AE
    4f48:	41 15       	cp	r20, r1
    4f4a:	51 05       	cpc	r21, r1
    4f4c:	41 f4       	brne	.+16     	; 0x4f5e <malloc+0x114>
    4f4e:	4d b7       	in	r20, 0x3d	; 61
    4f50:	5e b7       	in	r21, 0x3e	; 62
    4f52:	80 91 a9 00 	lds	r24, 0x00A9
    4f56:	90 91 aa 00 	lds	r25, 0x00AA
    4f5a:	48 1b       	sub	r20, r24
    4f5c:	59 0b       	sbc	r21, r25
    4f5e:	20 91 54 01 	lds	r18, 0x0154
    4f62:	30 91 55 01 	lds	r19, 0x0155
    4f66:	24 17       	cp	r18, r20
    4f68:	35 07       	cpc	r19, r21
    4f6a:	b0 f4       	brcc	.+44     	; 0x4f98 <malloc+0x14e>
    4f6c:	ca 01       	movw	r24, r20
    4f6e:	82 1b       	sub	r24, r18
    4f70:	93 0b       	sbc	r25, r19
    4f72:	86 17       	cp	r24, r22
    4f74:	97 07       	cpc	r25, r23
    4f76:	80 f0       	brcs	.+32     	; 0x4f98 <malloc+0x14e>
    4f78:	ab 01       	movw	r20, r22
    4f7a:	4e 5f       	subi	r20, 0xFE	; 254
    4f7c:	5f 4f       	sbci	r21, 0xFF	; 255
    4f7e:	84 17       	cp	r24, r20
    4f80:	95 07       	cpc	r25, r21
    4f82:	50 f0       	brcs	.+20     	; 0x4f98 <malloc+0x14e>
    4f84:	42 0f       	add	r20, r18
    4f86:	53 1f       	adc	r21, r19
    4f88:	50 93 55 01 	sts	0x0155, r21
    4f8c:	40 93 54 01 	sts	0x0154, r20
    4f90:	f9 01       	movw	r30, r18
    4f92:	61 93       	st	Z+, r22
    4f94:	71 93       	st	Z+, r23
    4f96:	02 c0       	rjmp	.+4      	; 0x4f9c <malloc+0x152>
    4f98:	e0 e0       	ldi	r30, 0x00	; 0
    4f9a:	f0 e0       	ldi	r31, 0x00	; 0
    4f9c:	cf 01       	movw	r24, r30
    4f9e:	df 91       	pop	r29
    4fa0:	cf 91       	pop	r28
    4fa2:	08 95       	ret

00004fa4 <free>:
    4fa4:	cf 93       	push	r28
    4fa6:	df 93       	push	r29
    4fa8:	00 97       	sbiw	r24, 0x00	; 0
    4faa:	09 f4       	brne	.+2      	; 0x4fae <free+0xa>
    4fac:	50 c0       	rjmp	.+160    	; 0x504e <free+0xaa>
    4fae:	ec 01       	movw	r28, r24
    4fb0:	22 97       	sbiw	r28, 0x02	; 2
    4fb2:	1b 82       	std	Y+3, r1	; 0x03
    4fb4:	1a 82       	std	Y+2, r1	; 0x02
    4fb6:	a0 91 56 01 	lds	r26, 0x0156
    4fba:	b0 91 57 01 	lds	r27, 0x0157
    4fbe:	10 97       	sbiw	r26, 0x00	; 0
    4fc0:	09 f1       	breq	.+66     	; 0x5004 <free+0x60>
    4fc2:	40 e0       	ldi	r20, 0x00	; 0
    4fc4:	50 e0       	ldi	r21, 0x00	; 0
    4fc6:	ac 17       	cp	r26, r28
    4fc8:	bd 07       	cpc	r27, r29
    4fca:	08 f1       	brcs	.+66     	; 0x500e <free+0x6a>
    4fcc:	bb 83       	std	Y+3, r27	; 0x03
    4fce:	aa 83       	std	Y+2, r26	; 0x02
    4fd0:	fe 01       	movw	r30, r28
    4fd2:	21 91       	ld	r18, Z+
    4fd4:	31 91       	ld	r19, Z+
    4fd6:	e2 0f       	add	r30, r18
    4fd8:	f3 1f       	adc	r31, r19
    4fda:	ae 17       	cp	r26, r30
    4fdc:	bf 07       	cpc	r27, r31
    4fde:	79 f4       	brne	.+30     	; 0x4ffe <free+0x5a>
    4fe0:	8d 91       	ld	r24, X+
    4fe2:	9c 91       	ld	r25, X
    4fe4:	11 97       	sbiw	r26, 0x01	; 1
    4fe6:	28 0f       	add	r18, r24
    4fe8:	39 1f       	adc	r19, r25
    4fea:	2e 5f       	subi	r18, 0xFE	; 254
    4fec:	3f 4f       	sbci	r19, 0xFF	; 255
    4fee:	39 83       	std	Y+1, r19	; 0x01
    4ff0:	28 83       	st	Y, r18
    4ff2:	12 96       	adiw	r26, 0x02	; 2
    4ff4:	8d 91       	ld	r24, X+
    4ff6:	9c 91       	ld	r25, X
    4ff8:	13 97       	sbiw	r26, 0x03	; 3
    4ffa:	9b 83       	std	Y+3, r25	; 0x03
    4ffc:	8a 83       	std	Y+2, r24	; 0x02
    4ffe:	41 15       	cp	r20, r1
    5000:	51 05       	cpc	r21, r1
    5002:	71 f4       	brne	.+28     	; 0x5020 <free+0x7c>
    5004:	d0 93 57 01 	sts	0x0157, r29
    5008:	c0 93 56 01 	sts	0x0156, r28
    500c:	20 c0       	rjmp	.+64     	; 0x504e <free+0xaa>
    500e:	12 96       	adiw	r26, 0x02	; 2
    5010:	8d 91       	ld	r24, X+
    5012:	9c 91       	ld	r25, X
    5014:	13 97       	sbiw	r26, 0x03	; 3
    5016:	ad 01       	movw	r20, r26
    5018:	00 97       	sbiw	r24, 0x00	; 0
    501a:	11 f0       	breq	.+4      	; 0x5020 <free+0x7c>
    501c:	dc 01       	movw	r26, r24
    501e:	d3 cf       	rjmp	.-90     	; 0x4fc6 <free+0x22>
    5020:	fa 01       	movw	r30, r20
    5022:	d3 83       	std	Z+3, r29	; 0x03
    5024:	c2 83       	std	Z+2, r28	; 0x02
    5026:	21 91       	ld	r18, Z+
    5028:	31 91       	ld	r19, Z+
    502a:	e2 0f       	add	r30, r18
    502c:	f3 1f       	adc	r31, r19
    502e:	ce 17       	cp	r28, r30
    5030:	df 07       	cpc	r29, r31
    5032:	69 f4       	brne	.+26     	; 0x504e <free+0xaa>
    5034:	88 81       	ld	r24, Y
    5036:	99 81       	ldd	r25, Y+1	; 0x01
    5038:	28 0f       	add	r18, r24
    503a:	39 1f       	adc	r19, r25
    503c:	2e 5f       	subi	r18, 0xFE	; 254
    503e:	3f 4f       	sbci	r19, 0xFF	; 255
    5040:	fa 01       	movw	r30, r20
    5042:	31 83       	std	Z+1, r19	; 0x01
    5044:	20 83       	st	Z, r18
    5046:	8a 81       	ldd	r24, Y+2	; 0x02
    5048:	9b 81       	ldd	r25, Y+3	; 0x03
    504a:	93 83       	std	Z+3, r25	; 0x03
    504c:	82 83       	std	Z+2, r24	; 0x02
    504e:	df 91       	pop	r29
    5050:	cf 91       	pop	r28
    5052:	08 95       	ret

00005054 <memcpy>:
    5054:	fb 01       	movw	r30, r22
    5056:	dc 01       	movw	r26, r24
    5058:	02 c0       	rjmp	.+4      	; 0x505e <memcpy+0xa>
    505a:	01 90       	ld	r0, Z+
    505c:	0d 92       	st	X+, r0
    505e:	41 50       	subi	r20, 0x01	; 1
    5060:	50 40       	sbci	r21, 0x00	; 0
    5062:	d8 f7       	brcc	.-10     	; 0x505a <memcpy+0x6>
    5064:	08 95       	ret

00005066 <memset>:
    5066:	dc 01       	movw	r26, r24
    5068:	01 c0       	rjmp	.+2      	; 0x506c <memset+0x6>
    506a:	6d 93       	st	X+, r22
    506c:	41 50       	subi	r20, 0x01	; 1
    506e:	50 40       	sbci	r21, 0x00	; 0
    5070:	e0 f7       	brcc	.-8      	; 0x506a <memset+0x4>
    5072:	08 95       	ret

00005074 <strncpy>:
    5074:	fb 01       	movw	r30, r22
    5076:	dc 01       	movw	r26, r24
    5078:	41 50       	subi	r20, 0x01	; 1
    507a:	50 40       	sbci	r21, 0x00	; 0
    507c:	48 f0       	brcs	.+18     	; 0x5090 <strncpy+0x1c>
    507e:	01 90       	ld	r0, Z+
    5080:	0d 92       	st	X+, r0
    5082:	00 20       	and	r0, r0
    5084:	c9 f7       	brne	.-14     	; 0x5078 <strncpy+0x4>
    5086:	01 c0       	rjmp	.+2      	; 0x508a <strncpy+0x16>
    5088:	1d 92       	st	X+, r1
    508a:	41 50       	subi	r20, 0x01	; 1
    508c:	50 40       	sbci	r21, 0x00	; 0
    508e:	e0 f7       	brcc	.-8      	; 0x5088 <strncpy+0x14>
    5090:	08 95       	ret

00005092 <itoa>:
    5092:	fb 01       	movw	r30, r22
    5094:	9f 01       	movw	r18, r30
    5096:	e8 94       	clt
    5098:	42 30       	cpi	r20, 0x02	; 2
    509a:	c4 f0       	brlt	.+48     	; 0x50cc <itoa+0x3a>
    509c:	45 32       	cpi	r20, 0x25	; 37
    509e:	b4 f4       	brge	.+44     	; 0x50cc <itoa+0x3a>
    50a0:	4a 30       	cpi	r20, 0x0A	; 10
    50a2:	29 f4       	brne	.+10     	; 0x50ae <itoa+0x1c>
    50a4:	97 fb       	bst	r25, 7
    50a6:	1e f4       	brtc	.+6      	; 0x50ae <itoa+0x1c>
    50a8:	90 95       	com	r25
    50aa:	81 95       	neg	r24
    50ac:	9f 4f       	sbci	r25, 0xFF	; 255
    50ae:	64 2f       	mov	r22, r20
    50b0:	77 27       	eor	r23, r23
    50b2:	0e 94 da 26 	call	0x4db4	; 0x4db4 <__udivmodhi4>
    50b6:	80 5d       	subi	r24, 0xD0	; 208
    50b8:	8a 33       	cpi	r24, 0x3A	; 58
    50ba:	0c f0       	brlt	.+2      	; 0x50be <itoa+0x2c>
    50bc:	89 5d       	subi	r24, 0xD9	; 217
    50be:	81 93       	st	Z+, r24
    50c0:	cb 01       	movw	r24, r22
    50c2:	00 97       	sbiw	r24, 0x00	; 0
    50c4:	a1 f7       	brne	.-24     	; 0x50ae <itoa+0x1c>
    50c6:	16 f4       	brtc	.+4      	; 0x50cc <itoa+0x3a>
    50c8:	5d e2       	ldi	r21, 0x2D	; 45
    50ca:	51 93       	st	Z+, r21
    50cc:	10 82       	st	Z, r1
    50ce:	c9 01       	movw	r24, r18
    50d0:	0c 94 6a 28 	jmp	0x50d4	; 0x50d4 <strrev>

000050d4 <strrev>:
    50d4:	dc 01       	movw	r26, r24
    50d6:	fc 01       	movw	r30, r24
    50d8:	67 2f       	mov	r22, r23
    50da:	71 91       	ld	r23, Z+
    50dc:	77 23       	and	r23, r23
    50de:	e1 f7       	brne	.-8      	; 0x50d8 <strrev+0x4>
    50e0:	32 97       	sbiw	r30, 0x02	; 2
    50e2:	04 c0       	rjmp	.+8      	; 0x50ec <strrev+0x18>
    50e4:	7c 91       	ld	r23, X
    50e6:	6d 93       	st	X+, r22
    50e8:	70 83       	st	Z, r23
    50ea:	62 91       	ld	r22, -Z
    50ec:	ae 17       	cp	r26, r30
    50ee:	bf 07       	cpc	r27, r31
    50f0:	c8 f3       	brcs	.-14     	; 0x50e4 <strrev+0x10>
    50f2:	08 95       	ret

000050f4 <_exit>:
    50f4:	f8 94       	cli

000050f6 <__stop_program>:
    50f6:	ff cf       	rjmp	.-2      	; 0x50f6 <__stop_program>
